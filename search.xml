<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【apue】动态进程池]]></title>
      <url>/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91%E5%8A%A8%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>引言：<br>&emsp;回顾之前文章《socket - STREAM》中的例程，服务端接受客户端请求后，fork子进程来响应请求。但这样无限制地fork进程，当请求非常多时，会导致fork失败，服务端将无法响应客户端请求。</p>
<p>我们可以借鉴之前线程池的思想，创建一个进程池处理。<br>①静态进程池：直接fork出N个子进程，然后由N个子进程接受客户端的连接，响应他们的请求。（不灵活，且创建的进程个数比较难确定；进程数少了，请求多时可能无法及时响应；进程数多了，可能造成资源浪费。）</p>
<p>②动态进程池：进程池上限为MAXCLIENT，允许最少存在X个空闲进程（没有与客户端连接），最多存在Y个空闲进程。程序先创建X个子进程，当请求增多时，继续fork进程响应请求；当请求减少时，存在较多空闲进程时，kill空闲进程。</p>
<p>例程：server.c（服务端）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MAXCLIENT 20</span></span><br><span class="line"><span class="comment">#define MINIDLESERVER 5     </span></span><br><span class="line"><span class="comment">#define MAXIDLESERVER 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SIG_NOTIFY  SIGUSR2</span></span><br><span class="line"><span class="comment">#define BUFSIZE     1024</span></span><br><span class="line"><span class="comment">#define IPSTRSIZE   40</span></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    STAT_IDLE = 1,</span><br><span class="line">    STAT_BUSY</span><br><span class="line">&#125;;</span><br><span class="line">struct server_st</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int sd;</span><br><span class="line">static int busy_count,idle_count;</span><br><span class="line">static struct server_st *server_pool; //struct array address</span><br><span class="line"></span><br><span class="line">static int establish_socket(void);</span><br><span class="line">static int creat_pool(void);</span><br><span class="line">static void manage_pool(void);</span><br><span class="line"></span><br><span class="line">static void usr_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void server_job(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t ppid;</span><br><span class="line">    int client_sd;</span><br><span class="line">    struct sockaddr_in raddr;</span><br><span class="line">    socklen_t raddr_len;</span><br><span class="line">    time_t stamp;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    char ipstr[IPSTRSIZE];</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    raddr_len = sizeof(raddr);</span><br><span class="line">    ppid = getppid();</span><br><span class="line">    <span class="keyword">if</span>(ppid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"getppid()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        server_pool[pos].state = STAT_IDLE;</span><br><span class="line">        <span class="built_in">kill</span>(ppid,SIG_NOTIFY);</span><br><span class="line"></span><br><span class="line">        client_sd = accept(sd,(void *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(client_sd &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"accept()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server_pool[pos].state = STAT_BUSY;</span><br><span class="line">        <span class="built_in">kill</span>(ppid,SIG_NOTIFY);//notify parent process the check server pool, mainly to caculate the busy_count</span><br><span class="line"></span><br><span class="line">//        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">//        <span class="built_in">printf</span>(<span class="string">"client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        stamp = time(NULL);</span><br><span class="line">        len = snprintf(buf,BUFSIZE,<span class="string">"%ld\n"</span>,(long)stamp);//can<span class="string">'t be long long</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if(send(client_sd,buf,len,0) &lt; 0)//can'</span>t be sd</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"send()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(5);</span><br><span class="line">        close(client_sd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //avoid zombie process(the children will be reclaimed by init process; parent process mustn<span class="string">'t call wait()) and children will not send SIGCHLD to parent process when they terminate</span></span><br><span class="line"><span class="string">    struct sigaction sa;//sa is temp val</span></span><br><span class="line"><span class="string">    sa.sa_handler = SIG_IGN;</span></span><br><span class="line"><span class="string">    sigemptyset(&amp;sa.sa_mask);</span></span><br><span class="line"><span class="string">    sa.sa_flags = SA_NOCLDWAIT;</span></span><br><span class="line"><span class="string">    sigaction(SIGCHLD,&amp;sa,NULL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    //do nothing, just as a driver signal</span></span><br><span class="line"><span class="string">    sa.sa_handler  = usr_handler;</span></span><br><span class="line"><span class="string">    sigemptyset(&amp;sa.sa_mask);</span></span><br><span class="line"><span class="string">    sa.sa_flags = 0;</span></span><br><span class="line"><span class="string">    sigaction(SIG_NOTIFY,&amp;sa,NULL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    establish_socket();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    //puts("establish_socket ok");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if(creat_pool() &lt; 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        fprintf(stderr,"creat_pool() fail!\n");</span></span><br><span class="line"><span class="string">        exit(1);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    //puts("creat_pool ok");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    manage_pool();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    exit(0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static int get_free_pos(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int i;</span></span><br><span class="line"><span class="string">    if(idle_count + busy_count &gt;= MAXCLIENT)</span></span><br><span class="line"><span class="string">        return -1;</span></span><br><span class="line"><span class="string">    for(i = 0; i &lt; MAXCLIENT; i++)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if(server_pool[i].pid == -1)</span></span><br><span class="line"><span class="string">            return i;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return -1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static int add_1_server(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int pos;</span></span><br><span class="line"><span class="string">    pid_t pid;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pos = get_free_pos();</span></span><br><span class="line"><span class="string">    if(pos &lt; 0)</span></span><br><span class="line"><span class="string">        return -1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    server_pool[pos].state = STAT_IDLE;</span></span><br><span class="line"><span class="string">    pid = fork();</span></span><br><span class="line"><span class="string">    if(pid &lt; 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        perror("fork");</span></span><br><span class="line"><span class="string">        exit(1);</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">    if(pid == 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        server_job(pos);</span></span><br><span class="line"><span class="string">        exit(0);</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        server_pool[pos].pid = pid;</span></span><br><span class="line"><span class="string">        idle_count ++;</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;   </span></span><br><span class="line"><span class="string">static int del_1_server(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int i;</span></span><br><span class="line"><span class="string">    if(idle_count == 0)</span></span><br><span class="line"><span class="string">        return -1;</span></span><br><span class="line"><span class="string">    for(i = 0; i &lt; MAXCLIENT; i++)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if(server_pool[i].pid != -1 &amp;&amp; server_pool[i].state == STAT_IDLE)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            kill(server_pool[i].pid,SIGTERM);//terminal child process</span></span><br><span class="line"><span class="string">            server_pool[i].pid = -1;</span></span><br><span class="line"><span class="string">            idle_count --;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">static int scan_pool(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int i;</span></span><br><span class="line"><span class="string">    int idle = 0,busy = 0;</span></span><br><span class="line"><span class="string">    for(i = 0; i &lt; MAXCLIENT; i++)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if(server_pool[i].pid == -1)//unused</span></span><br><span class="line"><span class="string">            continue;</span></span><br><span class="line"><span class="string">        if(kill(server_pool[i].pid,0) == ESRCH)//the process don'</span>t exist</span><br><span class="line">        &#123;</span><br><span class="line">            server_pool[i].pid = -1;</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(server_pool[i].state == STAT_IDLE)</span><br><span class="line">            idle ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(server_pool[i].state == STAT_BUSY)</span><br><span class="line">            busy ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fprintf(stderr,<span class="string">"unkown state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    idle_count = idle;</span><br><span class="line">    busy_count = busy;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***************************************</span><br><span class="line">1 get socket        SOCK_STREAM</span><br><span class="line">2 <span class="built_in">set</span> sockopt       SO_REUSEADDR</span><br><span class="line">3 <span class="built_in">bind</span> laddr        <span class="string">"0.0.0.0"</span>:1999</span><br><span class="line">4 <span class="built_in">set</span> listen        max:200</span><br><span class="line">****************************************/</span><br><span class="line">static int establish_socket(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_in laddr;</span><br><span class="line">    int val = 1;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,sizeof(val)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVER_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,200) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int creat_pool(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    server_pool = mmap(NULL,sizeof(struct server_st)*MAXCLIENT,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);</span><br><span class="line">    <span class="keyword">if</span>(server_pool == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        //puts(<span class="string">"mmap() fail"</span>);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(server_pool,-1,sizeof(struct server_st)*MAXCLIENT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//signal dirver program</span><br><span class="line">static void manage_pool(void)</span><br><span class="line">&#123;</span><br><span class="line">    sigset_t <span class="built_in">set</span>,oset;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIG_NOTIFY);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MINIDLESERVER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(add_1_server() &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"init minidle server fail\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        //<span class="built_in">wait</span> <span class="keyword">for</span> a signal; when receive SIG_NOTIFY, use oset replace <span class="built_in">set</span>, <span class="keyword">then</span> block and <span class="built_in">wait</span> the next SIG_NOTIFY</span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line"></span><br><span class="line">        scan_pool();//update the busy_count and idle_count</span><br><span class="line"></span><br><span class="line">        //contrl the pool, keep the idleserver count [5,10]</span><br><span class="line">        <span class="keyword">if</span>(idle_count &gt; MAXIDLESERVER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = 0; i &lt; (idle_count - MAXIDLESERVER); i++)</span><br><span class="line">                del_1_server();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(idle_count &lt; MINIDLESERVER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = 0; i &lt; (MINIDLESERVER - idle_count); i++)</span><br><span class="line">                add_1_server();</span><br><span class="line">        &#125;</span><br><span class="line">        //<span class="built_in">printf</span> pool state</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; MAXCLIENT; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(server_pool[i].pid == -1)</span><br><span class="line">                putchar(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(server_pool[i].state == STAT_IDLE)</span><br><span class="line">                putchar(<span class="string">'u'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(server_pool[i].state == STAT_BUSY)</span><br><span class="line">                putchar(<span class="string">'x'</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fprintf(stderr,<span class="string">"unkown state.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        putchar(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oset,NULL);//recover sigset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>改进：实际工程中，服务端要做成守护进程，然后其中的报错要改成提交系统日志（syslog）。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动态进程池 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】如何避免僵尸进程]]></title>
      <url>/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>引言：<br>&emsp;<strong>对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。<br>    如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。<br>    如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。</strong></p>
<p><em>一个子进程在终止或停止时，会向其父进程发送SIGCHLD信号</em>。</p>
<p>对于SIGCHLD信号，如果我们定义为：</p>
<blockquote>
<p>1.SIG_DFL：默认的处理方式是不理会这个信号，但是也不会丢弃子进行状态，所以如果不用wait，waitpid对其子进行进行状态信息回收，会产生僵尸进程。<br>2.SIG_IGN：忽略，此时我们的子进程终止的时候，由init进程进程回收，所以不会产生僵尸进程。（不需要要在父进程中调用wait()）</p>
</blockquote>
<p>如果调用sigaction（）函数，且sa_flag中设置了SA_NOCLDWAIT标志，则子进程终止时候，不产生僵尸进程，<strong>同时不向父进程发送SIGCHLD信号</strong></p>
<p>(例程见下一篇：动态进程池)</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SIGCHLD信号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】socket - STREAM]]></title>
      <url>/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91socket-STREAM/</url>
      <content type="html"><![CDATA[<p><strong>流式套接字</strong>(面向连接的套接字)</p>
<blockquote>
<pre><code>能保证收到的消息是正确的(可靠)
 通信之前必须先建立一个连接
 socket();
 bind();
 listen();
 accept();
 connect()；
 send();
 close();</code></pre></blockquote>
<p><strong>SOCK_STREAM</strong>: 提供有序的、可靠的、双工的、基于连接的字节流。可支持带外数据传输机制。 </p>
<p>异常退出后，如果端口没有被及时回收，再次bind会报错；<br>解决：setsockopt()，SO_REUSEADDR参数。</p>
<p>例程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">//proto.h</span><br><span class="line"><span class="comment">#ifndef PROTO_H__</span></span><br><span class="line"><span class="comment">#define PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SERVER_PORT "1999"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//client.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int sd,newsd;</span><br><span class="line">    struct sockaddr_in raddr;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    long long stamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVER_PORT));</span><br><span class="line">    inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sd,(void *)&amp;raddr,sizeof(raddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // connect server success!!!</span><br><span class="line"></span><br><span class="line">    fp = fdopen(sd,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fdopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fscanf(fp,<span class="string">"%lld"</span>,&amp;stamp) &lt; 1) //match error</span><br><span class="line">        fprintf(stderr,<span class="string">"fscanf error\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(stdout,<span class="string">"stamp = %lld\n"</span>,stamp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//server.c 服务端与客户端连接成功后，fork子进程来发送消息</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define IPSTRSIZE 40</span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static void server_job(int sd)</span><br><span class="line">&#123;   </span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    int len;</span><br><span class="line">    </span><br><span class="line">    len = sprintf(buf,<span class="string">"%lld\n"</span>,(long long)time(NULL));</span><br><span class="line">    </span><br><span class="line">    //had established the connect, so just send msg</span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,0) &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sd,newsd;</span><br><span class="line">    char ipstr[IPSTRSIZE];</span><br><span class="line">    struct sockaddr_in laddr,raddr;</span><br><span class="line">    socklen_t raddr_len;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int val = 1;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,sizeof(val)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVER_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,100) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = sizeof(raddr);</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        newsd = accept(sd,(void *)&amp;raddr,&amp;raddr_len);</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == 0)    //child</span><br><span class="line">        &#123;</span><br><span class="line">            close(sd);</span><br><span class="line">            inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client: %s:%d\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">            server_job(newsd);</span><br><span class="line">            close(newsd);</span><br><span class="line">            <span class="built_in">exit</span>(0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(newsd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上述程序还有个问题：子进程完成消息发送后exit，但父进程在while循环，不会退出，没有wait回收子进程</strong>。<br>解决方法见下一篇：如何避免僵尸进程。</p>
<p>补充几个命令：</p>
<blockquote>
<p>netstat -anu    //查看打开的UDP端口<br>    netstat -ant    //查看打开的TCP端口<br>    nc ip port        //请求某端口的内容<br>    hostname -I 查看当前ip地址<br>    sudo ufw disable 关闭防火墙<br>    sudo systemctl status apache2<br>    eog xxx        //eog是解码器，用于查看图片</p>
</blockquote>
<p><a href="https://www.cnblogs.com/lfri/p/10522392.html" target="_blank" rel="noopener">如何在Ubuntu 16.04上安装Apache Web服务器</a></p>
<p>例程2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">/*******************************</span><br><span class="line">从web爬取图片（前提：已开启apache服务，且网页输入127.0.0.1/test.jpg 可查看图片</span><br><span class="line">即/var/www/html下有图片，注意文件权限）</span><br><span class="line"></span><br><span class="line">验证：</span><br><span class="line">./webdl 127.0.0.1 &gt; /tmp/out   //将图片保存</span><br><span class="line">eog /tmp/out    //用eog解码，查看图片</span><br><span class="line">*******************************/</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int sd,newsd;</span><br><span class="line">    struct sockaddr_in raddr;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    char rbuf[BUFSIZE];</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(80);</span><br><span class="line">    inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(connect(sd,(void *)&amp;raddr,sizeof(raddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // connect server success!!!</span><br><span class="line"></span><br><span class="line">    fp = fdopen(sd,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fdopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fprintf(fp,<span class="string">"GET /test.jpg\r\n\r\n"</span>);</span><br><span class="line">    fflush(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        len = fread(rbuf,sizeof(char),BUFSIZE,fp);</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        fwrite(rbuf,sizeof(char),len,stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 流式套接字 </tag>
            
            <tag> SIGCHLD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】socket - DGRAM]]></title>
      <url>/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91socket/</url>
      <content type="html"><![CDATA[<p>3、网络套接字sockekt<br><strong>讨论：跨主机的传输要注意的问题</strong></p>
<blockquote>
<p>   1、字节序问题：<br>        大端：低地址处放高字节<br>        小端：低地址处放低字节<br>        解决：<br>        主机字节序：host<br>        网络字节序：network<br>        _ to _ _ : htons,htonl,ntohs,ntohl（最后的字符指长度short, long）<br>        （纯文本传输不用转换）</p>
</blockquote>
<blockquote>
<p>   2、对齐：<br>        struct<br>        {<br>            int i;<br>            float f;<br>            char ch;<br>        };    //占12个字节<br>        解决：不对齐</p>
</blockquote>
<blockquote>
<p>   3、类型长度问题<br>        int<br>        char<br>        解决：int32_t, uint32_t, int8_t, int64_t</p>
</blockquote>
<p><strong>报式套接字(DGRAM)</strong></p>
<blockquote>
<pre><code>被动端（先运行）
     socket();
     bind();
     recvfrom();//addrlen要初始化，不然第一次发送会失败
     close();            
 主动端：
     socket();
     bind();（可省略，不绑定端口，直接使用本机随意可用的端口）
     sndto();
     close();</code></pre></blockquote>
<p>相关函数：</p>
<blockquote>
<p>int socket(int domain, int type, int protocol);<br>inet_pton();//转换ip4或ipv6地址（点分式）为整型数<br>inet_ntop();//将大整数转换成点分式的ip地址<br>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);<br>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);<br>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">man 7 ip	(ipv4)</span><br><span class="line">	struct sockaddr_in &#123;</span><br><span class="line">    	sa_family_t    sin_family; /* address family: AF_INET */</span><br><span class="line">        in_port_t      sin_port;   /* port <span class="keyword">in</span> network byte order */</span><br><span class="line">        struct in_addr sin_addr;   /* internet address */</span><br><span class="line">        &#125;;</span><br><span class="line">与struct sockaddr *src_addr不同，用(void *)转化；</span><br><span class="line"></span><br><span class="line">/***************************************************</span><br><span class="line">	laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCV_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)//<span class="built_in">bind</span> a name to socket</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">****************************************************/</span><br></pre></td></tr></table></figure>
<br>

<p>例程1：（basic）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">//proto.h</span><br><span class="line"><span class="comment">#ifndef PROTO_H__</span></span><br><span class="line"><span class="comment">#define PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define RCV_PORT "1999"</span></span><br><span class="line"><span class="comment">#define NAMESIZE 11</span></span><br><span class="line">struct msg_st</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t name[NAMESIZE];</span><br><span class="line">    int32_t math;</span><br><span class="line">    int32_t chinese;</span><br><span class="line">&#125;__attribute__((packed));//cancel align</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//rcver.c</span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"><span class="comment">#define IPSTRSIZE 40</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sd;</span><br><span class="line">    char ipstr[IPSTRSIZE];</span><br><span class="line">    struct msg_st rbuf;</span><br><span class="line">    struct sockaddr_in laddr,raddr;//<span class="built_in">local</span> / remote  address</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,0);//ipv4,datagrams,default protocol:UDP</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCV_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)//<span class="built_in">bind</span> a name to socket</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //!!!! addrlen must be initialized</span><br><span class="line">    addrlen = sizeof(raddr);</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,sizeof(rbuf),0,(void *)&amp;raddr,&amp;addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----Message from %s:%d----\n"</span>,ipstr,raddr.sin_port);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name:%s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"math:%d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"chinese:%d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//snder.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int sd;</span><br><span class="line">    struct msg_st sbuf;</span><br><span class="line">    struct sockaddr_in raddr;//remote  address</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usag...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,0);//ipv4,datagrams,default protocol:UDP</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//  <span class="built_in">bind</span>();     //ignore</span><br><span class="line">    memset(&amp;sbuf,<span class="string">'\0'</span>,sizeof(sbuf));</span><br><span class="line">    strcpy(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%100);</span><br><span class="line">    sbuf.chinese = htonl(rand()%100);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCV_PORT));</span><br><span class="line">    inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,sizeof(sbuf),0,(void *)&amp;raddr,sizeof(raddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多点通讯：广播（全网广播，子网广播），多播/组播</p>
<blockquote>
<pre><code>setsockopt();
getsockopt();        
广播：(man 7 socket)
level：SOL_SOCKET
optname：SO_BROADCAST    
多播组：（man 7 ip）
level：IPPROTO_IP
主动端创建多播组，被动端加入多播组。
optname：IP_MULTICAST_IF，创建多播组
         IP_ADD_MEMBERSHIP，加入多播组</code></pre></blockquote>
<blockquote>
<pre><code>UDP: 丢包 -- 原因：阻塞        解决：闭环流控（停等式流控）    
 漏桶、令牌桶：没有校验，开环流控
 停等式流控：闭环流控，确保能够收到包，但并没有降低丢包率
 TTL：能够经过的路由的个数（Linux环境下默认为64，Windows下默认为128）</code></pre></blockquote>
<p>例程2：尝试用setsockopt设置广播/多播组通信。（自行实现）</p>
<p>例程3：用变长的方式组织结构体数据<br>修改提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">①proto.h</span><br><span class="line"></span><br><span class="line">//512 is UDP recommend size</span><br><span class="line">//two 8 is masthead and (sizeof(msg_st) - 1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define NAMEMAX (512-8-8)   </span></span><br><span class="line"></span><br><span class="line">struct msg_st</span><br><span class="line">&#123;</span><br><span class="line">    int32_t math;</span><br><span class="line">    int32_t chinese;</span><br><span class="line">    uint8_t name[1]; //variable</span><br><span class="line">&#125;__attribute__((packed));//cancel align</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">②snder.c和rcver.c中，定义struct msg_st *bufp;结构体指针，再malloc内存空间。</span><br><span class="line">    size = sizeof(struct msg_st) + NAMEMAX -1;</span><br><span class="line">    rbufp = malloc(size);   //其实就是512-8</span><br></pre></td></tr></table></figure>

<p>例程4：实现myftp_udp（简易检验client收到数据后回复ack，不加流控算法，用有限状态机思想编程）</p>
<p>例程5：实现myftp_udp_verify(在例程4的基础上完善，①在RTT时间内未收到Ack，防server丢包；②给数据包加编号，如果收到的两个数据包编号相同，说明Ack包丢了；给Ack包加编号校验，防Ack包延迟到达)</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> socket </tag>
            
            <tag> 报式套接字 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】进程间通信 - 消息队列、信号量数组，共享内存]]></title>
      <url>/zhoujiabo.github.io/2020/08/13/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-XSI/</url>
      <content type="html"><![CDATA[<p>2、XSI -&gt; SysV<br>    &emsp;IPC    -&gt; Inter-Process Communication<br>    &emsp;主动端：先发包的一方<br>    &emsp;被动端：先收包的一方（被动端先运行，创建通信机制）</p>
<p>相关函数：<br>    ①key_t ftok(const char <em>pathname, int proj_id);//取得一个key，实现类似哈希<br>    &emsp;pathname：文件名，实际要的是inode（唯一性）<br>    &emsp;proj_id：杂质<br>*</em>key：确保两个没有亲缘关系的进程，拿到同一个通信机制（同一个msgid）**<br>    ②消息队列、信号量数组、共享内存三种通信方法中所使用的函数命令类似，<strong>xxxget();创建    xxxop();发送/接收    xxxctl();初始化/销毁</strong></p>
<p><strong>Message Queues</strong></p>
<pre><code>int msgget(key_t key, int msgflg);
参数：
    key：这个位置的值可以是IPC_PRIVATE，用于有亲缘关系的进程间通信；
         如果是普通的key值，则msgflg中要有IPC_CREAT，创建消息队列
返回值：成功返回msgid，否则返回-1，设置errno

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                  int msgflg);</code></pre><blockquote>
<p><strong>消息队列特点</strong>：<br>    ①消息队列有一个缓存的机制，即使发送端在没有创建msg实例前，先snd了几次，<br>     接收端随后运行时还是能收到发送端发送的内容<br>    ②不是严格意义上的队列，msgrcv中有个msgtyp，可以选择接收特定的包，不是严格意义上的先进先出<br>    ③如果进程异常退出，创建的消息队列没有被销毁（ipcs查看当前存在的通信机制）<br>     ipcrm -q msqid（命令行删除某个消息队列）</p>
</blockquote>
<p>例程1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//proto.h文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef PROTO_H__</span></span><br><span class="line"><span class="comment">#define PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define KEYPATH "/etc/services"</span></span><br><span class="line"><span class="comment">#define KEYPROJ 'a'</span></span><br><span class="line"><span class="comment">#define NAMESIZE 32</span></span><br><span class="line"></span><br><span class="line">struct msg_st</span><br><span class="line">&#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char name[NAMESIZE];</span><br><span class="line">    int math;</span><br><span class="line">    int chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//rcver.c</span><br><span class="line"></span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    key_t key;</span><br><span class="line">    int msgid;</span><br><span class="line">    struct msg_st rbuf;</span><br><span class="line"></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key,IPC_CREAT|0600);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid,&amp;rbuf,sizeof(rbuf)-sizeof(long),0,0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"msgrcv"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name:%s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"math:%d\n"</span>,rbuf.math);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"chinese:%d\n"</span>,rbuf.chinese);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgctl(msgid,IPC_RMID,NULL);//destroy msg queue</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//snder.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    key_t key;</span><br><span class="line">    int msgid;</span><br><span class="line">    struct msg_st sbuf;</span><br><span class="line"></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key,0);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sbuf.mtype = 1;</span><br><span class="line">    strcpy(sbuf.name,<span class="string">"zhou"</span>);</span><br><span class="line">    sbuf.math = rand()%100;</span><br><span class="line">    sbuf.chinese = rand()%100;</span><br><span class="line">    //msgsnd中msgsz的大小为buf中除开mtype外的数据的大小</span><br><span class="line">    <span class="keyword">if</span>(msgsnd(msgid,&amp;sbuf,sizeof(sbuf)-sizeof(long),0) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgsnd()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    puts(<span class="string">"snd ok"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例程2：尝试实现myftp(类似cat)，snder发path给rcver，rcver接收后去获取相应的文件内容然后发送snder。<br><br><br><strong>Semaphore Arrays（信号量数组）</strong></p>
<blockquote>
<p>有A,B两种资源的情况时，如果不用信号量数组进行控制，<br>    让一个进程单独拿到A资源或B资源，容易乱进程僵/饿死<br>    （1号抢A，等待B，B被2号占有；2号占有B，又在等待A）<br>    如果信号量数组只有1个元素，就是我们之前学的信号量，控制一种资源的使用；<br>    <strong>如果只有1个元素，且元素中只有一个资源量，就是我们之前学的互斥量</strong>。<br>    <em>我们希望进程在取资源时，要么获得需要的全部资源，要么不占用任何资源</em>。</p>
</blockquote>
<pre><code>int semget(key_t key, int nsems, int semflg);//nsems为数组大小
int semctl(int semid, int semnum, int cmd, ...);//semnum为数组下标，cmd为SETVAL时，设置资源总量
int semop(int semid, struct sembuf *sops, size_t nsops);//sops为结构体数组首地址，nsops为数组大小</code></pre><blockquote>
<p>struct sembuf：<br>         unsigned short sem_num;  /* semaphore number <em>/<br>           short          sem_op;   /</em> semaphore operation <em>/<br>           short          sem_flg;  /</em> operation flags <em>/<br>(*</em>sem_num为信号量数组下标，sem_op可正可负，负表示取资源，正表示还资源**)</p>
</blockquote>
<p>例程：（实现互斥量）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define FNAME "/tmp/out"</span></span><br><span class="line"><span class="comment">#define THRNUM 10 </span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static int semid;</span><br><span class="line">static void P(void)</span><br><span class="line">&#123;   </span><br><span class="line">    struct sembuf sop;</span><br><span class="line">    </span><br><span class="line">    sop.sem_num = 0;</span><br><span class="line">    sop.sem_op = -1;</span><br><span class="line">    sop.sem_flg = 0;</span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;sop,1) &lt; 0)//operat one sembuf</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR || errno != EAGAIN)</span><br><span class="line">        &#123;   </span><br><span class="line">            perror(<span class="string">"semop()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void V(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf sop;</span><br><span class="line"></span><br><span class="line">    sop.sem_num = 0;</span><br><span class="line">    sop.sem_op = 1;</span><br><span class="line">    sop.sem_flg = 0;</span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;sop,1) &lt; 0)//operat one sembuf</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR || errno != EAGAIN)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"semop()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void *thr_add(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    fd = open(FNAME,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    P();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(fd,buf,BUFSIZE) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        perror(<span class="string">"read()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    sleep(1);</span><br><span class="line">    lseek(fd,0,SEEK_SET);</span><br><span class="line">    dprintf(fd,<span class="string">"%d"</span>,atoi(buf)+1);</span><br><span class="line">    fflush(NULL);</span><br><span class="line">    V();</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">    </span><br><span class="line">&#125;   </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,err;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    semid = semget(IPC_PRIVATE,1,0600);//sem array member <span class="built_in">set</span> 1</span><br><span class="line">    <span class="keyword">if</span>(semid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(semctl(semid,0,SETVAL,1) &lt; 0)//sem_array[0] value is 1</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_add,NULL);</span><br><span class="line">        <span class="keyword">if</span>(err != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    semctl(semid,0,IPC_RMID);   //destory semid</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
**Shared Memory**

<pre><code>shmget();
void *shmat(int shm_id, const void *shm_addr, int shmflg);    //attch
参数：
    shm_addr，可以为NULL，让系统在当前进程中找到合适的地址，然后将共享内存映射过来
    shmflg，一般为0
返回值：失败返回(void *)-1。

int shmdt(const void *shmaddr);//detach，将共享内存从当前进程分离

shmctl();</code></pre><p>例程：（子写父读）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MEMSIZE 1024</span></span><br><span class="line"></span><br><span class="line">//shmget一块空间后，fork子进程，父子进程间进行通信</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int shmid;</span><br><span class="line">    char *ptr;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(IPC_PRIVATE,MEMSIZE,0600);//create shared memory</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child write</span><br><span class="line">    &#123;</span><br><span class="line">        //<span class="keyword">if</span> shmaddr is NULL, system choose a suitable addr <span class="keyword">in</span> the current process to attch </span><br><span class="line">        ptr = shmat(shmid,NULL,0);//attch to child process</span><br><span class="line">        <span class="keyword">if</span>(ptr == (void *)-1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        strcpy(ptr,<span class="string">"hello"</span>);</span><br><span class="line">        shmdt(ptr); //dettach</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>            //parent <span class="built_in">read</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">        ptr = shmat(shmid,NULL,0);//attch to child process</span><br><span class="line">        <span class="keyword">if</span>(ptr == (void *)-1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(ptr);</span><br><span class="line">        shmdt(ptr); //dettach</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进程间通信 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】进程间通信 - 管道]]></title>
      <url>/zhoujiabo.github.io/2020/08/13/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>通信方式分类：<br>①位于同一台主机上的        —-    管道、XSI<br>    &emsp;有亲缘关系<br>    &emsp;没有亲缘关系</p>
<p>②位于不同主机上的        —-    socket</p>
<p>1、管道</p>
<blockquote>
<p>①内核提供，单工<br>    ②自同步机制（迁就比较慢的一方）<br>    ③管道要凑齐读写两方才能进行操作<br>    ④两个管道协同，可实现双工</p>
</blockquote>
<p>匿名管道（磁盘看不到，<strong>有亲缘关系的进程间通信</strong>）<br>        &emsp;pipe();//<strong>默认pd[0]读端 [1]写端</strong></p>
<p>命令管道（实际是一个p文件）<br>        &emsp;mkfifo();//创建命令管道，man 3 mkfifo</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/08/13/a429ef6ca6c2e80468b3572b6032c5f3c59ef7f04b096061.png" alt="mkfifo xxx 命令行创建" title="" class="">
                <p>mkfifo xxx 命令行创建</p>
            </figure>


<blockquote>
<p>关于效率：想象整个程序是多段粗细不同的水管衔接起来的；限制整体流速的是最细的那一段，<br>所以要优化，提高效率，需要找到结症所在；即使你把直径10m的水管换成100m，但因为最细的那段水管<br>是1m的，所以之前做的工作对整体效率没有任何提升，是无用功。</p>
</blockquote>
<p>例程：（父子进程通过匿名管道通信）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int pd[2];</span><br><span class="line">    int len;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pipe(pd) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child <span class="built_in">read</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(pd[1]);   //关闭不需要的写端 </span><br><span class="line">        len = <span class="built_in">read</span>(pd[0],buf,BUFSIZE);</span><br><span class="line">        close(pd[0]);   //读完后关闭读端</span><br><span class="line">        puts(buf);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>            //parent write</span><br><span class="line">    &#123;</span><br><span class="line">        close(pd[0]);</span><br><span class="line">        write(pd[1],<span class="string">"hello"</span>,6);</span><br><span class="line">        close(pd[1]);</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/08/13/d9092404faa19a33bae807ac9b60a477ecfc8d3dc46a43e2.png" alt="" title="" class="">
                <p></p>
            </figure>




]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进程间通信 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg命令]]></title>
      <url>/zhoujiabo.github.io/2020/08/03/ffmpeg%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>ffmpeg使用</p>
<p>一、音频：</p>
<p>1.转换<br>    &emsp;①m4a转mp3：ffmpeg -i “input.m4a” -codec:v copy -codec:a libmp3lame -q:a 0 “output.mp3”<br>    &emsp;②mp3转wav：ffmpeg -i input.mp3 -acodec pcm_s16le -ac 1 -ar 8000 output.wav<br>    &emsp;③m4a转wav：ffmpeg -i input.m4a -acodec pcm_s16le -ac 1 -ar 8000 output.wav</p>
<p>2、压缩：<br>    &emsp;ffmpeg -i input.mp3 -ab 128 output.mp3    （-ab – 表明音频比特率。）</p>
<p>3、预览或测试音频<br>    &emsp;ffplay xxx.mp3</p>
<p><strong>转换音频文件脚本tran.sh:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir newfiles</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> *.m4a;<span class="keyword">do</span> ffmpeg -i <span class="string">"<span class="variable">$f</span>"</span> -codec:v copy -codec:a libmp3lame -q:a 0 newfiles/<span class="string">"<span class="variable">$&#123;f%.m4a&#125;</span>.mp3"</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment">#转换音频文件脚本：</span></span><br><span class="line"><span class="comment">#利用ffmpgeg，将当前目录下的.m4a文件转换成.mp3格式文件，存储到newfiles中</span></span><br><span class="line"><span class="comment">#用-qscale:a（或别名-q:a）控制质量。值是特定于编码器的，因此对于libmp3lame，范围是0-9，其中值越小表示质量越高。</span></span><br><span class="line"><span class="comment">#0-3通常会产生透明的结果，4（默认值）应接近感知透明，而6通常会产生“可接受的”质量。</span></span><br></pre></td></tr></table></figure>

<p>二、视频</p>
<p>1、转换视频文件到不同的格式<br>    &emsp;①ffmpeg -i video.mp4 video.avi<br>    &emsp;②ffmpeg -i video.flv video.mpeg</p>
<p>2、从一个视频文件移除音频流<br>    &emsp;ffmpeg -i input.mp4 -an output.mp4    （-an 表示没有音频录制）</p>
<p>3、从一个媒体文件移除视频流（提取音频）<br>    &emsp;ffmpeg -i input.mp4 -vn output.mp3    （-vn 代表没有视频录制）</p>
<p>4、调整视频播放速度<br>    &emsp;ffmpeg -i input.mp4 -vf “setpts=0.5*PTS” output.mp4</p>
]]></content>
      
        <categories>
            
            <category> 工具使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 音视频转换格式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】管道实例-池类算法]]></title>
      <url>/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E7%AE%A1%E9%81%93%E5%AE%9E%E4%BE%8B-%E6%B1%A0%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>回顾之前学多线程互斥量与条件变量时写的池类算法：</p>
<blockquote>
</blockquote>
<pre><code>维护一个num线程池，main（上游线程）分配任务，N个线程（下游线程）到池中抢任务并计算
main线程分发数字（任务），&gt;0为有任务，=0当前任务被完成，=-1没有任务可以分发了；
其它线程抢任务，计算完成后将num清0；如果num为-1,线程跳出循环结束。</code></pre><p>但是其效率还是比较低的，因为池中只有一个数据，大部分时间线程还是处于等待状态。</p>
<p>现在用管道（循环队列封装的）来做一个更大池，上游线程往管道写数据，下游线程从管道取数据计算。</p>
<p>管道封装：<br>①mypipe.h</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef MYPIPE_H__</span></span><br><span class="line"><span class="comment">#define MYPIPE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PIPESIZE      1024</span></span><br><span class="line"></span><br><span class="line">//身份位图，读者|写者</span><br><span class="line"><span class="comment">#define MYPIPE_READ   0X00000001UL</span></span><br><span class="line"><span class="comment">#define MYPIPE_WRITE  0x00000002UL</span></span><br><span class="line">typedef void mypipe_t;</span><br><span class="line">typedef int pipe_data_t;</span><br><span class="line"></span><br><span class="line">mypipe_t *mypipe_init(void);</span><br><span class="line">int mypipe_destroy(mypipe_t *ptr);</span><br><span class="line"></span><br><span class="line">/*********************************************</span><br><span class="line">*如果是骗你的怎么办，注册了读者身份，却去写管道</span><br><span class="line">*可以加一个权限位图</span><br><span class="line">***********************************************/</span><br><span class="line">int mypipe_register(mypipe_t *ptr,int opmap);</span><br><span class="line">int mypipe_unregister(mypipe_t *ptr,int opmap);</span><br><span class="line"></span><br><span class="line">/*********************************************</span><br><span class="line">*函数：想要从管道中读取count个数据，存储到buf中</span><br><span class="line">*返回值：</span><br><span class="line">*   -1  身份不是读者（待补充）</span><br><span class="line">*    0  管道为空且没有写者，退出读等待</span><br><span class="line">*   &gt;0  实际读取的数据个数</span><br><span class="line">***********************************************/</span><br><span class="line">int mypipe_read(mypipe_t *ptr,pipe_data_t *buf,size_t count);</span><br><span class="line">int mypipe_write(mypipe_t *ptr,const pipe_data_t *buf,size_t count);</span><br><span class="line"></span><br><span class="line">//如果管道为空，返回-1；如果管道不为空，读取完成后，无论有没有写者存在，都直接返回实际读取到的数据个数</span><br><span class="line">int mypipe_try_read(mypipe_t *ptr,pipe_data_t *buf,size_t count);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<p>②mypipe.c</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include "mypipe.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DATA_MAX (PIPESIZE+1)  //循环队列,加一空位作判断 </span></span><br><span class="line"></span><br><span class="line">struct mypipe_st</span><br><span class="line">&#123;</span><br><span class="line">    int head;</span><br><span class="line">    int tail;</span><br><span class="line">    pipe_data_t data[DATA_MAX];    //管道大小</span><br><span class="line">    int datasize;</span><br><span class="line">    pthread_mutex_t mut;</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line">    int count_rd;           //读者数量</span><br><span class="line">    int count_wr;           //写者数量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mypipe_t *mypipe_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me;</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    me-&gt;head = 0;</span><br><span class="line">    me-&gt;tail = 0;</span><br><span class="line">    me-&gt;datasize = 0;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut,NULL);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond,NULL);</span><br><span class="line">    me-&gt;count_rd = 0;</span><br><span class="line">    me-&gt;count_wr = 0;</span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int mypipe_register(mypipe_t *ptr,int opmap)</span><br><span class="line">&#123;</span><br><span class="line">    int id_unlegal = 1;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_READ)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_rd++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_wr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id_unlegal)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//有新的读者或写者到来</span><br><span class="line"></span><br><span class="line">    //如果只有写者，或只有读者，则继续等待</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;count_rd &lt;= 0 || me-&gt;count_wr &lt;= 0)</span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mypipe_unregister(mypipe_t *ptr,int opmap)</span><br><span class="line">&#123;</span><br><span class="line">    int id_unlegal = 1;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_READ)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_rd--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_wr--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id_unlegal)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//有读者或写者走了</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int next(int n)</span><br><span class="line">&#123;</span><br><span class="line">    n = (n + 1) % DATA_MAX;</span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">static int mypipe_readbyte_unlocked(struct mypipe_st *me,pipe_data_t *datap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;datasize &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    *datap = me-&gt;data[me-&gt;head];</span><br><span class="line">    me-&gt;head = next(me-&gt;head);</span><br><span class="line">    me-&gt;datasize --;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int mypipe_read(mypipe_t *ptr,pipe_data_t *buf,size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    //当前管道空</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;datasize &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(me-&gt;count_wr &gt; 0)//有写者，才继续等待</span><br><span class="line">            pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line">        <span class="keyword">else</span> //没有写者，解锁，退出读</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mypipe_readbyte_unlocked(me,buf+i) != 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知数据被读出，可写</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int mypipe_writebyte_unlocked(struct mypipe_st *me,const pipe_data_t *ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;datasize &gt;= DATA_MAX)</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    me-&gt;data[me-&gt;tail] = *ch;</span><br><span class="line">    me-&gt;tail = next(me-&gt;tail);</span><br><span class="line">    me-&gt;datasize ++;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int mypipe_write(mypipe_t *ptr,const pipe_data_t *buf,size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    //当前管道满</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;datasize &gt;= DATA_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(me-&gt;count_rd &gt; 0)//还有读者，则继续等待</span><br><span class="line">            pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line">        <span class="keyword">else</span>    //没有读者，解锁，退出写</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mypipe_writebyte_unlocked(me,buf+i) != 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知有数据到来，可读</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mypipe_destroy(mypipe_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    free(me);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mypipe_try_read(mypipe_t *ptr,pipe_data_t *buf,size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(me-&gt;datasize &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mypipe_readbyte_unlocked(me,buf+i) != 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知数据被读出，可写</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③main.c和makefile就不贴出来了。</p>
<p><img src="https://file.moetu.org/images/2020/08/03/6551e26d5cf543e283fb336b825c73e941c8ac96f6c9dae3.png" alt="测试结果"></p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 管道封装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】文件锁]]></title>
      <url>/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E6%96%87%E4%BB%B6%E9%94%81/</url>
      <content type="html"><![CDATA[<p>5、文件锁<br>    fcntl();<br>    lockf();//比较常用<br>    flock();</p>
<p>意外解锁现象：<br>&emsp;<strong>文件锁是加在inode层面的</strong>，如果有多个fd指向一个inode，其中一个fd关闭，会造成其它fd意外解锁。</p>
<p>加锁后写数据，解锁前要调用fflush，将缓冲区的内容写入文件。</p>
<p>之前用互斥量实现的add.c，现在用文件锁重构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">include &lt;unistd.h&gt;</span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#define PROCNUM  (10)</span></span><br><span class="line"><span class="comment">#define FNAME "/tmp/out"</span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static void proc_add(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = fileno(fp);</span><br><span class="line">    lockf(fd,F_LOCK,0);</span><br><span class="line">    fgets(buf,BUFSIZE,fp);</span><br><span class="line">    rewind(fp);//equal to fseek(fp,0,SEEK_SET);</span><br><span class="line">//    sleep(1);//放大线程竞争</span><br><span class="line">    fprintf(fp,<span class="string">"%d\n"</span>,atoi(buf)+1);</span><br><span class="line">    fflush(fp);//将缓冲区中内容写入文件</span><br><span class="line">    lockf(fd,F_ULOCK,0);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int err,i;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid  = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            proc_add();</span><br><span class="line">            <span class="built_in">exit</span>(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 高级IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】存储映射IO]]></title>
      <url>/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84IO/</url>
      <content type="html"><![CDATA[<p>4、存储映射IO<br>    mmap();//<strong>有亲缘关系进程间通信，共享内存</strong>。</p>
<p>函数详解：</p>
<blockquote>
<p>void *mmap(void *addr, size_t length, int prot, int flags,<br>                  int fd, off_t offset);<br>    参数：<br>        addr：一般直接赋NULL，让内核随意找一块空间<br>        prot：内存的读写权限设置<br>        flags：特殊要求，MAP_SHARED和MAP_PRIVATE中的一个，再或上其它内容<br>                如果有或上MAP_ANONYMOUS，匿名空间，内容初始化为0，不需要fd，直接设置-1<br>        fd，offset，length：将文件的某个位置开始，length长度的内容映射到内存<br>    返回值：<br>        成功返回首地址，失败返回MAP_FAILED<br><br><br>    int munmap(void *addr, size_t length);</p>
</blockquote>
<p>例子1：将指定fd的内容映射到某个存储空间，统计其中a的个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char *ptr;</span><br><span class="line">    struct <span class="built_in">stat</span> statres;</span><br><span class="line">    int i,count = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[1],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd,&amp;statres) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fstat()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = mmap(NULL,statres.st_size,PROT_READ,MAP_SHARED,fd,0);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        munmap(ptr,statres.st_size);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; statres.st_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr[i] == <span class="string">'a'</span>)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">    munmap(ptr,statres.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>例子2：mmap申请一块空间后，fork子进程，父子进程间进行通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MEMSIZE 1024</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;   </span><br><span class="line">    pid_t pid;</span><br><span class="line">    char *ptr;</span><br><span class="line">    int i,count = 0;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    ptr = mmap(NULL,MEMSIZE,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        munmap(ptr,MEMSIZE);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child write</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(ptr,<span class="string">"hello"</span>);</span><br><span class="line">        munmap(ptr,MEMSIZE);//子进程也要解除映射</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>            //parent <span class="built_in">read</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">        puts(ptr);</span><br><span class="line">        munmap(ptr,MEMSIZE);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 高级IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】非阻塞IO与IO多路转接]]></title>
      <url>/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E9%AB%98%E7%BA%A7IO/</url>
      <content type="html"><![CDATA[<p>非阻塞IO    —-    阻塞IO    </p>
<p>补充：有限状态机编程</p>
<p>1、非阻塞IO<br>    简单流程：自然流程是结构化的（如open -&gt; put -&gt; close）<br>    复杂流程：自然流程不是结构化的（网络协议）</p>
<pre><code>数据中继引擎：
    （当我们指定打开的设备为O_NONBLOCK，read/write就不会阻塞；没有读到内容，
    返回-1，设置errno为EAGAIN）
    因此读完数据后状态机就会陷入忙推状态，一直在等待新的数据。</code></pre><p>利用有限状态机编程思想，实现两个文件（或终端，要在main中加while(1) pause();）相互传输数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TTY1 "./file1"</span></span><br><span class="line"><span class="comment">#define TTY2 "./file2"</span></span><br><span class="line"><span class="comment">#define BUFSIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    STATE_R = 1,</span><br><span class="line">    STATE_W,</span><br><span class="line">    STATE_Ex,</span><br><span class="line">    STATE_T</span><br><span class="line">&#125;;</span><br><span class="line">struct fsm_st</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">stat</span>;</span><br><span class="line">    int sfd;</span><br><span class="line">    int dfd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    int len;</span><br><span class="line">    int pos;</span><br><span class="line">    char *errstr;</span><br><span class="line">&#125;;</span><br><span class="line">static void driver(struct fsm_st *fsm)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    switch(fsm-&gt;<span class="built_in">stat</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_R:</span><br><span class="line">            fsm-&gt;len = <span class="built_in">read</span>(fsm-&gt;sfd,fsm-&gt;buf,BUFSIZE);</span><br><span class="line">            <span class="keyword">if</span>(fsm-&gt;len == 0)//读取完成，结束</span><br><span class="line">                fsm-&gt;<span class="built_in">stat</span> = STATE_T;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fsm-&gt;len &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN)//假错，重新读</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_R;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"read()"</span>;</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_Ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fsm-&gt;pos = 0;</span><br><span class="line">                fsm-&gt;<span class="built_in">stat</span> = STATE_W;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> STATE_W:</span><br><span class="line">            ret = write(fsm-&gt;dfd,fsm-&gt;buf+fsm-&gt;pos,fsm-&gt;len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_W;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"write()"</span>;</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_Ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                //坚持写完</span><br><span class="line">                fsm-&gt;len -= ret;</span><br><span class="line">                <span class="keyword">if</span>(fsm-&gt;len == 0)</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_R;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;pos += ret;</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_W;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_Ex:</span><br><span class="line">            perror(fsm-&gt;errstr);</span><br><span class="line">            fsm-&gt;<span class="built_in">stat</span> = STATE_T;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_T:</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            abort();</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void relay(int fd1, int fd2)</span><br><span class="line">&#123;</span><br><span class="line">    int fd1_save,fd2_save;</span><br><span class="line">    struct fsm_st fsm12,fsm21;</span><br><span class="line"></span><br><span class="line">    //先确保两个文件是非阻塞的</span><br><span class="line">    fd1_save = fcntl(fd1,F_GETFD);</span><br><span class="line">    fcntl(fd1,F_SETFD,fd1_save|O_NONBLOCK);</span><br><span class="line">    fd2_save = fcntl(fd2,F_GETFD);</span><br><span class="line">    fcntl(fd2,F_SETFD,fd2_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fsm12.stat = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line">    fsm21.stat = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fsm12.stat != STATE_T || fsm21.stat != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        driver(&amp;fsm12);</span><br><span class="line">        driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(fd1,F_SETFD,fd1_save);</span><br><span class="line">    fcntl(fd2,F_SETFD,fd2_save);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int fd1,fd2;</span><br><span class="line"></span><br><span class="line">    fd1 = open(TTY1,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd1 &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd2 = open(TTY2,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd2 &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    relay(fd1,fd2);</span><br><span class="line"></span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尝试封装一个数据中继引擎</strong>（封装方法类似之前的anytimer，下面部分程序供参考：）:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">enum rel_state</span><br><span class="line">&#123;   </span><br><span class="line">    REL_RUNNING = 1,</span><br><span class="line">    REL_CANCELED,</span><br><span class="line">    REL_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rel_job_st</span><br><span class="line">&#123;   </span><br><span class="line">    int rel_stat;               //中继任务状态</span><br><span class="line">    int fd1,fd2;                //交换数据双方</span><br><span class="line">    struct fsm_st fsm12,fsm21;  //两个有限状态机</span><br><span class="line">    int fd1_save,fd2_save;       //保存好的原文件状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int get_free_pos_unlocked(void);</span><br><span class="line">static void fsm_driver(struct fsm_st *fsm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void *thr_relayer(void *p)</span><br><span class="line">&#123;   </span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_mutex_lock(&amp;job_mut);</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; REL_JOBMAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(job[i]-&gt;rel_stat == REL_RUNNING)</span><br><span class="line">                &#123;</span><br><span class="line">                    fsm_driver(&amp;job[i]-&gt;fsm12);</span><br><span class="line">                    fsm_driver(&amp;job[i]-&gt;fsm21);</span><br><span class="line">                    <span class="keyword">if</span>(job[i]-&gt;fsm12.stat == STATE_T &amp;&amp; \</span><br><span class="line">                        job[i]-&gt;rel_stat = REL_OVER;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;job_mut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2、IO多路转接</p>
<blockquote>
<p>监视文件描述符：<br>    select();    //以事件为单位组织文件描述符；最古老，移植性好；接口设计有缺陷；<br>    poll();        //以文件描述符为单位来组织事件；移植性也可以，用户自己来维护一些内容<br>    epoll();    //方言</p>
</blockquote>
<p><strong>以事件为单位组织文件描述符：</strong><br>int select(int nfds, fd_set *readfds, fd_set *writefds,<br>                  fd_set *exceptfds, struct timeval *timeout);</p>
<p>函数会阻塞直到：<br>    ①一个或多个文件描述符变成“ready”态<br>    ②被信号打断<br>    ③超时</p>
<p>参数：<br>    &emsp;nfds：最大的文件描述符+1<br>    &emsp;三个集合：*将发生变化的描述符以位图方式回写，没有变化则全部位清0，需要重新布置监视任务 *<br>    &emsp;timeout：超时设置，NULL则阻塞<br>返回值：<br>    &emsp;&gt;0，    成功，返回三集合（读集，写集，异常集）中发生变化的fd个数<br>    &emsp;=0，    超时<br>    &emsp;-1，    失败，设置errno</p>
<p>文件描述符集合：fd_set（类似信号集sigset_t）<br>    &emsp;FD_CLR：从fd集合中删除指定fd；<br>    &emsp;FD_ISSET：判断fd是否属性某个集合<br>    &emsp;FD_SET：添加一个fd到集合<br>    &emsp;FD_ZERO：清空集体</p>
<p>布置监视任务，监视，查看监视结果。</p>
<blockquote>
<p>select缺陷：<br>    监视现场和监视结果存放的是同一块空间<br>    监视的事件太单一，除了读，写，其它都算是异常</p>
</blockquote>
<p>用select()监视读写事件发生：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    STATE_R = 1,</span><br><span class="line">    STATE_W,</span><br><span class="line">STATE_AUTO,// 大于这个值，则自动推状态机</span><br><span class="line">    STATE_Ex,</span><br><span class="line">    STATE_T</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">修改relay.c中的推动状态机部分的程序</span><br><span class="line"><span class="keyword">while</span>(fsm12.stat != STATE_T || fsm21.stat != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        //布置监视现场</span><br><span class="line">        FD_ZERO(&amp;rset);</span><br><span class="line">        FD_ZERO(&amp;wset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_R)</span><br><span class="line">            FD_SET(fsm12.sfd,&amp;rset);</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_W)</span><br><span class="line">            FD_SET(fsm12.dfd,&amp;wset);</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_R)</span><br><span class="line">            FD_SET(fsm21.sfd,&amp;rset);</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_W)</span><br><span class="line">            FD_SET(fsm21.dfd,&amp;wset);</span><br><span class="line"></span><br><span class="line">        //监视</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat &lt; STATE_AUTO || fsm21.stat &lt; STATE_AUTO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(select(max(fd1,fd2)+1, &amp;rset, &amp;wset, NULL, NULL) &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"select()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查看监视结果</span><br><span class="line">        <span class="keyword">if</span>( FD_ISSET(fd1,&amp;rset) || FD_ISSET(fd2,&amp;wset) \</span><br><span class="line">                ||fsm12.stat &gt; STATE_AUTO)</span><br><span class="line">            driver(&amp;fsm12);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( FD_ISSET(fd2,&amp;rset) || FD_ISSET(fd1,&amp;wset) \</span><br><span class="line">                ||fsm21.stat &gt; STATE_AUTO)</span><br><span class="line">            driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>以文件描述符为单位来组织事件：</strong><br>int poll(struct pollfd *fds, nfds_t nfds, int timeout);<br>参数：<br>    &emsp;fds：结构体数组的起始地址<br>    &emsp;nfds：监视的fd个数<br>    &emsp;timeout：单位为ms，0表示非阻塞，-1表示阻塞</p>
<p>struct pollfd {<br>               int   fd;         /* file descriptor <em>/<br>               short events;     /</em> 我们关心的事件 <em>/<br>               short revents;    /</em> 实际返回的事件 */<br>           };<br>events，revents都是16位的位图，暂时可监视7种事件</p>
<p>用poll()监视两个文件描述符的变化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fsm12.stat != STATE_T || fsm21.stat != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        //布置监视现场</span><br><span class="line">        pfd[0].events = 0;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_R)</span><br><span class="line">            pfd[0].events |= POLLIN;</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_W)</span><br><span class="line">            pfd[0].events |= POLLOUT;</span><br><span class="line"></span><br><span class="line">        pfd[1].events = 0;</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_R)</span><br><span class="line">            pfd[1].events |= POLLIN;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_W)</span><br><span class="line">            pfd[1].events |= POLLOUT;</span><br><span class="line"></span><br><span class="line">        //监视</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat &lt; STATE_AUTO || fsm21.stat &lt; STATE_AUTO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(poll(pfd, 2, -1) &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"select()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查看监视结果</span><br><span class="line">        <span class="keyword">if</span>( (pfd[0].revents &amp; POLLIN) || (pfd[1].revents &amp; POLLOUT) \</span><br><span class="line">                ||fsm12.stat &gt; STATE_AUTO )</span><br><span class="line">            driver(&amp;fsm12);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (pfd[1].revents &amp; POLLIN) || (pfd[0].revents &amp; POLLOUT)  \</span><br><span class="line">                ||fsm21.stat &gt; STATE_AUTO )</span><br><span class="line">            driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>epoll：相当于将poll机制封装了一层，放到了内核当中。</strong><br>struct pollfd数组由内核维护，提供几个系统调用给用户使用。<br>    epoll_create();    //创建一个epoll实例，参数现在是任意的正值，返回值是fd，可以用close关闭<br>    epoll_ctl();    //<strong>EPERM  目标fd不支持epoll.</strong><br>    epoll_wait();</p>
<blockquote>
<p>学习IO多路转接后，可以尝试用poll来优化之前的数据中继引擎。</p>
</blockquote>
<p>3、其它读写函数</p>
<p>读写多个buffers：<br>    readv();<br>    writev();<br>坚持读写n个字节（apue.h）：<br>    readn();<br>    writen();</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 高级IO </tag>
            
            <tag> 有限状态机编程思想 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Xshell设置与使用]]></title>
      <url>/zhoujiabo.github.io/2020/08/03/Xshell%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>配色：New Black</p>
<p>字体：DejaVu Sans Mono  12</p>
<p>关闭提示音：工具 - 选项 - 高级 - 禁用铃声</p>
<p>不使用Xftp：工具 - 选项 - 高级 - 打开SFTP会话，不执行Xftp</p>
<p>SFTP命令：</p>
<blockquote>
</blockquote>
<pre><code>服务器端（虚拟机）操作：
    支持的常规命令：ls cd mkdir mv pwd rm rmdir clear</code></pre><br>
    本地端（电脑）相关操作：
        lls 显示本地工作目录文件列表
        lpwd 显示本地工作目录路径
        explore 使用电脑资源管理器打开本地工作目录
        lcd 切换本地工作目录（切换文件传输位置）
<br>        
    文件传输：
        put 上传文件到服务器
        get 下载文件到本地
<br>        
        bye    关闭SFTP会话
        quit 完成SFTP会话

<p>linux快捷键：<br>    &emsp;ctrl + u：删除光标前字符<br>    &emsp;ctrl + k：删除光标后字符<br>    &emsp;ctrl + a：光标移动行首<br>    &emsp;ctrl + e：光标移动行尾</p>
<p>xshell快捷键：<br>    &emsp;切换窗口：shift/ctrl + tab</p>
]]></content>
      
        <categories>
            
            <category> 工具使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Xshell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[虚拟机和电脑能相互ping通，但使用putty远程连接]]></title>
      <url>/zhoujiabo.github.io/2020/07/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%94%B5%E8%84%91%E8%83%BD%E7%9B%B8%E4%BA%92ping%E9%80%9A%EF%BC%8C%E4%BD%86%E4%BD%BF%E7%94%A8putty%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>用filezilla，putty或xshell无法连接虚拟机！！！！</p>
<p>找好两天，在某篇文章中的评论找到了正解。</p>
<blockquote>
<p>设置的静态ip不要和电脑中的适配网卡ip相同！！！<br>如果VMnet8中网关为192.168.174.2，则电脑适配网卡可以设置为192.168.174.1<br>最后虚拟机中静态ip设置192.168.174.3</p>
</blockquote>
<p>我的问题就是：将静态Ip设置成192.168.174.1，后果就是<br>虚拟机和电脑能相互Ping通，但无法用putty远程连接.</p>
]]></content>
      
        <categories>
            
            <category> Linux问题集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】线程实例]]></title>
      <url>/zhoujiabo.github.io/2020/07/30/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>一、模拟信号量实现：</p>
<p>main.c</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include "mysem.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  (RIGHT-LEFT+1)</span></span><br><span class="line"><span class="comment">#define N       4       </span></span><br><span class="line">//不限制创建线程的数量，但同一时刻只能有4个线程</span><br><span class="line"></span><br><span class="line">static mysem_t *sem;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line"></span><br><span class="line">    i = (int)p;</span><br><span class="line"></span><br><span class="line">    mark = 1;</span><br><span class="line">    <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = 0;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is primer\n"</span>,i);</span><br><span class="line"></span><br><span class="line">    //sleep(5); //放大信号量效果，同一时刻只能存在N个线程</span><br><span class="line">    mysem_add(sem,1);//归还信号量</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    sem = mysem_init(N);</span><br><span class="line">    <span class="keyword">if</span>(sem == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"mysem_init() fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mysem_sub(sem,1);//使用信号量</span><br><span class="line">        err = pthread_create(tid+(i-LEFT),NULL,thr_primer,(void *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT],NULL);//回收线程,接收返回值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysem_destroy(sem);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mysem.c</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include "mysem.h"</span></span><br><span class="line"></span><br><span class="line">typedef void mysem_t;</span><br><span class="line"></span><br><span class="line">struct mysem_st</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    pthread_mutex_t mut;</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mysem_t *mysem_init(int initval)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me;</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    me-&gt;value = initval;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut,NULL);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mysem_add(mysem_t *ptr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    me-&gt;value += n;</span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知其它线程value有变化</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mysem_sub(mysem_t *ptr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;value &lt; n)</span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    me-&gt;value -= n;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mysem_destroy(mysem_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自行补充makefile和mysem.h文件。<br>上面的信号量实现，是为了限制同一时间的线程数量；要<em>测试</em>：先将main中的sleep取消注释；新建终端，隔一段时间ps一次，会发现，除main线程不变外，同一时间总是存在4个线程，它们的id号会变化。</p>
<p>二、用多线程<strong>重构令牌桶</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "mytbf.h"</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct mytbf_st</span><br><span class="line">&#123;</span><br><span class="line">    int cps;</span><br><span class="line">    int burst;</span><br><span class="line">    int token;</span><br><span class="line">    int pos;</span><br><span class="line">    pthread_mutex_t mut;</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static pthread_t tid_alrm;</span><br><span class="line">static struct mytbf_st *job[MYTBF_MAX];//static,默认初始化为0</span><br><span class="line">static pthread_mutex_t mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">static pthread_once_t init_once;</span><br><span class="line"></span><br><span class="line">static void *thr_alrm(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                            pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">                job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">                <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                    job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">                pthread_cond_broadcast(&amp;job[i]-&gt;cond);//通知token发生变化</span><br><span class="line">                pthread_mutex_unlock(&amp;job[i]-&gt;mut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void module_unload(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_cancel(tid_alrm);</span><br><span class="line">    pthread_join(tid_alrm,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            mytbf_destroy(job[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void module_load(void)</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    err = pthread_create(&amp;tid_alrm,NULL,thr_alrm,NULL);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int get_free_pos_unlock(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == NULL)</span><br><span class="line">            <span class="built_in">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mytbf_t *mytbf_init(int cps,int burst)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me;</span><br><span class="line">    int pos;</span><br><span class="line"></span><br><span class="line">    pthread_once(&amp;init_once,module_load);</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;//malloc失败</span><br><span class="line"></span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;token = 0;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut,NULL);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond,NULL);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);//加锁</span><br><span class="line">    pos = get_free_pos_unlock();</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        free(me);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);//解锁</span><br><span class="line">        <span class="built_in">return</span> NULL;//令牌桶个数达到上限</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line">    job[pos] = me;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);//解锁</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int min(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="built_in">return</span> a;</span><br><span class="line">    <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//size为想要取的token数，返回值为实际取得的token数</span><br><span class="line">int mytbf_fetchtoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);//加锁</span><br><span class="line"></span><br><span class="line">    //通知法</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //等待其它人来通知，得到通知第一反应是先抢锁;如果条件不成立解锁继续等&gt;待</span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">    //查询法，忙等</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;me-&gt;mut);//解锁</span><br><span class="line">        sched_yield();//出让CPU使用权</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);//抢锁</span><br><span class="line">    &#125;</span><br><span class="line">*/</span><br><span class="line">    n = min(me-&gt;token,size);</span><br><span class="line"></span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归还未使用的token</span><br><span class="line">int mytbf_returntoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);//加锁</span><br><span class="line"></span><br><span class="line">    me-&gt;token += size;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//广播通知token发生变化</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);//解锁</span><br><span class="line">    <span class="built_in">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mytbf_destroy(mytbf_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;//转换</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    job[me-&gt;pos] = NULL;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    free(ptr);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、用线程<strong>重构anytimer</strong>：</p>
<p>思路：<br>①module_load时创建<strong>一个始终运行的定时线程</strong>（job数组中所有元素的sec–，出现sec减至0的元素就发广播通知）；module_unload挂到钩子函数，在exit前运行，进行清理回收工作；<br>②<strong>每个定时任务都要一个自己的等待执行线程</strong>，计时完成（收到通知）后执行任务，线程退出，但因为有将tid保存到timjob_st中，所以可以在最后deljob时，调用pthread_join回收线程。<br>③<em>回收线程和销毁定时任务策略</em>：已完成的任务，是执行后直接销毁；还是先不管，到最后module_unload时统一销毁；或者超过一定数量回收一次。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 信号量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】线程竞争与同步]]></title>
      <url>/zhoujiabo.github.io/2020/07/29/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<p>线程竞争：<br>    因为进程中多个线程的代码段是共用的，所以在访问一些资源和变量时可能产生冲突。</p>
<p>竞争例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define THRNUM  (10)</span></span><br><span class="line"><span class="comment">#define FNAME "/tmp/out"</span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static void* thr_add(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    fp = fopen(FNAME,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fgets(buf,BUFSIZE,fp);</span><br><span class="line">    rewind(fp);//equal to fseek(fp,0,SEEK_SET);</span><br><span class="line">    sleep(1);//放大线程竞争</span><br><span class="line">    fprintf(fp,<span class="string">"%d\n"</span>,atoi(buf)+1);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_add,NULL);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：<br>echo 1 &gt; /tmp/out<br>./add<br>cat /tmp/out<br>得到2（所有线程读到的都是1，对文件重复写2）<br>解决思路：用互斥量，限制同一时间只能有一个线程对文件进行读写</p>
<p>3、线程同步</p>
<p>互斥量（某一时刻只能有一个人在小黑屋里写或读写（更严格））<br>    pthread_mutex_t;<br>    pthread_mutex_init();<br>    pthread_mutex_destory();<br>    pthread_mutex_lock();        //阻塞<br>    pthread_mutex_trylock();    //非阻塞<br>    pthread_mutex_unlock();</p>
<p>sleep();放大竞争和故障。</p>
<p><strong>sched_yield();//出让CPU使用权</strong></p>
<p><strong>互斥锁，不是限制某个资源某个变量的读写，而限制代码能否运行下去。我们将被限制的代码区称为临界区。</strong></p>
<blockquote>
<p>第一次man pthread_mutex_init可能失败，要安装manpages-posix-dev)</p>
</blockquote>
<p>线程池：<br>    例：primer_pool_busy.c（查询法）<br>    维护一个num线程池，main（上游线程）分配任务，N个线程（下游线程）到池中抢任务并计算<br>    main线程分发数字（任务），&gt;0为有任务，=0当前任务被完成，=-1没有任务可以分发了；<br>    其它线程抢任务，计算完成后将num清0；如果num为-1,线程跳出循环结束。</p>
<p><strong>要注意临界区内的所有跳转语句，如果是跳转出临界区外，则跳转前要解锁，避免造成死锁</strong>。<br>临界区内的调用函数要能返回。</p>
<p><strong>动态模块的单次初始化函数：pthread_once();</strong></p>
<p>条件变量<br>    pthread_cond_t<br>    phtread_cond_init();<br>    phtread_cond_destroy();<br>    pthread_cond_broadcast();<br>    pthread_cond_signal();<br>    pthread_cond_wait();    </p>
<p>信号量<br>    限制某时刻使用资源的用量</p>
<p>读写锁<br>    读锁 —&gt; 共享锁<br>    写锁 —&gt; 互斥锁<br>    避免写者饿死：如果有写者到来，后来的读者不能再读。<br><br><br><big><strong>通过已学的线程知识，重构primer0.c</strong></big></p>
<p><strong>交叉分配法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  10 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct thr_arg_st</span><br><span class="line">&#123;</span><br><span class="line">    int id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line">    int ID;</span><br><span class="line">    ID = ((struct thr_arg_st *)p)-&gt;id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT+ID; i &lt;= RIGHT; i += THRNUM)</span><br><span class="line">    &#123;</span><br><span class="line">        mark = 1;</span><br><span class="line">        <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = 0;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is primer\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,id;</span><br><span class="line">    struct thr_arg_st *arg;</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(id = 0; id &lt; THRNUM; id++)</span><br><span class="line">    &#123;</span><br><span class="line">        arg = malloc(sizeof(*arg));</span><br><span class="line">        arg-&gt;id = id;</span><br><span class="line">        err = pthread_create((tid+id),NULL,thr_primer,arg);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(id = 0; id &lt; THRNUM; id++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[id],&amp;ptr);//回收线程,接收返回值</span><br><span class="line">        free(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>线程池方法：</strong></p>
<blockquote>
<p>线程池实现:<br>    main线程分发数字（任务），&gt;0为有任务，=0当前任务被完成，=-1没有任务可以分发了；<br>    其它线程抢任务，计算完成后将num清0；如果num为-1,线程跳出循环结束。</p>
</blockquote>
<br>    
①查询法，忙等（涉及互斥量）：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  (4)</span></span><br><span class="line"></span><br><span class="line">static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">static int num = 0;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line">    int n = (int)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">if</span>(num == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = num;</span><br><span class="line">        num = 0;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line"></span><br><span class="line">        mark = 1;</span><br><span class="line">        <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = 0;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]:%d is primer\n"</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_primer,(void *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">while</span>(num != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            sched_yield();//出让CPU使用权</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        &#125;</span><br><span class="line">        num = i;//下发新的数字</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">    num = -1;//提醒线程结束</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//回收线程</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
②通知法（涉及互斥量，条件变量）（cpu使用率较低）
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  (4)</span></span><br><span class="line"></span><br><span class="line">static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">static pthread_cond_t cond_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line">static int num = 0;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line">    int n = (int)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">while</span>(num == 0)</span><br><span class="line">        &#123;   </span><br><span class="line">            pthread_cond_wait(&amp;cond_num,&amp;mut_num);//等待任务下发或结束</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == -1)</span><br><span class="line">        &#123;   </span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        i = num;</span><br><span class="line">                num = 0;</span><br><span class="line">        pthread_cond_broadcast(&amp;cond_num);//广播通知任务被领取</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line"></span><br><span class="line">        mark = 1;</span><br><span class="line">        <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = 0;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]:%d is primer\n"</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_primer,(void *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //main线程下发数字</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">while</span>(num != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond_num,&amp;mut_num);//等待任务被线程领取</span><br><span class="line">        &#125;</span><br><span class="line">        num = i;</span><br><span class="line">        pthread_cond_signal(&amp;cond_num);//通知下游线程，有任务分发下来</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">    num = -1;//提醒线程结束</span><br><span class="line">    pthread_cond_broadcast(&amp;cond_num);//通知下游所有线程退出</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line"></span><br><span class="line">    //回收线程</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    pthread_cond_destroy(&amp;cond_num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 线程池方法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】线程介绍]]></title>
      <url>/zhoujiabo.github.io/2020/07/29/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p><strong>会话承载进程组，进程组承载进程，进程承载线程。</strong></p>
<p>1、线程的概念<br>    <strong>一个正在运行的函数<br>    多个线程的地址空间是共享的（代码段是共用的，栈是独立的）</strong><br>    posix线程是一套标准，而不是实现<br>    openmp线程<br>    线程标识：pthread_t（p是指posix标准）<br>    线程消耗进程号(ps ax -L 查看线程，LWP)<br>    编译和链接都要带-pthread。<br>    线程的调度取决于调度器的调度策略</p>
<p>pthread_equal();//比较两个线程<br>pthread_self();//返回当前线程标识</p>
<p>2、线程的创建<br>    pthread_create();<br>    //参数：pthread_t的地址，指定属性，入口函数地址，函数参数<br>    //返回值，成为返回0；失败返回error number，用strerror辅助报错</p>
<p>   线程的终止：<br>    3种方式：<br>&emsp;1）线程从启动例程返回，返回值就是线程的退出码<br>&emsp;2）线程可以被同一进程中的其它线程取消<br>&emsp;3）线程调用pthread_exit()</p>
<p>回收线程：pthread_join（类似进程中的wait）</p>
<p>   栈的清理<br>    pthread_cleanup_push();<br>    pthread_cleanup_pop();<br>    //比钩子函数多了主动权，pthread_cleanup_pop可以选择压栈的函数是否被调用<br>    //要成对出现，pop操作一定要有，如果放到pthread_exit后面，则都当成1。</p>
<p>简单例程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line">static void *func(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">"thread is working."</span>);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    puts(<span class="string">"begin."</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid,NULL,func,NULL);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid,NULL); //  等待线程终止</span><br><span class="line">    puts(<span class="string">"end."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);    //进程结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程的取消选项：<br>pthread_cancel();<br>&emsp;取消有两种状态：允许和不允许；<br>&emsp;允许取消又分为异步cancel和推迟cancel(默认)，推迟至cancel点再响应<br>&emsp;cancel点：POSIX定义的cancel点，都是<strong>可能引发阻塞的系统调用</strong><br>            pthread_setcancelstate()：设置是否允许取消    pthread_setcanceltype()：设置取消方式<br><strong>pthread_testcancel()：本函数什么都不做，就是一个cancel点(人为设置cancel点)</strong></p>
<p>   线程分离<br>    pthread_detach(); 设置线程的分离属性，其它线程不能对它回收。</p>
<br>
4、线程属性:

<p><strong>80%的问题用默认属性就可以解决</strong>。</p>
<p>&emsp;pthread_attr_init();<br>    &emsp;pthread_attr_destroy();<br>    &emsp;pthread_attr_setstacksize();<br>    &emsp;pthread_attr_setdetachstate();<br>&emsp;其它见man pthread_attr_init中的see also</p>
<p>   线程同步的属性<br>    互斥量属性：<br>        &emsp;pthread_mutexattr_init();<br>        &emsp;pthread_mutexattr_destroy();<br>        是否跨进程起作用：<br>        &emsp;pthread_mutexattr_getpshared();<br>        &emsp;pthread_mutexattr_setpshared();<br>&emsp;clone();//<em>可自定义地创建所需要的线程或进程</em><br>        互斥量类型：<br>        &emsp;pthread_mutexattr_gettype();<br>        &emsp;pthread_mutexattr_settype();<br>    条件变量属性：<br>        &emsp;pthread_condattr_init();<br>        &emsp;pthread_condattr_destroy();<br>        。。。。<br>    读写锁属性：<br>        。。。。</p>
<p>5、重入<br>   ①多线程中的IO<br>        <em>stdio默认都是支持多线程并发的</em>，先lock缓冲区，东西放进去，unlock。<br>        （<em>也有不加锁的版本</em>，可以尝试man getchar_unlocked查看）</p>
<p>   ②线程与信号<br>            <strong>每个线程都有mask和pending位图，而进程只有一个pending位图。每个线程从内核态<br>        退出时，先用mask与进程的pending按位与，再与线程的pending按位与</strong>。<br>                pthread_sigmask();<br>sigwait();<br>pthread_kill();</p>
<p>   ③线程与fork</p>
<p>6、openmp线程标准<br>    <a href="http://www.OpenMP.org" target="_blank" rel="noopener">www.OpenMP.org</a></p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pthread </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】信号进阶]]></title>
      <url>/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BF%A1%E5%8F%B7%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>7、信号集<br>&emsp;信号集类型：sigset_t<br>&emsp;sigemptyset();<br>&emsp;sigfillset();<br>&emsp;sigaddset();<br>&emsp;sigdelset();<br>&emsp;sigismember();</p>
<p>8、信号屏蔽字/pending集的处理<br>&emsp;sigprocmask();//设置信号屏蔽字，可以决定信号什么时候才响应。<br>&emsp;原型：int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);//set是信号集合，how是处理/操作方式</p>
<blockquote>
<p>首先，若oldset是非空指针，那么进程的当前信号屏蔽字通过oset返回。<br>其次，若set是一个非空指针，则参数how指示如何修改当前信号屏蔽字。<br>注意，不能阻塞SIGKILL和SIGSTOP信号。</p>
</blockquote>
<p>how有三种行为：SIG_BLOCK，阻塞某信号，即将mask中该信号对应的位清0；SIG_UNBLOCK，解除阻塞，即将mask的对应位恢复成1；SIG_SETMASK，直接设置屏蔽字。</p>
<p>block.c例程（<strong>阻塞SIGINT信号</strong>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void int_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    write(1,<span class="string">"!"</span>,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    sigset_t <span class="built_in">set</span>,oset,saveset;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = 0; j &lt; 1000; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(1,<span class="string">"*"</span>,1);</span><br><span class="line">            sleep(1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        write(1,<span class="string">"\n"</span>,1);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;oset,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、<strong>扩展(重要！)</strong><br>    sigsuspend();//wait for signal，原子操作；<br>    解除某个信号集的阻塞状态，马上进入等待信号阶段，信号一定会砸到sigsuspend();<br>    <strong>pause()的缺陷：不用用于信号驱动程序（有信号到来才能继续执行）<br>    信号驱动程序中，不能用pause()来等待一个信号，因为它是非原子操作，信号砸不到pause()上。</strong></p>
<p><strong>信号驱动例程（有SIGINT到来才能继续打印）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void int_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    write(1,<span class="string">"!"</span>,1);</span><br><span class="line">&#125;//</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    sigset_t <span class="built_in">set</span>,oset,saveset;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">    <span class="keyword">for</span>(j = 0; j &lt; 1000; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(1,<span class="string">"*"</span>,1);</span><br><span class="line">            sleep(1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        write(1,<span class="string">"\n"</span>,1);</span><br><span class="line">        sigsuspend(&amp;oset);//等待一个信号</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sigaction();//用来替换signal();<br><strong>signal()中的缺陷：<br>&emsp;多个信号可以共用一个信号处理函数，容易发生重入。<br>&emsp;没有区别信号的来源，容易被别的用户干涉。</strong><br>    int sigaction(int signum, const struct sigaction <em>act,<br>                     struct sigaction *oldact);<br>    struct sigaction {<br>               void     (</em>sa_handler)(int);<br>               void     (<em>sa_sigaction)(int, siginfo_t *, void *);<br>               sigset_t   sa_mask;<br>               int        sa_flags;<br>               void     (</em>sa_restorer)(void);<br>           };<br>    ①sa_handler和sa_sigaction不能同时设置，可以理解为它俩是共用体；<br>    ②sa_mask:在响应当前信号时，还需要将哪些信号block住；<br>    ③三参的信号处理函数：<br>        int是信号类别，当多个信号可以共用一个信号处理函数时有意义；<br>        siginfo_t是信号属性结构体，其中最常用的是sig_code（从哪来，用户，内核，信号队列，，，）<br>                 从而可以决定是否响应该信号，使其只响应从指定位置来的信号。<br>        void *，第三个参数不再使用，原来为ucontext_t *类型，保存信号响应之前的上下文</p>
</blockquote>
<p>用sigaction函数(单参)重构mydaemon.c（<strong>防止重入</strong>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static FILE *fp;</span><br><span class="line">static void daemon_exit(int s)</span><br><span class="line">&#123;</span><br><span class="line">    //fprintf(fp,<span class="string">"mydaemon_exit()\n"</span>);//测试时用</span><br><span class="line">    fclose(fp);</span><br><span class="line">    closelog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    struct sigaction sa;</span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>,LOG_PID,LOG_DAEMON);//关联syslog，想要写日志的人物为mydaemon，日志包含其pid，日志的来源为守护进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sa.sa_handler = daemon_exit;//信号处理函数</span><br><span class="line">    sa.sa_flags = 0;//没有特殊要求</span><br><span class="line"></span><br><span class="line">    //信号在响应过程中要屏蔽的信号集，防止重入</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    //在响应SIGINT时，其本身也是被屏蔽着的；换句话说，在响应SIGINT时，下面三个</span><br><span class="line">信号都是被屏蔽住的</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGINT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGTERM);</span><br><span class="line"></span><br><span class="line">    //注册信号及其响应行为</span><br><span class="line">    sigaction(SIGINT,&amp;sa,NULL);</span><br><span class="line">    sigaction(SIGQUIT,&amp;sa,NULL);</span><br><span class="line">    sigaction(SIGTERM,&amp;sa,NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = creatdaemon();</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"creatdaemon() failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        syslog(LOG_INFO,<span class="string">"creatdaemon() success!"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    daemontask();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/25/sigaction0c52dcb349719bd1.png" alt="注意：前面的ctrl+c未响应，是因为中断信号发给了当前shell进程，而不是发给mydaemon的" title="" class="">
                <p>注意：前面的ctrl+c未响应，是因为中断信号发给了当前shell进程，而不是发给mydaemon的</p>
            </figure>

<br>
    setitimer();//用来替换alarm();
    setitimer()，设置时钟周期，误差不累积，精度到us。
    倒计时到0时发送时钟信号，且会将it_interval赋给it_value，进入下一个周期。

<p><strong>尝试1：使用单一计时器，利用alarm或setitimer构造一组函数，实现任意数量的计时器。</strong></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/25/anytimerf1458c5094c43365.png" alt="效果图" title="" class="">
                <p>效果图</p>
            </figure>

<p>参考：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef ANYTIMER_H__</span></span><br><span class="line"><span class="comment">#define ANYTIMER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define JOB_MAX 1024</span></span><br><span class="line"><span class="comment">#define ARGSIZE 1024</span></span><br><span class="line">typedef void jobfunc_t(char *);</span><br><span class="line"></span><br><span class="line">typedef enum jobstat</span><br><span class="line">&#123;</span><br><span class="line">    Running,</span><br><span class="line">    Cancel,      </span><br><span class="line">    Pause,      </span><br><span class="line">    Finish</span><br><span class="line">&#125;estat;</span><br><span class="line"></span><br><span class="line">struct timjob_st</span><br><span class="line">&#123;</span><br><span class="line">    int time;   //设置的时间 </span><br><span class="line">    int sec;    //倒计时时间</span><br><span class="line">    jobfunc_t *jobp;</span><br><span class="line">    char arg[ARGSIZE];</span><br><span class="line">    estat <span class="built_in">stat</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************************</span><br><span class="line">*<span class="built_in">return</span> &gt;= 0        成功，返回任务id</span><br><span class="line">*       == -ENOSPC  失败，数组满</span><br><span class="line">*       == -ENOMEM  失败，内存空间不足</span><br><span class="line">*******************************/</span><br><span class="line">int at_addjob(int time,jobfunc_t *jobp,char *arg);</span><br><span class="line"></span><br><span class="line">int at_canceljob(int id);   //取消任务，能计时但不会执行动作  </span><br><span class="line">int at_deljob(int id);      //执行动作完成，可销毁</span><br><span class="line">//int at_pausejob(int id);	//暂时没用到</span><br><span class="line">//int at_resumejob(int id);	</span><br><span class="line">int job_num(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<p><strong>尝试2：用刚学到的setitimer和sigaction函数（三参）重构令牌桶程序（只有来自内核的SIGALRM信号才有效）</strong><br>原来的令牌桶程序的bug：令牌桶程序（./mytbf /etc/services）在运行，如果有其它进程向它不断发送SIGALRM信号（新建shell，命令行输入 while true; do kill -SIGALRM ‘pid’; done），流速直接上升到峰值，内容很快输出完毕。</p>
<p>10、实时信号<br>①实时信号是要排队的，它的响应是有顺序要求的。<br>②既收到实时信号又收到标准信号，先响应标准信号。<br>③实时信号不丢失。</p>
<p>还是之前的信号驱动例程，用实时信号（SIGRTMIN+6）替换SIGINT；编译执行，新建终端，命令行输入kill -40 pid，发送多次时，可以观察到信号没有丢失，都得到了响应。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sigaction, setitimer </tag>
            
            <tag> 实现anytimer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】令牌桶封装]]></title>
      <url>/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BB%A4%E7%89%8C%E6%A1%B6%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>将令牌桶封装成一个库，以便满足多个用户或进程的不同流控需求。</p>
<p>mkdir mytbf<br>cd mytbf<br>touch main.c mytbf.c mytbf.h makefile</p>
<blockquote>
<p>补充vim多标签：同时打开编辑多个文件<br>vim * -p //打开当前目录下所有文件<br><br>切换标签<br>    :tabr    跳到第一个标签<br>    :tabl    跳到最后一个标签<br>    :tabn    下一个标签，快捷方式gt<br>    :tabp    上一个标签，快捷方式gT<br><br>关闭与保存<br>    :wall    保存所有标签<br>    :qall    退出所有标签<br>    :q        关闭当前标签<br>    :only    只保留当前标签<br><br>新建文件<br>    :tabnew</p>
</blockquote>
<p>makefile文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all:mytbf</span><br><span class="line"></span><br><span class="line">mytbf:main.o mytbf.o</span><br><span class="line">    gcc $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">clean: </span><br><span class="line">    rm -rf *.o mytbf</span><br></pre></td></tr></table></figure>
<p>可能遇到的问题：makefile:3: *** missing separator (did you mean TAB instead of 8 spaces?).  Stop.</p>
<blockquote>
<p>原因：vimrc中设置了用4个空格替换tab键。<br>解决：非编辑模式下输入:%s/^[ ]+/\t/g</p>
</blockquote>
<p>mytbf.h文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> main.c  makefile  mytbf.c  mytbf.h                                          X</span><br><span class="line"><span class="comment">#ifndef MYTBF_H__</span></span><br><span class="line"><span class="comment">#define MYTBF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MYTBF_MAX 1024</span></span><br><span class="line"></span><br><span class="line">typedef void mytbf_t;</span><br><span class="line"></span><br><span class="line">mytbf_t *mytbf_init(int cps,int burst);</span><br><span class="line"></span><br><span class="line">int mytbf_fetchtoken(mytbf_t *ptr,int size);</span><br><span class="line"></span><br><span class="line">int mytbf_returntoken(mytbf_t *ptr,int size);</span><br><span class="line"></span><br><span class="line">int mytbf_destory(mytbf_t *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<p>mytbf.c文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include "mytbf.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef void (*sighandler_t) (int);</span><br><span class="line"></span><br><span class="line">struct mytbf_st</span><br><span class="line">&#123;</span><br><span class="line">    int cps;</span><br><span class="line">    int burst;</span><br><span class="line">    int token;</span><br><span class="line">    int pos;</span><br><span class="line">&#125;;</span><br><span class="line">static int inited = 0;</span><br><span class="line">static struct mytbf_st *job[MYTBF_MAX];//static,默认初始化为0</span><br><span class="line"></span><br><span class="line">sighandler_t alrm_handler_save;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    alarm(1);//设置下一秒的时钟</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">            <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void module_unload(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    signal(SIGALRM,alrm_handler_save);//恢复原来的行为</span><br><span class="line">    alarm(0);//将闹钟关掉</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        free(job[i]);</span><br><span class="line">        job[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void module_load(void)</span><br><span class="line">&#123;</span><br><span class="line">    alrm_handler_save = signal(SIGALRM,alrm_handler);</span><br><span class="line">    alarm(1);</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line">static int get_free_pos(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == NULL)</span><br><span class="line">            <span class="built_in">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mytbf_t *mytbf_init(int cps,int burst)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me;</span><br><span class="line">    int pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inited)</span><br><span class="line">    &#123;</span><br><span class="line">        module_load();</span><br><span class="line">        inited = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pos = get_free_pos();</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> NULL;//令牌桶个数达到上限</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">        <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;//malloc失败</span><br><span class="line"></span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;token = 0;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me;</span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line">static int min(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="built_in">return</span> a;</span><br><span class="line">    <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//size为想要取的token数，返回值为实际取得的token数</span><br><span class="line">int mytbf_fetchtoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= 0)</span><br><span class="line">        pause();</span><br><span class="line"></span><br><span class="line">    n = min(me-&gt;token,size);</span><br><span class="line"></span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归还未使用的token</span><br><span class="line">int mytbf_returntoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    me-&gt;token += size;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int mytbf_destory(mytbf_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;//转换</span><br><span class="line"></span><br><span class="line">    job[me-&gt;pos] = NULL;</span><br><span class="line">    free(ptr);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>main.c文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "mytbf.h"</span></span><br><span class="line"><span class="comment">#define CPS 10 //流控制，每秒10个字符    </span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"><span class="comment">#define BURST 100   //最多只能攒100次权限</span></span><br><span class="line"></span><br><span class="line">//令牌桶：没有数据到来，就攒权限；数据来时，连续读写token次。</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mytbf_t *tbf;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    long len,ret,pos;</span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage ...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tbf = mytbf_init(CPS,BURST);//初始化一个令牌桶</span><br><span class="line">    <span class="keyword">if</span>(tbf == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"mytbf_init() fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fd = open(argv[1],O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(fd &lt; 0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        size  = mytbf_fetchtoken(tbf,BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span>(size &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"mytbf_fetchtoken() fail:%s\n"</span>,strerror(-size));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( (len = <span class="built_in">read</span>(fd,buf,size)) &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(len == 0)//没有数据到来或已读取完成，继续等待新数据</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(size - len &gt; 0)//有可能没消耗完token，，文件尾</span><br><span class="line">            mytbf_returntoken(tbf,size-len);</span><br><span class="line"></span><br><span class="line">        pos = 0;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; 0) //防止漏写</span><br><span class="line">        &#123;</span><br><span class="line">            ret = write(1,buf+pos,len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret; //这次又写了ret个字节，pos是已写的字节数</span><br><span class="line">            len -= ret; //还剩多少个字节没写</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    mytbf_destory(tbf);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim 多标签 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】漏桶与令牌桶]]></title>
      <url>/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E6%BC%8F%E6%A1%B6%E4%B8%8E%E4%BB%A4%E7%89%8C%E6%A1%B6/</url>
      <content type="html"><![CDATA[<p>漏桶：每秒打印10个字符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#define CPS 10 //流控制，每秒10个字符    </span></span><br><span class="line"><span class="comment">#define BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static volatile int loop = 1;</span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    alarm(1);//设置下一秒时钟</span><br><span class="line">    loop = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int fd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    long len,ret,pos;</span><br><span class="line">    struct itimerval itv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage ...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    signal(SIGALRM,alrm_handler);</span><br><span class="line">    alarm(1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fd = open(argv[1],O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(fd &lt; 0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop)</span><br><span class="line">            pause();// 等待时钟信号</span><br><span class="line">        loop = 1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( (len = <span class="built_in">read</span>(fd,buf,BUFSIZE)) &lt; 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)//如果是中断打断了读操作，则不报错，重新读</span><br><span class="line">            	<span class="built_in">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = 0;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; 0) //防止漏写</span><br><span class="line">        &#123;</span><br><span class="line">            ret = write(1,buf+pos,len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret; //这次又写了ret个字节，pos是已写的字节数</span><br><span class="line">            len -= ret; //还剩多少个字节没写</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/25/e9ebf16bb9f0c42038e51f012c214fe1cc4b9a0c89cfa248.png" alt="" title="" class="">
                <p></p>
            </figure>


<br>
令牌桶：漏桶的优化
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define BURST 100   //最多只能攒100次权限</span></span><br><span class="line"></span><br><span class="line">//没有数据到来，就攒权限；数据来时，连续读写token次。</span><br><span class="line"></span><br><span class="line">static volatile sig_atomic_t token = 0;</span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    alarm(1);</span><br><span class="line">    token++; </span><br><span class="line">    <span class="keyword">if</span>(token &gt; BURST)</span><br><span class="line">        token = BURST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(token &lt;= 0)//没有token</span><br><span class="line">            pause();</span><br><span class="line">        token--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( (len = <span class="built_in">read</span>(fd,buf,BUFSIZE)) &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(len == 0)//没有数据或已读取完成，继续等新的数据</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：先准备一个有少量数据的文件/tmp/out，命令行./slowcat2 /tmp/out，数据以10字符/s打印完成后等待新数据到来；等一会儿，新建终端，输入cat /etc/services &gt;&gt; /tmp/out追加数据到/tmp/out，这时因为攒的权限够多，所以可以观察到：回车后瞬间输出大量内容，然后恢复10字符/s的打印速度。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 流控 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】信号基础]]></title>
      <url>/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>先补充两个概念:</p>
<p>同步，用户知道什么时候发生什么事件。（单进程程序）<br>异步，这个事件什么时候到来不知道，会产生什么结果不知道。</p>
<p>异步事件的处理：查询法，通知法<br>发生频率稀疏—通知法（但是也要有相应的机制监听）</p>
<p>一、信号</p>
<p>1、信号的概念<br>    <strong>信号是软件层面的中断。信号的响应依赖于中断。</strong></p>
<p>2、signal()<br>#include &lt;signal.h&gt;<br>typedef void (*sighandler_t)(int);    //sighandler_t是函数指针，返回值为void，参数为int<br>sighandler_t signal(int signum, sighandler_t handler);<br>@param：<br>    signum：为信号编号，如SIGINT表示终端中断符，ctrl+c是其快捷方式<br>    handler：为函数指针，也可以是SIG_IGN忽略信号，或SIG_DFL默认动作<br>@return：上一个信号的行为</p>
<p>void ( *signal(int signum, void (*func)(int)) )(int)<br>//头文件中没有sighandler_t的定义，每次要用时在文件头加typedef void (*sighandler_t)(int);</p>
<p>signal小例程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void int_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    write(1,<span class="string">"!"</span>,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(1,<span class="string">"*"</span>,1);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言的缺陷之一：名空间管理不善，如果名字冲突就完蛋了。</p>
<p>信号会打断阻塞的系统调用。<br>    查看man手册知open存在返回值为EINTR的情况，<strong>当阻塞等待打开一个慢设备时，调用可能被信号打断。<br>    所以在使用阻塞系统调用时，要判断是真错还是假错（被信号打断）</strong></p>
<p>重构mycpy.c中open和read内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    sfd = open(argv[1], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(sfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR)//不是信号导致的打开失败</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //<span class="keyword">else</span> <span class="built_in">continue</span>;//是假错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(sfd &lt; 0);</span><br></pre></td></tr></table></figure>

<p>3、信号的不可靠<br>    信号的行为不可靠，执行现场是由内核布置的，<strong>有可能第一次调用还没结束就发生了第二次调用。</strong></p>
<p>4、可重入函数<br>    所有的系统调用都是可重入的，一部分库函数也是可重入的，如memcpy</p>
<p><strong>一些库函数其本身是不可重入的，所以需要额外的_r版本函数，<br>如rand_r,localtime_r,,,专门用于信号处理。</strong></p>
<p>5、<strong>信号的响应过程（重点）</strong></p>
<p>2个位图，mask，pending，理论上是32位的。<br>mask是信号屏蔽字（初始全为1），pending位图（初始全为0）</p>
<p>&emsp;从内核回到用户态时要进行mask&amp;pending，如果有信号到来(pending对应位为1)，则将mask，pending中的信号位归0，<br>栈中PC寄存器值表示的执行位置地址换成int_handler函数地址；响应完成后，mask对应信号位恢复，<br>PC寄存器值也恢复原来的执行位置。</p>
<blockquote>
<p>总结与思考：<br>①信号从收到到响应有一个不可避免的延迟。<br>&emsp;信号是进程从kernel回到user的路上响应的。<br>②如何忽略掉一个信号？<br>&emsp;SIG_IGN实现实际就是将mask中表示某信号的位置0<br>③标准信号为什么要丢失？<br>&emsp;位图不会计数<br>④标准信号的响应没有严格的顺序<br>⑤不能从信号处理函数中随意的往外跳。（可能会错过mask的恢复过程，sigsetjump,siglongjump）</p>
</blockquote>
<p>6、常用函数<br>    kill();//发信号，int kill(pid_t pid, int sig);<br>&emsp;参数pid:<br>&emsp;&emsp;&gt;0，发送信号到对应pid的进程<br>&emsp;&emsp;0，当前进程的进程组广播（组内广播）<br>&emsp;&emsp;-1，发送信号到init以外的所有进程（全局广播），一般是Init进程用来广播通知所有进程终止。<br>&emsp;&emsp;&lt;-1，发送信号到ID为|-pid|的进程组中的所有进程（特定gid的组广播）。<br>&emsp;参数sig：为0时，不会发送信号，用于测试一个进程或进程组是否存在。<br>&emsp;errno：EPERM，没有发送信号的权限；ESRCH，进程或进程组不存在</p>
<p>raise();//发送信号给当前进程，int raise(int sig);</p>
<p>alarm();//设置时钟信号，unsigned int alarm(unsigned int seconds);<br>&emsp;当seconds倒计时到0，产生SIGALRM信号，默认动作是终止当前进程。<br><strong>有些平台sleep是用alarm+pause封装的。所以不要在程序中混用alarm和sleep。</strong></p>
<p>pause();//等待一个信号<br>abort();</p>
<p>system();<br>&emsp;想要在有信号的进程当中使用system，需要blocked掉SIGCHLD，ignored掉SIGIINT和SIGQUIT。</p>
<p>sleep();的替代函数：<br>&emsp;nanosleep();<br>&emsp;usleep();<br>&emsp;select();</p>
<p>alarm小例程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line">static volatile int loop = 0;</span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    loop = 1;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t count = 0;</span><br><span class="line">    signal(SIGALRM,alrm_handler);</span><br><span class="line">    alarm(5);</span><br><span class="line">    <span class="keyword">while</span>(!loop)//5s内count能加到几？</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc -S 5sec_sig.c -O1    //对源文件进行优化，获取其汇编文件<br>查看其汇编文件，while(loop)会陷入死循环，因为是去内存中取的loop的值，没有变过。<br>解决：volatile修饰loop，去这个变量的真正空间取数值。</p>
<p>测试结果：优化之后得到的count大约是原来计数值的7倍。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/25/8de76ea3f17269cb6bd94dd00d81d6b529fb6ec6c20192fb.png" alt="" title="" class="">
                <p></p>
            </figure>]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 信号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】守护进程与系统日志]]></title>
      <url>/zhoujiabo.github.io/2020/07/19/%E3%80%90apue%E3%80%91%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<p>10、守护进程：一些服务需要一直在后台跑。<br>    会话session，标识sid<br>    终端</p>
<p>守护进程一般是一个会话的Leader，也是一个进程组的Leader。<br><strong>线程为单位的编程。进程实际就是容器。</strong><br>多线程是先有标准化，先把框框架架弄好，再在框架下实现并发内容。多线程并发比多进程并发更好控一些。</p>
<p>一个session中存在多个进程，<br>前台进程组，后台进程组。<strong>最多只有一个前台进程组，可以没有。只有前台进程组能使用标准输入输出</strong>。</p>
<p>守护进程的特点：<br>    setsid();//创建一个会话，并设置进程组ID。<br>    只有子进程才能创建会话，调用方会成为新的会话的leader，会成为当前新的进程组的leader，并脱离控制终端。<br>    ps axj<br>    <strong>守护进程，tty为’?’，sid，pgid，pid相同。如果创建的子进程是守护进程，那么其父进程不会一直等，<br>    所以守护进程的ppid为1。（不一定，ubuntu较新的发行版都用 upstart 代替 init 来收养孤儿进程。）</strong></p>
<p>int setpgid(pid_t pid, pid_t pgid);//将指定pid号的进程放到pgid进程组<br>pid_t getpgid(pid_t pid);//返回指定pid号的进程的进程组id，为0时返回当前进程id</p>
<p>pid_t getpgrp(void);//返回当前进程的进程组id，POSIX.1方言<br>pid_t getpgrp(pid_t pid); //查看某个进程的进程组id，BSD方言</p>
<p>单实例守护进程：锁文件/var/run/name.pid ,记录了某些守护进程的pid。<br><strong>（一些守护进程如sshd、rsyslogd，同一时间只能跑一份，利用锁文件来完成单实例守护进程的控制）</strong><br>启动脚本文件：/etc/rc*…，人为将某个守护进程添加到启动项</p>
<p>11、系统日志文件<br>    /var/log</p>
<p>每个系统服务都有必要写系统日志，但我又不能让人人都写。权限分隔层。<br><strong>root将写系统日志的权限交给syslogd服务，所有要写系统日志的进程都将日志信息提交syslogd，<br>由syslogd统一地接收、写系统日志。</strong></p>
<p>#include &lt;syslog.h&gt;<br>    openlog();     //与syslog关联<br>    syslog();    //提交<br>    closelog();</p>
<p>void openlog(const char *ident, int option, int facility);<br>&emsp;ident：可以是任何字段，一般是程序名字<br>&emsp;option：一些控制标志，如LOG_PID表示每条日志信息包含PID；LOG_PERROR表示同时将error信息打印到stderr。<br>&emsp;facility：提交日志信息的服务类型，也可以说是日志信息来源；<br>              如LOG_DAEMON表示系统守护进程的日志，LOG_FTP表示是FTP的日志信息</p>
<p>void syslog(int priority, const char *format, …);<br>&emsp;priority：是facility或上level的结果，level是级别，如LOG_ERR,LOG_WARNING,LOG_INFO<br>&emsp;format：类似printf的格式，不用’\n’，因为我们只是提交信息，由syslogd服务实际写日志。</p>
<blockquote>
<p>/var/log/syslog记录了系统大部分日志信息<br>/etc/rsyslog.conf为syslog配置文件，如约定level&gt;LOG_INFO才往日志中写信息。    </p>
</blockquote>
<p><strong>mydaemon例程：</strong>创建一个守护进程，守护进程负责不断往/tmp/out中写数字；并将程序中的错误提交系统日志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;syslog.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define FNAME "/tmp/out"</span></span><br><span class="line"></span><br><span class="line">static int creatdaemon(void)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> -1; //fork失败</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //<span class="built_in">printf</span>(<span class="string">"[%d]:parent exit\n"</span>,pid);</span><br><span class="line">        <span class="built_in">exit</span>(0); //父进程直接退出</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //<span class="built_in">printf</span>(<span class="string">"[%d]:child is working\n"</span>,pid);</span><br><span class="line">    fd = open(<span class="string">"/dev/null"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; 0) </span><br><span class="line">        <span class="built_in">return</span> -2;  //open失败</span><br><span class="line"></span><br><span class="line">    //脱离控制终端，将0,1,2重定向到/dev/null</span><br><span class="line">    dup2(fd,0);</span><br><span class="line">    dup2(fd,1);</span><br><span class="line">    dup2(fd,2);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">"/"</span>);//守护进程一直在跑，最好就将PWD切换成根，因为根是一直存在的 </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static void daemontask(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME,<span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"fopen() failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=0; ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(fp,<span class="string">"%d\n"</span>,i);</span><br><span class="line">        fflush(fp); //文件是全缓冲，要刷新缓冲区</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>,LOG_PID,LOG_DAEMON);//关联syslog，想要写日志的人物为mydaemon，日志包含其</span><br><span class="line">pid，日志的来源为守护进程</span><br><span class="line"></span><br><span class="line">    ret = creatdaemon();</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"creatdaemon() failed!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == -1)</span><br><span class="line">            syslog(LOG_ERR,<span class="string">"fork() failed!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == -2)</span><br><span class="line">            syslog(LOG_ERR,<span class="string">"open() failed!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        syslog(LOG_INFO,<span class="string">"creatdaemon() success!"</span>);</span><br><span class="line"></span><br><span class="line">    daemontask();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/20/cd981de91817d02e01727b11090e91ea2537cc10ec5cc0af.png" alt="" title="" class="">
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/20/16fbaad86c45f74304977acee218fc2f5c1b9b1e6a63f817.png" alt="" title="" class="">
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/20/d8d29885a6fc2350f1563222a679e84b3ffcb665b06fde12.png" alt="查看系统日志文件/var/log/syslog" title="" class="">
                <p>查看系统日志文件/var/log/syslog</p>
            </figure>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 创建守护进程例程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】用户权限与组权限]]></title>
      <url>/zhoujiabo.github.io/2020/07/18/%E3%80%90apue%E3%80%91%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E4%B8%8E%E7%BB%84%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<p>执行某个命令时，是带着身份的。</p>
<p><strong>u+s权限：将root用户的权限打散，往下放。<br>二进行文件的权限如果是u+s，则在文件执行时，它的身份会暂时切换成文件的user用户</strong><br>（如passwd，过去普通用户是无法更改自己的口令的。而现在本身普通用户虽然无法查看修改/etc/shadow，<br>但普通用户却能通过passwd命令，修改自身的口令。就是通过将/usr/bin/passwd设置为u+s权限来实现的。）</p>
<p>shell进程fork，exec出一个子进程passwd，子进程身份暂时切换成root执行，父进程shell等待回收子进程。</p>
<p>g+s权限，，，类似</p>
<p>函数：<br>    getuid();//get real user id                            geteuid();//get effective user id<br>    getgid();                                            getegid();<br>    setuid();//设置euid。                                setgid();//设置egid<br>    setreuid();//交换ruid和euid,且是原子化操作            setregid();</p>
<blockquote>
<p>给二进制可执行文件添加u+s权限：<br>    将文件用户设置为root(sudo chown root xxx)，并添加u+s权限(sudo chmod u+s xxx)。</p>
</blockquote>
<p><strong>简单mysu实现</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现 ./mysu 0 cat /etc/shadow</span><br><span class="line">    //不要太天真，不是说切换就能切换的。需要将文件用户设置为root，并添加u+s权限。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child</span><br><span class="line">    &#123;</span><br><span class="line">        setuid(atoi(argv[1]));//切换用户身份，测试</span><br><span class="line">        execvp(argv[2],argv+2);//替换子进程镜像，执行cat /etc/shadow</span><br><span class="line">        perror(<span class="string">"execvp()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wait</span>(NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/18/c6a94e6ba0fc4dd1a8277932f45e68e489153db983440c87.png" alt="必须将用户改为root且给予u+s权限" title="" class="">
                <p>必须将用户改为root且给予u+s权限</p>
            </figure>

]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】进程基础]]></title>
      <url>/zhoujiabo.github.io/2020/07/17/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>进程基本知识</p>
<p>1、进程标识符pid<br>    pid_t （int16_t，3w多个进程），虚拟机技术，有可能不够用<br>    命令ps,  man ps 查找组合用法， ps axf<br>    <strong>进程号是顺次向下使用。（与fd有区别）</strong><br>    getpid();     //获取当前进程的Pid<br>    getppid();</p>
<p>2、进程的产生<br>    fork();</p>
<blockquote>
<p>①关键字：duplicating，复制，拷贝，一模一样，连运行到的位置都相同<br>②fork后父子进程的区别：fork的返回值不一样，pid不同，ppid也不同，<br>未决信号（还没来得及去响应的信号）和文件锁不继承，资源利用量归零<br>③Init进程：1号，是所有进程的祖先进程。<br>④fork成功，父进程中返回的是子进程的Pid，子进程中返回0；fork失败，父进程中返回-1，设置errno。    </p>
</blockquote>
<p>永远不要猜测父子进程哪先被调度，这是由调度器的调试策略决定的。<br>非常重要！！！<strong>fork前fflush(NULL),刷新所有成功打开的流</strong>。</p>
<p>zombie态在进程关系中是正常的（但通常是短暂性存在的），谁打开谁关闭，谁申请谁释放，子进程是父进程创建的，而如果<strong>父进程在忙，子进程终止后无人”收尸”，子进程就呈现Z+态</strong>。</p>
<p><strong>父进程终止，而子进程没有终止，子进程变成孤儿进程，最后会被Init进程接管（ps axf可以看到子进程的父进程为init进程）；孤儿进程占用的资源一般是比较少的，但进程号比较宝贵</strong>。</p>
<p>了解：vfork();<br>用vfork创建的子进程，实际和父进程指向的是同一块物理内存；但vfork创建的子进程，只能调用_exit()或exec()，其它行为（如关闭一个文件）是未定义的。</p>
<p><strong>fork()是写时拷贝，只读时父子进程指向同一块空间</strong>。父子进程谁想写，谁去复制一份内存到其它空间。fork通过定时拷贝技术，基本将过去vfork的功能糅合进来了，所以vfork逐渐被废弃。    </p>
<p><strong>fork函数例程</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//fork：duplicating，拷贝，一模一样，连运行到的位置都相同；</span><br><span class="line">//区别：fork返回值不同，pid,ppid不同，未决信号和文件锁不继承，资源清零。</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]:begin.\n"</span>,getpid());</span><br><span class="line">    //加了\n，因为默认输出设备是stdout，行缓冲，会刷新缓冲区；</span><br><span class="line">    //所以命令./fork，打印一次begin</span><br><span class="line"></span><br><span class="line">    //命令./fork1 &gt; /tmp/out，输出设备是文件，默认是全缓冲，还来得及没写到文件中，马上fork了，&gt;父子进程缓冲区都有存在一句“begin.”。    </span><br><span class="line"></span><br><span class="line">    fflush(NULL);//正确的做法是fork之前刷新所有打开的流。</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]:child is working\n"</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>            //parent</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]:parent is working\n"</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]:end.\n"</span>,getpid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考点：打印结果，与缓冲区有关。比较下列三种结果</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/17/b5bd6cb7296c206db816587de4590a4c2fc74b08cbe7a875.png" alt="终端输出，行缓冲" title="" class="">
                <p>终端输出，行缓冲</p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/17/01ca2d5a69d91f2054cd9c756413a7117fc0f585c91d506b.png" alt="文件是全缓冲，fflush刷新缓冲区" title="" class="">
                <p>文件是全缓冲，fflush刷新缓冲区</p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/17/52f5638cb6e6652d39c1b77f3b4be09b7ac5e0b36eedf89d.png" alt="文件是全缓冲，无fflush" title="" class="">
                <p>文件是全缓冲，无fflush</p>
            </figure>


<p>3、进程的消亡及释放资源<br>    wait();    和 waitpid();    等待进程状态发生变化</p>
<p>pid_t wait(int *status);//成功返回终止子进程的pid，将子进程的状态存储到status指向的内存。死等，是阻塞的。</p>
<p>pid_t waitpid(pid_t pid, int *status, int options);</p>
<p>@params:<br>    options是位图，如果有WNOHANG参数，函数变成非阻塞的。<br>    pid: &lt;-1，收进程组id为|-n|中的任何一个子进程<br>          -1，收任何一个子进程<br>           0，收与当前进程同组的一个子进程<br>          &gt;0，收指定pid号的子进程 </p>
<p>wait(&amp;status)    equal to     waitpid(-1,&amp;status,0)<br>如果只是要回收而不关心子进程的状态，也可以wait(NULL)。</p>
<p>了解：waitid(); wait3(); wait4();</p>
<p>进程分配：<br>①分块法<br>②交叉分配（有可能进程拿到的数永远是某个数的倍数）<br>③池（涉及到竞争）</p>
<p><strong>计算出某区间内所有的质数</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //父进程不断创建子进程</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //质数的计算交给子进程</span><br><span class="line">        <span class="keyword">if</span>(pid == 0)        //child</span><br><span class="line">        &#123;</span><br><span class="line">            mark = 1;</span><br><span class="line">            <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    mark = 0;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d is primer\n"</span>,i);</span><br><span class="line"></span><br><span class="line">            //如果没有<span class="built_in">exit</span>，子进程还会去fork。</span><br><span class="line">            <span class="built_in">exit</span>(0);//子进程正常终止</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">        <span class="built_in">wait</span>(NULL);//只是要回收，不关心回收的子进程的状态</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/***************没必要每次计算都创建进程，可以创建N个进程交叉分配计算任务，作出如下优化***********************/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,n,mark;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(n = 0; n &lt; N; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //父进程连续创建N个子进程后等待N个子进程完成计算，子进程交叉分配任务</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid == 0)	//child</span><br><span class="line">        &#123;</span><br><span class="line">            //第一个进程分配的数总是3的倍数</span><br><span class="line">            <span class="keyword">for</span>(i = LEFT + n; i &lt;= RIGHT; i += N)</span><br><span class="line">            &#123;</span><br><span class="line">                    mark = 1;</span><br><span class="line">                    <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            mark = 0;</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(mark)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"[%d]:%d is primer\n"</span>,n,i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">             <span class="built_in">exit</span>(0);//子进程正常终止</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(n = 0; n &lt; N; n++)</span><br><span class="line">        <span class="built_in">wait</span>(NULL);//只是要回收，不关心回收的子进程的状态</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>4、exec函数族<br>bash<br>&emsp;./primer2<br>&emsp;&emsp;./primer2<br>&emsp;&emsp;./primer2<br>&emsp;&emsp;…<br>&emsp;&emsp;201个</p>
<p>所谓的父进程是bash创建的，为什么bash创建的子进程不叫bash。</p>
<p>exec函数族：用一个新的进程镜像替换当前的进程镜像<br>//execl(“/bin/date”,”date”,”+%s”,NULL);//如果成功，不会返回</p>
<p>变参：<br>    execl();<br>    execlp();<br>    execle();</p>
<p>定参：<br>    execv();<br>    execvp();    //例：execvp(globres.gl_pathv[0],globres.gl_pathv);</p>
<p>int execl(const char <em>path, const char *arg, …<br>                       /</em> (char  *) NULL */);<br>int execvp(const char *file, char *const argv[]);//文件名，和argv</p>
<p>char <em>strsep(char *</em>stringp, const char *delim);//根据指定分隔符（可以是” \t\n”）将串分隔</p>
<p><strong>简单实现mysh，只处理外部命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;glob.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DELIMS  " \t\n"     //定义分隔符</span></span><br><span class="line">struct cmd_t</span><br><span class="line">&#123;</span><br><span class="line">    glob_t globres;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void prompt(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mysh-0.1$"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void pharse(char *line, struct cmd_t  *res)</span><br><span class="line">&#123;</span><br><span class="line">    char *tok;</span><br><span class="line">    int i = 0;</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        tok = strsep(&amp;line,DELIMS);//根据分隔符将串分隔</span><br><span class="line">        <span class="keyword">if</span>(tok == NULL) //有问题</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tok[0] == <span class="string">'\0'</span>)//多个分隔符连续时，会解析出空串</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">        glob(tok,GLOB_NOCHECK|GLOB_APPEND*i,NULL,&amp;res-&gt;globres);</span><br><span class="line">        i = 1;//i的作用，第一次GLOB_APPEND参数失效</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    char *linebuf = NULL;</span><br><span class="line">    size_t linebuf_size = 0;</span><br><span class="line">    struct cmd_t cmd;</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        prompt();   //提示符</span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf,&amp;linebuf_size,stdin) &lt; 0)//从标准输入获取一行</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        pharse(linebuf,&amp;cmd);//解析命令行</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(0)   //内部命令</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span>    //只处理外部命令</span><br><span class="line">        &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"fork()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid == 0) //child</span><br><span class="line">            &#123;</span><br><span class="line">                execvp(cmd.globres.gl_pathv[0],cmd.globres.gl_pathv);</span><br><span class="line">                perror(<span class="string">"execvp()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>        //parent</span><br><span class="line">                <span class="built_in">wait</span>(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/18/ed32e9cbf7be0bc62402c27fc7d698fe8093e95de24854d0.png" alt="mysh例程测试" title="" class="">
                <p>mysh例程测试</p>
            </figure>




]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysh简单例程 </tag>
            
            <tag> 父子进程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】命令行参数分析]]></title>
      <url>/zhoujiabo.github.io/2020/07/08/%E3%80%90apue%E3%80%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>命令行参数的分析用到的两个函数:<br>    getopt();    //获取短选项，如ls -a<br>    getopt_long(); //获取长选项，如ls –all</p>
<p>ch=getopt(argc,argv,”-y:mdH:MS”);//从命令行中获取选项，如果不是可选项中的字符，则返回-1；</p>
<blockquote>
<p>如果optstring中字符后面跟着’:’，则还可以传入选项参数<br>case ‘H’:<br>     if(strcmp(optarg,”12”) == 0)<br>         strcat(timeformat,”%I(%P) “);<br>     else if(strcmp(optarg,”24”) == 0)<br>         strcat(timeformat,”%H “);<br>     else<br>         fprintf(stderr,”H argument invalid\n”);<br>     break;</p>
</blockquote>
<blockquote>
<p>optstring第一个字符为’-‘，则返回1，进行识别非选项传参（如路径），文件名所对应的argv的下标为argind-1。<br>//非选项参数有多个时的策略：①先入为主，要第一个，后面的不管；②后入为主，要最后一个；③全部都处理。<br>case 1  :<br>     if(fp == stdout)//当非选项参数有多个时先入为主，后面的不管<br>     {<br>         fp = fopen(argv[optind-1],”w”);//无则创建，覆写<br>         if(fp == NULL)<br>         {<br>             perror(“fopen()”);<br>             fp = stdout;<br>          }<br>     }<br>     break;</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">/**********命令行选项，选项参数及非选项参数的获取与解析******************/</span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = stdout;</span><br><span class="line">    time_t stamp;</span><br><span class="line">    struct tm *tm;</span><br><span class="line">    char timestr[BUFSIZE];</span><br><span class="line">    char timeformat[BUFSIZE];</span><br><span class="line">    char ch;</span><br><span class="line">    timeformat[0] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    stamp = time(NULL);</span><br><span class="line">    tm = localtime(&amp;stamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getopt(argc,argv,<span class="string">"-y:mdH:MS"</span>);//从命令行中获取选项，如果不是可选&gt;项中的字符，则返回-1；如果optstring中有<span class="string">":"</span>，则还可以传入选项参数</span><br><span class="line">        <span class="keyword">if</span>(ch &lt; 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        switch(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> 1  ://optstring中有<span class="string">'-'</span>，则识别非选项传参</span><br><span class="line">                <span class="keyword">if</span>(fp == stdout)//先入为主，后面的不管</span><br><span class="line">                &#123;</span><br><span class="line">                    fp = fopen(argv[optind-1],<span class="string">"w"</span>);//无则创建，覆写</span><br><span class="line">                    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">                        fp = stdout;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'y'</span>:</span><br><span class="line">                <span class="keyword">if</span>(strcmp(optarg,<span class="string">"4"</span>) == 0)</span><br><span class="line">                    strcat(timeformat,<span class="string">"%Y "</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(strcmp(optarg,<span class="string">"2"</span>) == 0)</span><br><span class="line">                    strcat(timeformat,<span class="string">"%y "</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fprintf(stderr,<span class="string">"y argument invalid\n"</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">                strcat(timeformat,<span class="string">"%m "</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                strcat(timeformat,<span class="string">"%d "</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'H'</span>:</span><br><span class="line">                <span class="keyword">if</span>(strcmp(optarg,<span class="string">"12"</span>) == 0)</span><br><span class="line">                    strcat(timeformat,<span class="string">"%I(%P) "</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(strcmp(optarg,<span class="string">"24"</span>) == 0)</span><br><span class="line">                    strcat(timeformat,<span class="string">"%H "</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fprintf(stderr,<span class="string">"H argument invalid\n"</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                strcat(timeformat,<span class="string">"%M "</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                strcat(timeformat,<span class="string">"%S "</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strftime(timestr,BUFSIZE,timeformat,tm);</span><br><span class="line">    strcat(timestr,<span class="string">"\n"</span>);</span><br><span class="line">    fputs(timestr,fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp != stdout)</span><br><span class="line">        fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/09/34fe63ae3e68d2d4a33b0628ccfb0ff2ab5478468f00c801.png" alt="命令行解析例程测试" title="" class="">
                <p>命令行解析例程测试</p>
            </figure>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 命令行选项，选项参数及非选项参数的获取与解析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】进程的终止与钩子函数]]></title>
      <url>/zhoujiabo.github.io/2020/07/08/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>进程的终止</strong><br>    正常终止：<br>        从main函数返回<br>        调用exit<br>        调用_exit或_Exit<br>        最后一个线程从其启动例程返回<br>        最后一个线程调用pthread_exit<br>    异常终止：<br>        调用abort<br>        接到一个信号并终止<br>        最后一个线程对其取消请求作出响应</p>
<p>进程的返回值是给其父进程看的。</p>
<p>int atexit(void (*function)(void)); //登记过的函数（像钩子般挂上去）在最后会逆序执行。</p>
<p><strong>atexit();//钩子函数，在进程正常终止（exit）之前会被调用。类似c++中的析构函数，最后关闭文件，释放资源或做其它处理。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">void f1(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">"f1() is working"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void f2(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">"f2() is working"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void f3(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">"f3() is working"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">"beginning."</span>);</span><br><span class="line">    </span><br><span class="line">    atexit(f1);</span><br><span class="line">    atexit(f2);</span><br><span class="line">    atexit(f3);    </span><br><span class="line"></span><br><span class="line">    puts(<span class="string">"end."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/08/b4f355397e6ed9aefe76aad1500257a2352ffc5ab8987eda.png" alt="" title="" class="">
                <p></p>
            </figure>

<p><strong>exit先执行钩子函数和IO清理，再执行_exit或_Eixt退出用户进程空间。</strong></p>
<p>出错了，什么都不敢动，调用_exit(1)，或abort()。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进程的终止 </tag>
            
            <tag> atexit() </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】系统数据文件和信息]]></title>
      <url>/zhoujiabo.github.io/2020/07/08/apue%E3%80%91%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>1、/etc/passwd<br>不能人为地打开这个文件来获取字段，因为标准不一样，在其它版本的系统中不一定存在/etc/passwd。</p>
<p>根据xx获取pwd字段<br>    getpwuid();<br>    getpwname();</p>
<p>2、/etc/group<br>    getgrgid();<br>    getgrnam();</p>
<p>3、/etc/shadow</p>
<p>hash  混淆    不可逆    如原串相同，所得串也相同，防备管理员监守自盗<br>加密  -  解密<br>加密： 安全 ：攻击成本 &gt; 收益<br>安全？ 穷举        口令随机校验（防脚本攻击）</p>
<p>getspnam(); //通过user-name获取该用户的pwd字段。<br>char *crypt(const char *key, const char *salt);<br>//参数为输入的口令和杂串（其包括加密方式，crypt只当识别第三个$前的内容），返回经过加密后得到的串<br>getspnam(); //参数为用户名，返回值为shadow当中的一行<br>getpass();    ////参数为提示符，返回值为输入的口令原文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;shadow.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">/************口令校验例程*************/</span><br><span class="line"></span><br><span class="line">//注意事项：-lcrypt在<span class="string">"末尾"</span>添加才不会报<span class="string">"crypt未定义"</span></span><br><span class="line">//获取shadow文件的内容，需要root权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    char *input_pass;</span><br><span class="line">    char *crypted_pass;</span><br><span class="line">    struct spwd *shadowline;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;   </span><br><span class="line">        fprintf(stderr,<span class="string">"usage ...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    input_pass = getpass(<span class="string">"password:"</span>); //参数为提示符，返回值为输入的口令原文</span><br><span class="line"></span><br><span class="line">    shadowline = getspnam(argv[1]); //根据命令行输入的name，获取shadow中的某一</span><br><span class="line">行</span><br><span class="line">    </span><br><span class="line">    crypted_pass = crypt(input_pass,shadowline-&gt;sp_pwdp);//根据输入的口令和杂串，生成经过加密的串 </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(crypted_pass == NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">        fprintf(stderr,<span class="string">"crypt() error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">if</span>(strcmp(crypted_pass,shadowline-&gt;sp_pwdp) == 0)</span><br><span class="line">        puts(<span class="string">"Right,welcome!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        puts(<span class="string">"Error,input again!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/08/b41083c6350a1a6179b1a8efd737f3f50573fc036d42d4ba.png" alt="chkpass测试" title="" class="">
                <p>chkpass测试</p>
            </figure>


<p>4、时间戳：time_t、char *、struct tm<br>    time();//获取当前的时间戳，<br>    struct tm *localtime(const time_t *timep);//时间表示方式转换，time_t转换成结构体形式<br>    time_t mktime(struct tm *tm); 结构体转换成时间戳，附加可以自动调整时间格式<br>    strftime();//strftime - format date and time</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">/*************每隔1s在文件尾写当前时间******************/</span><br><span class="line"><span class="comment">#define FNAME       "/tmp/out"</span></span><br><span class="line"><span class="comment">#define BUFSIZE     1024</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    time_t stamp;</span><br><span class="line">    struct tm *tm;</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME,<span class="string">"a+"</span>);//无则创建，追加写</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    //获取已有的行数</span><br><span class="line">    <span class="keyword">while</span>( fgets(buf,BUFSIZE,fp) != NULL )</span><br><span class="line">        count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;   </span><br><span class="line">        time(&amp;stamp); //获取时间戳</span><br><span class="line">        tm = localtime(&amp;stamp);//转换成结构体</span><br><span class="line"></span><br><span class="line">        //在文件尾续写时间串</span><br><span class="line">        fprintf(fp,<span class="string">"%4d %d-%d-%d %d:%d:%d\n"</span>,++count,\</span><br><span class="line">        tm-&gt;tm_year+1900,tm-&gt;tm_mon+1,tm-&gt;tm_mday,\</span><br><span class="line">                tm-&gt;tm_hour,tm-&gt;tm_min,tm-&gt;tm_sec);//按一定的格式将时间写入到文件中,tm_year是从1900开始算的，tm_mon取值0-11。</span><br><span class="line"></span><br><span class="line">        fflush(fp);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/08/6bc467ab2e7b09225c2abe8f241e294d3d198a50707418e8.png" alt="timelog测试" title="" class="">
                <p>timelog测试</p>
            </figure>
<blockquote>
<p>补充：测试时可以不ctrl+C终止进程，而新建终端，用tail -f /tmp/out 动态查看文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define STRSIZE 1024</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char timestr[STRSIZE];</span><br><span class="line">    time_t stamp;    </span><br><span class="line">    struct tm *tm;</span><br><span class="line"></span><br><span class="line">    stamp = time(NULL);</span><br><span class="line">    tm = localtime(&amp;stamp);</span><br><span class="line">    strftime(timestr,STRSIZE,<span class="string">"now:%Y-%m-%d"</span>,tm);//从tm结构体中按一定格式提取时</span><br><span class="line">间字符串，放到timestr中</span><br><span class="line">    puts(timestr);</span><br><span class="line"></span><br><span class="line">    tm-&gt;tm_mday += 100;</span><br><span class="line"></span><br><span class="line">    mktime(tm);//借助mktime函数的附加功能，自动调整格式</span><br><span class="line">    strftime(timestr,STRSIZE,<span class="string">"100days later:%Y-%m-%d"</span>,tm);</span><br><span class="line">    puts(timestr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/08/4edcc031d0337b43506c83f0dd2b0d32e6d8a9cfef798390.png" alt="mktime除了转换格式外，还能自动调整" title="" class="">
                <p>mktime除了转换格式外，还能自动调整</p>
            </figure>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 密码校验例程 </tag>
            
            <tag> 时间戳例程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】mydup实现]]></title>
      <url>/zhoujiabo.github.io/2020/07/07/%E3%80%90apue%E3%80%91mydup%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>du 查看一个文件占磁盘空间的大小（单位为k字节数）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;glob.h&gt;</span></span><br><span class="line"></span><br><span class="line">/**********统计某路径下的所有文件所占的磁盘空间（单位为k）****************/</span><br><span class="line"></span><br><span class="line"><span class="comment">#define PATHSIZE 1024</span></span><br><span class="line">static int path_noloop(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    char *pos;</span><br><span class="line">    pos  = strrchr(path,<span class="string">'/'</span>);//定位字符串中最右边的<span class="string">'/'</span>的位置</span><br><span class="line">    <span class="keyword">if</span>(pos == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果是.或..，则不能再进行递归。不然会造成无限循环</span><br><span class="line">    <span class="keyword">if</span>(strcmp(pos+1,<span class="string">"."</span>) == 0 || strcmp(pos+1,<span class="string">".."</span>) == 0)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">static int64_t mydu(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    static struct <span class="built_in">stat</span> statres;</span><br><span class="line">    static char nextpath[PATHSIZE];</span><br><span class="line">    glob_t globres;</span><br><span class="line">    int i;</span><br><span class="line">    int64_t sum;</span><br><span class="line"></span><br><span class="line">    //lstat:遇到符号链接文件，不展开</span><br><span class="line">    <span class="keyword">if</span>(lstat(path,&amp;statres) &lt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">"lstat()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //到文件子叶，进行返回</span><br><span class="line">    <span class="keyword">if</span>(!S_ISDIR(statres.st_mode))</span><br><span class="line">        <span class="built_in">return</span> statres.st_blocks;</span><br><span class="line"></span><br><span class="line">    //如果是目录，目录下的非隐藏文件和隐藏文件都要解析</span><br><span class="line">    strcpy(nextpath,path);</span><br><span class="line">    strcat(nextpath,<span class="string">"/*"</span>);</span><br><span class="line">    glob(nextpath,0,NULL,&amp;globres);</span><br><span class="line"></span><br><span class="line">    strcpy(nextpath,path);</span><br><span class="line">    strcat(nextpath,<span class="string">"/.*"</span>);</span><br><span class="line">    glob(nextpath,GLOB_APPEND,NULL,&amp;globres);</span><br><span class="line"></span><br><span class="line">    //glob_pathv[]中保存了目录所包含的文件路径</span><br><span class="line">    sum = statres.st_blocks;</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; globres.gl_pathc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(path_noloop(globres.gl_pathv[i]))</span><br><span class="line">            sum += mydu(globres.gl_pathv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    globfree(&amp;globres);</span><br><span class="line">    <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">       fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,mydu(argv[1])/2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/08/f21f25009bc921cc00a8c900eb776f32f6ec141afcdf8e92.png" alt="测试结果" title="" class="">
                <p>测试结果</p>
            </figure>

<blockquote>
<p>strrchr函数：<br>char *strrchr(const char *s, int c);    定位字符串中的某个字符<br>strrchr找最右边的某字符所在的位置<br>FUNCTION:<br>    The strrchr() function returns  a  pointer  to  the last occurrence of the character c in the string s.<br>RETURN:<br>    strrchr()  functions  return  a pointer to the matched character  or  NULL  if  the character  is not found. </p>
</blockquote>
<blockquote>
<p>递归优化，有意识地将可以不放在栈中的内容都拿出去。<br>如果一个变量的使用，完全是在递归点之前的或者只在静态点之后出现，则可以将其放到静态区中。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 递归遍历目录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】目录文件]]></title>
      <url>/zhoujiabo.github.io/2020/07/07/%E3%80%90apue%E3%80%91%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>文件系统</p>
<p>类ls的实现，如myls -a -l -i -n</p>
<p>一、目录和文件</p>
<p>1、获取文件属性<br>    stat：通过文件路径获取属性，如果是符号链接文件，会进行展开。<br>    fstat：通过文件描述符获取属性<br>    lstat：面对符号链接文件时获取的是符号链接文件的属性，不展开。</p>
<p>命令行查看文件属性：ls -l path -l 或 stat path</p>
<p>linux环境下，<br>size可能小于，也可能大于block_size * blocks（后者才是文件真正占的磁盘空间，size是文件中的字符个数，包括空字符）<br>cp支持空洞文件的拷贝</p>
<p>七种文件类型：dcb-lsp<br>    d –&gt; 目录    c –&gt; 字符设备文件    b –&gt; 块设备文件<br>    - –&gt; 普通文件    l –&gt;字符链接文件    s –&gt; 网络套接字文件<br>    p –&gt; 命名管道文件</p>
<p>2、文件访问权限<br>    st_mode是16位的位图，用于表示文件类型，文件访问权限，及特殊权限位。</p>
<blockquote>
<p>stat函数原型：int stat(const char *pathname, struct stat *buf);</p>
</blockquote>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/07/af37f63b17f7c570128e0f5c8f2e3256472cf9ec9523130e.md.png" alt="stat结构体" title="" class="">
                <p>stat结构体</p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/07/395db53582c29af870491248db7522e80dc04403b121be05.png" alt="ftype实现" title="" class="">
                <p>ftype实现</p>
            </figure>


<p>3、umask<br>    防止产生权限过松的文件</p>
<p>4、文件权限的更改/管理<br>命令行：chmod a+x file    //给所有用户（u,g,o）添加一个对该文件的执行权限<br>函数： int chmod(const char *pathname, mode_t mode);<br>       int fchmod(int fd, mode_t mode);</p>
<p>5、粘住位<br>    t位，原本是给二进制可执行文件设计的，在内存中保存它的使用痕迹，下次装载时比较快（现在不常用了）。</p>
<p>6、文件系统：FAT、UFS<br>文件或数据的存储和管理<br>FAT：闭源，怕大文件，单链表，查询慢<br>UFS：开源，不怕大文件</p>
<p>7、硬链接，符号链接<br>硬链接：ln file file_link，有两个文件名，指向同一个inode<br>硬链接与目录项是同义词，且建立硬链接有限制：不能给分区建立，不能给目录建立。</p>
<p>符号链接：ln -s file s_link,如同windows下的快捷方式，如果file被删除，则符号链接失效。<br>符号链接优点：可跨分区，可以给目录建立。<br>函数：link,unlink,remove,rename</p>
<p>8、utime：可以更改文件的最后读的时间和最后修改的时间</p>
<p>9、目录的创建和销毁<br>    mkdir<br>    rmdir</p>
<p>10、更改当前工作路径<br>chdir, fchdir 修改工作路径；能够突破假根技术（安全机制）。<br>getcwd获取当前工作路径</p>
<p>11、分析目录/读取目录内容</p>
<p>glob();    //解析通配符</p>
<blockquote>
<p>函数原型：int glob(const char <em>pattern, int flags,<br>                int (</em>errfunc) (const char *epath, int eerrno),<br>                glob_t *pglob);</p>
</blockquote>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/07/e585768c2bc305d64e0f593161d7a78500a967db61f72be6.png" alt="解析当前目录" title="" class="">
                <p>解析当前目录</p>
            </figure>
<blockquote>
<p>如果要包含隐藏文件的话，要用glob函数将”./.*”也解析一遍</p>
</blockquote>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/07/07/9795b77ba4d7bcb886c3b2c48fa39b51905250c05b8e06c6.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>也可以用下列函数实现目录文件解析：<br>opendir();<br>closedir();<br>readdir();<br>rewinddir();<br>seekdir();<br>telldir();</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】文件IO与标准IO的区别]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91%E6%96%87%E4%BB%B6IO%E4%B8%8E%E6%A0%87%E5%87%86IO%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>先看一个程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    putchar(<span class="string">'a'</span>);</span><br><span class="line">    write(1,<span class="string">"b"</span>,1); //第一个‘1’是stdout的fd</span><br><span class="line"></span><br><span class="line">    putchar(<span class="string">'a'</span>);</span><br><span class="line">    write(1,<span class="string">"b"</span>,1);</span><br><span class="line"></span><br><span class="line">    putchar(<span class="string">'a'</span>);</span><br><span class="line">    write(1,<span class="string">"b"</span>,1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出什么？ababab, aaabbb还是bbbaaa<br>请上机验证一下，思考为什么是这个结果。</p>
<p>文件IO与标准IO的区别：<br>区别：响应速度&amp;吞吐量<br>文件IO响应速度快，及时性好；<br>标准IO吞吐量大，效率高，整体速度快。</p>
<p>转换：fileno fdopen<br>提醒：文件IO和标准IO不可混用。<br>标准IO的修改没有直接写到磁盘当中，而是写到了缓冲区（比如，修改word文档后，关闭时还要保存一下，原文件才会发生更改）。FILE*和fd两个结构体不是时刻同步的，所以它们之间往往是不同的，同时使用标准IO和文件IO的话，容易造成混乱。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】IO效率问题]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91IO%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>将mycpy.c中的BUFSIZE进行放大，并观察进程 所消耗的时间，注意性能最佳拐点出现时的BUFSIZE，以及何时程序会出问题。</p>
<p>先看3个命令：<br>1、查找内存大于…的文件 sudo find / -size +100M</p>
<p>2、测试一个命令的运行时间 time ./mycpy 100Mfile /tmp/out<br>三个时间：real、user、sys<br>real = user + sys + 系统调用时间，系统调用时间无法改变，程序员只用关心user和sys时间。</p>
<p>3、mycpy<br>./mycpy 100Mfile /tmp/out BUFSIZE<br>（BUFSIZE为每次进行读写的字节数）</p>
<p>Shell编程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">START_K=128 <span class="comment">#等号两边不能有空格</span></span><br><span class="line"><span class="comment">#LIMIT_K=`expr 16 \* 1024` #算术运算工具expr，数与符号间要有空格</span></span><br><span class="line">LIMIT_K=$[ 16 * 1024 * 1024] <span class="comment">#乘法运算的另一种方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -e ./mycpy ];<span class="keyword">then</span></span><br><span class="line">    make mycpy</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>((i= <span class="variable">$START_K</span>; i&lt;= <span class="variable">$LIMIT_K</span>; i = $[ i * 2 ])); <span class="comment">#128b ~ 16M</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$i</span>"</span> -lt <span class="string">"1024"</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"BUFSIZE = "</span><span class="variable">$i</span><span class="string">"B"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$i</span>"</span> -ge <span class="string">"1024"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$i</span>"</span> -lt <span class="string">"$[ 1024 * 1024]"</span> ]; <span class="keyword">then</span>   </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"BUFSIZE = "</span>$[<span class="variable">$i</span> / 1024]<span class="string">"K"</span> <span class="comment">#字符串拼接：直接放到一起或用双引号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$i</span>"</span> -ge <span class="string">"$[ 1024 * 1024 ]"</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"BUFSIZE = "</span>$[<span class="variable">$i</span> / 1024 / 1024]<span class="string">"M"</span></span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">    time ./mycpy 100Mfile /tmp/out <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>测试：输入./cpy_time.sh，观察结果，找到最佳的效率时的BUFSIZE(什么时候花费的sys时间最短)</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/24/01ac36d37188e09e73f0a7277340afb8910a4b3aa7adcdbc.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>由图可知，拐点在64K。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】文件IO相关函数]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91%E6%96%87%E4%BB%B6IO%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>文件IO（系统调用IO）</p>
<p>文件描述符（fd）是在文件IO中贯穿始终的类型</p>
<p>文件描述符的概念<br>    整型数，数组下标，文件描述符优先使用当前可用范围内最小的</p>
<p>文件IO操作相关函数： open,close,read,write,lseek<br>①man 2 open<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/stat.h&gt;<br>       #include &lt;fcntl.h&gt;<br>int open(const char *pathname, int flags);<br>@param:<br>    flags必须包括O_RDONLY, O_WRONLY, or O_RDWR中的一个.<br>    还可以用位图的方式添加文件创建标志和文件状态标志</p>
<p>@return:<br>    成功返回fd, 失败返回-1</p>
<p>creat():<br>       creat()   is   equivalent   to   open()   with  flags  equal  to O_CREAT|O_WRONLY|O_TRUNC</p>
<p>②man 2 read:</p>
<p>#include &lt;unistd.h&gt;</p>
<p>ssize_t read(int fd, void *buf, size_t count);<br>@param：<br>    count准备读取的字节个数<br>@return:<br>    成功返回读取的字节个数，所有读取完成返回0，失败返回<br>-1</p>
<p>例程：用系统调用io来实现mycpy.</p>
<p>说明：和之前的mycpy有些不同，每次读的字节数BUFSIZE是通过命令行传进来的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int sfd,dfd;</span><br><span class="line">    char *buf = NULL;</span><br><span class="line">    long BUFSIZE,len,ret,pos;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(argc &lt; 4)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage ...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sfd = open(argv[1], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(sfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfd = open(argv[2],O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span>(dfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        close(sfd);</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">   BUFSIZE = atol(argv[3]);</span><br><span class="line">    buf = malloc(sizeof(char)*BUFSIZE);</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">read</span>(sfd,buf,BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span>(len &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = 0;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; 0) //防止漏写</span><br><span class="line">        &#123;</span><br><span class="line">            ret = write(dfd,buf+pos,len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret; //这次又写了ret个字节，pos是已写的字</span><br><span class="line">节数</span><br><span class="line">            len -= ret; //还剩多少个字节没写</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(buf);</span><br><span class="line">    close(dfd);</span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】临时文件]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>临时文件：有一些数据需要临时保存或分析</p>
<p>问题：1、如何不冲突 2、及时销毁<br>    char *tmpnam(char *s);    （申请一个名字）</p>
<p>冲突：<br>    在并发时有两个进程A,B，A用tmpnam申请一个名字后没有及时用fopen进行创建，这时时间片耗尽，B进程运行，它也要为临时文件申请一个名字，申请到的名字和A相同。两个进程申请到了相同的文件名，谁先创建谁倒霉，它们用fopen创建文件时传入的参数肯定不是r，所以，后来的进程会对文件进行覆写或修改。<br>（tmpnam+fopen 没法安全地创建临时文件）</p>
<p>FILE *tmpfile(void);    （创建一个临时文件）<br>tmpfile创建的临时文件，是一个匿名文件（没有名字），文件有创建和打开，但在磁盘上看不见（用ls -a也看不见）。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stdio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】getline]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91getline/</url>
      <content type="html"><![CDATA[<p>从问题出发：上述函数都不能让我们完整地读一行<br>ssize_t getline(char **lineptr, size_t *n, FILE *str<br>eam);</p>
<p>getline会malloc一段空间给lineptr，不够再用relloc扩展空间<br>这里<em>lineptr一定要初始化!!! getline需要根据</em>lineptr判断用malloc还是relloc。</p>
<p>不足：<br>getline最初都是GNU扩展。它们在POSIX.1-2008标准化。<br>getline申请过内存，没有对应的互逆的释放内存的函数，不过这是可控的内存泄漏。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】缓冲区与fflush]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8Efflush/</url>
      <content type="html"><![CDATA[<p>缓冲区的作用：大多数情况下是好事，合并系统调用<br>①行缓冲：换行时刷新，满了的时间刷新，强制刷新（标准输出是这样的，因为是终端设备）<br>②全缓冲：满了的时候刷新，强制刷新（默认，只要不是终端设备）<br>③无缓冲：如stderr，需要立即输出。</p>
<p>int fflush(FILE *stream);<br>强制刷新指定的stream，如果参数为NULL，则刷新所有打开的stream。</p>
<p>（了解）文件的缓冲模式是可以改的，setvbuf函数；一般不会用到。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stdio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】fseek、ftell、rewind]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91fseek%E3%80%81ftell%E3%80%81rewind/</url>
      <content type="html"><![CDATA[<p>int fseek(FILE *stream, long offset, int whence);<br>long ftell(FILE *stream);<br>因为ftell返回不会为负，所以fseek，ftell能操作（定位）的文件最大容量为2G</p>
<p>fseeko能操作4G的文件，但它遵循POSIX（方言），移植性不如fseek（遵循C99）</p>
<p>fseek函数参数：<br>whence有三个设置可选SEEK_SET,SEEK_CUR,SEEK_END<br>offset是在whence基础上的偏移，可正可负</p>
<p>ftell返回当前位置偏移</p>
<p>运用：获取文件大小<br>fseek(pf,0,SEEK_END);<br>printf(“%ld\n”,ftell(pf));</p>
<p>rewind(pf) 相当于 fseek(pf,0L,SEEK_SET); //文件位置指针回到文件开头</p>
<p>空洞文件：刚建立下载任务时创建的文件，一开始的大小就是要下载文件的大小，先用fseek将磁盘占了先，内容全为空字符。然后再建立多线程任务进行下载。</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stdio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】fread、fwrite、fprintf]]></title>
      <url>/zhoujiabo.github.io/2020/06/23/%E3%80%90apue%E3%80%91fread%E3%80%81fwrite%E3%80%81fprintf/</url>
      <content type="html"><![CDATA[<p>一、fread/fwrite</p>
<p>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);<br>从stream中读nmemb个对象，每个对象size大小，读到ptr中<br>返回值：成功读取的对象个数，为0时读取完毕</p>
<p>要点：比较fread(buf,1,10,pf);与fread(buf,10,1,pf);<br>①数量足够多<br>②只有5个字节</p>
<p>fread(buf,1,10,pf)<br>① 返回10    成功读到10个字节<br>② 返回5        成功读到5个字节</p>
<p>fread(buf,10,1,pf)<br>① 返回1        读到10个字节<br>② 返回0        读到多少字节？？？(0~9字节都返回0)    </p>
<p>fread 和 fwrite 都只能对操作工工整整的数据对象，中间不能出错。<br>保险起见，永远采用单字节来操作，即当作fgetc和fputc来用。</p>
<p>用fread和fwrite实现mycpy：<br>    while( (n = fread(buf,1,BUFSIZE,pfs)) &gt; 0 )<br>        fwrite(buf,1,n,pfd);</p>
<p>二、fprintf</p>
<p>int  fprintf(FILE  *stream,  const  char  *format,<br>       …);<br>//把…这些输出项放到format的指定格式中，然后把它们放到指定的stream中去<br>//printf();即是将指定格式的内容输出到stdout中去</p>
<p>sprintf可以将多种不同的数据综合成一个串来处理<br>int snprintf(char *str, size_t  size,  const  char<br>       *format, …);//size是str的大小，用于防范内存溢出</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stdio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】利用fgetc/fgets实现文件复制功能]]></title>
      <url>/zhoujiabo.github.io/2020/06/18/%E3%80%90apue%E3%80%91%E5%88%A9%E7%94%A8fgetc-fgets%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>fgetc函数原型：int fgetc(FILE *stream);<br>要点：为什么fgetc返回的是int而不是char</p>
<blockquote>
<p>通过man fgetc查看其返回值：fgetc(), getc() and getchar() return the character read as an unsigned char cast to an int or EOF  on end of file or error.<br><strong>返回时，unchar型会被转换为int，因为读到文件尾时需要返回的是EOF（-1）, 如果为char型，-1与0XFF相等，会发生冲突</strong>。</p>
</blockquote>
<p>fgets函数原型：char <em>fgets(char *s, int size, FILE *stream);<br>要点1：读取完成时返回NULL<br>*</em>要点2：fgets读取正常结束的几种情况：**</p>
<blockquote>
<p>#define SIZE 5<br>char buf[SIZE];<br>用fgets进行读取，有两种正常结束的情况：<br>读到size-1位置（因为最后要补’\0’），或读到’\n’（’\n’在文件中是默认存在的）<br>①buf中为”abcdef”，则读到的内容为 a b c d ‘\0’<br>②buf中为”ab”，则读到的内容为 a b ‘\n’ ‘\0’<br>特殊情况：buf中为”abcd”，则<strong>需要读两次</strong>：<br>    第一次，读到的内容为 a b c d ‘\0’<br>    第二次，读到的内容为 ‘\n’ ‘\0’ …</p>
</blockquote>
<br>
<big>例程：使用fgetc实现mycpy</big>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *pfs, *pfd;</span><br><span class="line">    int ch = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 3)    //如果传入参数不符合规则</span><br><span class="line">    &#123;   </span><br><span class="line">        fprintf(stderr,<span class="string">"usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n"</span>,argv[0]);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    pfs = fopen(argv[1],<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pfs == NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    pfd = fopen(argv[2],<span class="string">"w"</span>); </span><br><span class="line">    <span class="keyword">if</span>(pfd == NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">        fclose(pfs);    //将前面成功打开的文件关闭，防止内&gt;存泄露</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;   </span><br><span class="line">        ch = fgetc(pfs);</span><br><span class="line">        <span class="keyword">if</span>(ch == EOF)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fputc(ch,pfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(pfd);</span><br><span class="line">    fclose(pfs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用fgets来实现的话，基本只需改while的内容</p>
<blockquote>
<p>while( fgets(buf, BUFSIZE, pfs) != NULL)<br>     fputs(buf, pfd);//buf是字符数组（局部变量）</p>
</blockquote>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/18/fe848e90b1b09bef2b3c902b9b86a36ceccfb78cacd9d556.png" alt="" title="" class="">
                <p></p>
            </figure>

<blockquote>
<p>diff file1 file2    比较两个文件是否相同，相同的话终端什么都没有</p>
</blockquote>
<br>
<big>补充：利用fgetc计算文件中有效字符的个数</big>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    FILE *pf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">        fprintf(stderr,<span class="string">"usage:....\n"</span>);</span><br><span class="line"></span><br><span class="line">    pf = fopen(argv[1],<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fgetc(pf) != EOF)</span><br><span class="line">    &#123;   </span><br><span class="line">        count++;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"count = %d\n"</span>,count);</span><br><span class="line">    </span><br><span class="line">    fclose(pf);</span><br><span class="line">    <span class="built_in">exit</span>(0);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/18/fgetcc02bf0f4796250dc.png" alt="" title="" class="">
                <p></p>
            </figure>
>**用make快速编译一个.c文件，直接“make 文件名”**


]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stdio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】  fopen和fclose]]></title>
      <url>/zhoujiabo.github.io/2020/06/18/%E3%80%90apue%E3%80%91stdio-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>I/O: input&amp;output，是一切实现的基础<br>&emsp;stdio，标准io，移植性好，实质是依赖于sysio实现的<br>&emsp;sysio，系统调用io（文件io）</p>
<p>stdio函数:    FILE类型贯穿始终<br>    fopen    fclose    fgetc    fputc    fgets    fputs    fread    fwrite<br>    printf    scanf    fseek    ftell    rewind    fflush</p>
<p>函数原型：FILE <em>fopen(const char *path, const char *mode);<br>mode:<br>&emsp;r / r+    *</em>文件必须存在，不然会报错**<br>&emsp;w / w+ / a / a+ <strong>文件如果不存在则创建</strong></p>
<p><strong>the ‘b’ is ignored on all PHSIX comforming systems, including linux.<br>linux环境下只有一个流（stream）的概念。windows下有二进制流和文本流的区分。</strong></p>
<p><strong>例程1：fopen.c</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">//perror和strerror功能类似</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">"tmp"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">    //  perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        //errno is a global number</span><br><span class="line">        fprintf(stderr,<span class="string">"fopen():%s\n"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    puts(<span class="string">"OK!"</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①The argument mode points to a string beginning with one of the following sequences.<br><strong>mode参数位置只能识别一个串开头的内容</strong>，如”readwrite”，只能看懂r；如”r+write”，只能看懂r+。</p>
<p>②errno是一个全局变量，需要的话要包含&lt;errno.h&gt;的头文件，并及时打印。errno数字对应的错误信息在/usr/include/asm-generic/errno-base.h中可以查看。当然程序中可以用void perror(const char *s);或char *strerror(int errnum);来打印错误信息。</p>
<p>③调用fopen创建FILE后返回其地址，问题：FILE结构体本身存放在哪<br>&emsp;&emsp;栈（F）    因为调用fopen后，局部变量会被释放<br>&emsp;&emsp;静态区（F）    因为静态变量，定义声明只有一次，只有一块空间，后面会被覆盖。<br>&emsp;&emsp;堆（T）    使用malloc创建新文件</p>
<p><strong>例程2：maxfopen.c</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;    </span><br><span class="line">        fp = fopen(<span class="string">"tmp"</span>,<span class="string">"w"</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fopen()"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"count = %d\n"</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④一个进程能打开的文件数量最大为1024个，但为什么maxfopen程序中打印的是1021，因为<strong>进程已经默认打开了三个流（stdin,stdout,stderr）</strong>。<br>ulimit -a可以查看系统限制。</p>
<p>⑤ls -l tmp 查看fopen创建的文件权限，发现是664，fopen没有开放给用户去指定文件的权限，那<strong>664这个权限是怎么来的？</strong><br>依据的是一个公式 ：** 0666 &amp; ~umask **    (权限中的数为8进制，最大值为’111’)<br>直接命令行输入umask，发现umask为0002</p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stdio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【apue】环境搭建]]></title>
      <url>/zhoujiabo.github.io/2020/06/18/%E3%80%90apue%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>从官网<a href="http://www.apuebook.com/下载src.tar.gz" target="_blank" rel="noopener">http://www.apuebook.com/下载src.tar.gz</a><br>解压后，切换到apue.3e目录；<br>(不用编译，因为下载的代码已经是编译好的了。如果再make，会遇到<em>make: Nothing to be done for ‘all’</em> 的错误。）</p>
<p>复制文件：<br>    ①sudo cp ./include/apue.h /usr/include<br>    ②在/usr/include/apue.h中的#endif前面，即倒数第二行添加#include “error.c”<br>    ③sudo cp lib/error.c /usr/local/include</p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "apue.h"</span></span><br><span class="line"><span class="comment">#include &lt;dirent.h&gt;</span></span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    DIR             *dp;</span><br><span class="line">    struct dirent   *dirp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != 2)</span><br><span class="line">        err_quit(<span class="string">"usage: ls directory_name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dp = opendir(argv[1])) == NULL)</span><br><span class="line">        err_sys(<span class="string">"can't open %s"</span>, argv[1]);</span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dp)) != NULL)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 将上面的代码编译（gcc ls1.c）得到a.out，然后</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/18/lsdab39d5cee3e7bf3.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>注意：命令后面的路径不能忽略</p>
<p><big>到此，unix高级编程环境搭建ok了！</big></p>
]]></content>
      
        <categories>
            
            <category> Linux系统编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unix高级编程环境 </tag>
            
            <tag> apue环境搭建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Matlab】新手入门]]></title>
      <url>/zhoujiabo.github.io/2020/06/02/%E3%80%90Matlab%E3%80%91%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>MATLAB(<strong>matrix laboratory</strong>，矩阵实验室）</p>
<p><big>常数：<big><br>    1.     pi = 3.1415926…<br>    2.     i, j 数据单位    如5i，3 - 4j<br>    3.     e 以10为底的次幂 如1.62e5<br>    4.     inf 无限值    NaN 空值</p>
<p><big><strong>常用命令与快捷：</strong></big></p>
<blockquote>
<p>1.clc 清屏<br>2.clear清空工作区中保存的变量<br>3.help exp 查询exp函数的用法exit 退出Matlab<br>4.注释ctrl+R（注释符为%），取消注释ctrl+T</p>
</blockquote>
<p><strong>构造数组：</strong><br>    1. 直接构造 A = [3 5 2 1];<br>    2. 增量法构造（first:step:last），如 A = 0:10 （step默认为1）或0:0.01:10;<br>    3. 用linspace函数构造 如A = linsapce(0,10,5);   0到10生成5个数，间距为(10-0)/5</p>
<p><strong>构造矩阵：</strong><br>    1. 构造常规矩阵：row = [e1, e2, …, em]; A = [row1, row2, …, rown]; 或A = [2 4 2; 3 6 9; 7 2 1]<br>    1. B = A’ ，行列置换<br>    2. 构造特殊矩阵：<br>        1. zeros/ones 创建一个所有元素均为0/1的元素<br>        2. eye 创建对角元素为1，其它元素为0的元素<br>        3. diag创建对角矩阵，如C=[3 2 1]; V=diag(C); 其中C为对角值<br>        4. 聚合矩阵：①水平聚合C = [A B]；②垂直聚合C = [A;B];  </p>
<p>获取矩阵元素和相关信息：<br>    1. 取单个元素：A(3,1)<br>    2. 取多个元素：第一行A(1,:)  第二列A(:,2)<br>    3. 获取所有元素：A(:)<br>    4. length最长维的长度<br>    5. numel返回元素个数<br>    6. size 返回每一维的长度</p>
<p>log函数用法<br>    1. log(32) = 3.4657         默认以e为底<br>    2. log2(32) = 5，log10(100) = 2    只有2，10为底能这样写<br>    3. log(7)/log(3)     换底公式，得3为底7的对数</p>
<p>其它常用函数，如sqrt开方，mod取余，abs绝对值，round取整 </p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/02/9d923b8a72285e841befaa6066e07910b846dad4f2e30ffd.png" alt="" title="" class="">
                <p></p>
            </figure>


<p><big>语法：</big><br>  ①点乘：<br>  例如A = [1 2; 1 3]; B = [2 1; 1 4];<br>      A<em>B = [4 9; 5 13]（数学上的矩阵运算）<br>      A.</em>B = [2 2; 1 12]（对应相乘） </p>
<p>  ②输入和打印：<br>  x = input(‘enter x:’);<br>  fprintf(‘x = %d’,x); </p>
<p>  ③判断语句：<br>  if x&gt;0……<br>  elseif……<br>  else……<br>  end   </p>
<p><big>构造函数：</big></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> result =  mysum( a, b)</span><br><span class="line">	s = 0;</span><br><span class="line">	<span class="keyword">for</span> i = a : b</span><br><span class="line">		s = s + i;</span><br><span class="line">	end</span><br><span class="line">	result = s;</span><br><span class="line">	disp(s);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可以在命令行输入 s = mysum( 4, 10)，输出 s = 49.<br>也可以直接在其它函数（其它脚本中）引用。</p>
<p><big>画图：</big></p>
<p>画直线:<br>x = [0, 1]<br>y = [0, 0];<br>plot(x, y);</p>
<p>画抛物线:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = -5:0.1:5; %用0.1的间隔得到更多点</span><br><span class="line">y = x.*x; %表达式</span><br><span class="line">plot(x,y,<span class="string">"green"</span>); %画图，线是绿色</span><br><span class="line">%如果plot(x,y,<span class="string">"green-o"</span>); 则把图中的每个点圈起来</span><br><span class="line">axis equal命令，横纵坐标的单位长度一样，当前有效。</span><br></pre></td></tr></table></figure>

<p>画直方图:<br>month = 1 : 12<br>profit = [ some number]<br>bar(x,y);</p>
<p>画三维图像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">theta = 0 : pi/50 : 6pi;</span><br><span class="line">x = cos(theta);</span><br><span class="line">y = sin(theta);</span><br><span class="line">%上面x,y都得到301个点，z的点的个数要和x,y一样</span><br><span class="line">z = 0:0.1:30;</span><br><span class="line">plot3(x,y,z);</span><br></pre></td></tr></table></figure>
<br>
<big>图像设置：</big>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/02/c287885ea37b950b04f0300d24118766872c290dc36cdcf7.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>画板分割：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subplot(2,2,1); %画板被划分成2行2列，也就是4个部分，当前画第一个部分</span><br><span class="line">plot(x,y1);</span><br><span class="line">subplot(2,2,2); %画第二个部分，也就是右上角位置</span><br><span class="line">plot(x,y2);</span><br><span class="line">subplot(2,2,[3,4]); %最后一张图占了3，4两个部分</span><br><span class="line">plot(x,y4);</span><br></pre></td></tr></table></figure>

<p>画曲面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = -4 : 0.1 : 4;</span><br><span class="line">y = -4 : 0.1 : 4;</span><br><span class="line"> </span><br><span class="line">[X, Y] = meshgrid(x,y);	%网格采样，取点x*y平面的点</span><br><span class="line">Z = X.^2 + Y.^2;    %表达式</span><br><span class="line">surf(X,Y,Z);	%画曲面</span><br></pre></td></tr></table></figure>

<p>平移动画：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = -2*pi : 0.1 : 2*pi;</span><br><span class="line">y = sin(x);</span><br><span class="line">h = plot(x,y);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    x = x + 0.1; %平移</span><br><span class="line">    y = sin(x);</span><br><span class="line">    <span class="built_in">set</span>(h,<span class="string">'XData'</span>,x,<span class="string">'YData'</span>,y); %更新h中的x和y;</span><br><span class="line">    drawnow;  %画图</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>伸缩动画：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">theta = -10*pi : 0.1 : 10*pi;</span><br><span class="line">X = cos(theta);</span><br><span class="line">Y = sin(theta);</span><br><span class="line">Z = theta;</span><br><span class="line"> </span><br><span class="line">h = plot3(X, Y, Z);</span><br><span class="line">axis([-2,2,-2,2,-35,35]); %固定坐标轴，参数为x,y,z的范围</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i = 1 : 100</span><br><span class="line">        Z = 0.98 * Z; %缩小</span><br><span class="line">        <span class="built_in">set</span>(h,<span class="string">'XData'</span>,X,<span class="string">'YData'</span>,Y,<span class="string">'ZData'</span>,Z);</span><br><span class="line">        drawnow;</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">for</span> i = 1 : 100</span><br><span class="line">        Z = Z / 0.98;</span><br><span class="line">        <span class="built_in">set</span>(h,<span class="string">'XData'</span>,X,<span class="string">'YData'</span>,Y,<span class="string">'ZData'</span>,Z);</span><br><span class="line">        drawnow;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>旋转动画：时钟<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">t = 0 : pi/50 : 2*pi;</span><br><span class="line">x = cos(t);</span><br><span class="line">y = sin(t);</span><br><span class="line"> </span><br><span class="line">plot(x,y);</span><br><span class="line">axis equal;</span><br><span class="line">hold on;</span><br><span class="line"> </span><br><span class="line">LineX = [0, 1];</span><br><span class="line">LineY = [0, 0];</span><br><span class="line">h = plot(LineX,LineY);</span><br><span class="line">theta = 0;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    theta = theta - 0.05;</span><br><span class="line">    LineX(2) = cos(theta);</span><br><span class="line">    LineY(2) = sin(theta);</span><br><span class="line">    <span class="built_in">set</span>(h,<span class="string">'XData'</span>,LineX,<span class="string">'YData'</span>,LineY);</span><br><span class="line">    drawnow;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p><big><em>信号与系统中常用的命令与函数：</em></big></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/02/9d923b8a72285e841befaa6066e07910b846dad4f2e30ffd.md.png" alt="" title="" class="">
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/02/20200602174357257e87ecb2b5924b.md.png" alt="" title="" class="">
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/06/02/20200602174414e2c8f23633e0e502.md.png" alt="" title="" class="">
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 数学分析类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[蓝牙Mesh组网]]></title>
      <url>/zhoujiabo.github.io/2020/05/28/%E8%93%9D%E7%89%99Mesh%E7%BB%84%E7%BD%91/</url>
      <content type="html"><![CDATA[<p><strong>安卓测试APP、组网参考文档与模块程序</strong>：<a href="https://github.com/cral-freedom/JDY-10_Mesh" target="_blank" rel="noopener">https://github.com/cral-freedom/JDY-10_Mesh</a><br>（点亮STAR可收藏）</p>
<p>一、介绍：<br>    JDY-10透传模块，基于蓝牙4.0协议标准，工作频段为2.4GHZ范围。最大发射距离50m，具有功耗低、信号强、数据传输稳定等特性。</p>
<p>产品特征：<br>    1. 支持手机数据透传<br>    2. 支持一对多、多对一、多对多数据传输与控制<br>    3. 支持组网GPIO控制，支持组网4路PWM控制<br>    4. 最大广播与单播Mesh发送数据<br>    5. 支持BLE主从同时工作，无需主从切换<br>    6. 至少60%以上的智能家居应用JDY-10M可以胜任</p>
<p>通信接口：UART     波特率：115200（默认）</p>
<p><strong>二、测试APP安装</strong><br>    GitHub中的APP源码压缩包直接发到手机，手机不用解压，直接找到点击后辍名为.apk的文件，即可自动安装。</p>
<p><strong>三、配置</strong>：<br>    先用USB转TTL模块直接与JDY连接，用串口助手发送AT指令配置JDY。</p>
<p>1：配置组网 ID 号： AT+NETID112233445566<br>2：配置模块广播名： AT+NAME123，注意组网设备所有的模块必须广播名一致（一样）</p>
<p>3：配置短地址：AT+MADRR22，（短地址为 MAC 地址的最后一位）必须保证网络内的所有模块的短地址不能一样。</p>
<p>通过以上配置后，发送 AT+RESET 复位，模块重启后，所有模块就自动组网。</p>
<p>四、部分代码</p>
<p>mesh.h文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef __MESH_H</span></span><br><span class="line"><span class="comment">#define __MESH_H</span></span><br><span class="line"><span class="comment">#include "sys.h"</span></span><br><span class="line"></span><br><span class="line">/***************** 蓝牙Mesh 缺省设置 *******************/</span><br><span class="line">/*</span><br><span class="line">波特率： 115200    广播名：WAVE        ID：112233445566</span><br><span class="line">发送数据格式：AAFB + FFFF/(00+MADDR) + DATA（最多可以为10字节）</span><br><span class="line">数据接收格式：AA + MADDR + len + data</span><br><span class="line"></span><br><span class="line">手机app中mesh发送串口数据：（特别说明）</span><br><span class="line">①手机不用发FA等验证帧，直接发送数据，但实际要注意：</span><br><span class="line">  发10,实际发送的用户数据是31 30。（而1F对应的是31,46）</span><br><span class="line">②手机连接任意一个WAVE，均能实现控制</span><br><span class="line">③手机只能广播播放，//只能接收与手机连接的JDY的发送信息</span><br><span class="line"></span><br><span class="line">为了兼容手机与蓝牙控制，作出如下约定：</span><br><span class="line">①用户发送的数据长度默认为3，0x31(控制对象) + 0x31/0x32/...（控制指令）+ 0x30（帧尾）</span><br><span class="line">②如对应同一个行为（如控制JDY1的控制LED0反转），蓝牙发送AA FB 00 22 31 31 30, 手机则发送110</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#define User_Data_Len 0x03    </span></span><br><span class="line"><span class="comment">#define  JDY_ID 0x31        //JDY的短地址为21，ID设置为31</span></span><br><span class="line">extern u8 Mesh_Rec_Finish, Mesh_Rec_From, Mesh_Control_Obj, Mesh_Rec_Cmd;</span><br><span class="line"></span><br><span class="line">//void mesh_gpio_config(void);//PWRC与STAT引脚初始化，但用不到</span><br><span class="line">void mesh_uart2_init(u32 bound);</span><br><span class="line">void Mesh_Send_Data(u8 MADDR, u8 Obj, u8 Cmd);</span><br><span class="line"><span class="comment">#define Mesh_Single_Cast(addr,obj,cmd) Mesh_Send_Data(addr,obj,cmd)</span></span><br><span class="line"><span class="comment">#define Mesh_Board_Cast(obj,cmd) Mesh_Send_Data(0x00,obj,cmd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>mesh.c文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">void Mesh_Send_Data(u8 MADDR, u8 Obj, u8 Cmd)</span><br><span class="line">&#123;</span><br><span class="line">	u8 i, BUFF[7]=&#123;0xAA,0xFB,0xFF,0xFF,0x00,0x00, 0x30&#125;;</span><br><span class="line">	</span><br><span class="line">	//因为手机只能广播，所以为了明确控制对象，额外加了个控制对象的数据</span><br><span class="line">	</span><br><span class="line">	//发送方式设置，ffff为广播，00xx为单播，xx为目标短地址</span><br><span class="line">	<span class="keyword">if</span>(MADDR == 0x00)</span><br><span class="line">	&#123;</span><br><span class="line">		BUFF[2] = 0XFF;	BUFF[3] = 0XFF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		BUFF[2] = 0X00;	BUFF[3] = MADDR;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//控制对象</span><br><span class="line">	BUFF[4] = Obj;	</span><br><span class="line">	//发送控制的指令</span><br><span class="line">	BUFF[5] = Cmd;	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;7;i++)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="keyword">while</span>(!(USART2-&gt;SR &amp; USART_SR_TXE));</span><br><span class="line">		USART2-&gt;DR=BUFF[i]; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//接收来自蓝牙的数据包：如AA 21 02 31 31 3F</span><br><span class="line"></span><br><span class="line">/****************解析*******************</span><br><span class="line">*AA：表示数据包类型，看作帧头即可</span><br><span class="line">*21：发送者（模块）的短地址</span><br><span class="line">*02：用户数据长度</span><br><span class="line">*31：控制对象为JDY1</span><br><span class="line">*31：控制指令</span><br><span class="line">*30：作为帧尾(为了兼容手机发过来的数据，不能用3A~3F)</span><br><span class="line">***************************************/</span><br><span class="line">void USART2_IRQHandler(void)                	</span><br><span class="line">&#123;</span><br><span class="line">	static u8 state=0;</span><br><span class="line">	u8 i,data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		//USART_ClearFlag(USART2,USART_FLAG_RXNE);</span><br><span class="line">		USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">		data=USART_ReceiveData(USART2);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(state==0 &amp;&amp; data==0xAA)</span><br><span class="line">		&#123;</span><br><span class="line">			state = 1;</span><br><span class="line">			Mesh_Rec[0] = data;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == 1)//接收发送者的短地址</span><br><span class="line">		&#123;</span><br><span class="line">			Mesh_Rec[1] = data;</span><br><span class="line">			state = 2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state==2 &amp;&amp; data==User_Data_Len)//用户数据长度是否正确</span><br><span class="line">		&#123;</span><br><span class="line">			Mesh_Rec[2] = data;</span><br><span class="line">			state = 3;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == 3)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(data == JDY_ID)//控制对象是否正确，是不是给我的？</span><br><span class="line">			&#123;</span><br><span class="line">				Mesh_Rec[3] = data;</span><br><span class="line">				state = 4;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				state = 0;</span><br><span class="line">				<span class="keyword">for</span>(i=0; i&lt;5; i++)</span><br><span class="line">					Mesh_Rec[i] = 0x00;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == 4)//接收控制命令</span><br><span class="line">		&#123;</span><br><span class="line">			Mesh_Rec[4] = data;</span><br><span class="line">			state = 5;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state == 5)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(data == 0x30)//验证帧尾</span><br><span class="line">			&#123;									</span><br><span class="line">				Mesh_Rec[5] = data;</span><br><span class="line">				</span><br><span class="line">				//AA 21 02 31 31 3F</span><br><span class="line">				Mesh_Rec_Finish = 1;</span><br><span class="line">				Mesh_Rec_From = Mesh_Rec[1];</span><br><span class="line">				Mesh_Control_Obj = Mesh_Rec[3];</span><br><span class="line">				Mesh_Rec_Cmd = Mesh_Rec[4];</span><br><span class="line">				</span><br><span class="line">				state = 0;</span><br><span class="line">				<span class="keyword">for</span>(i=0; i&lt;5; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					Mesh_Rec[i] = 0x00;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;	</span><br><span class="line">				state = 0;</span><br><span class="line">				<span class="keyword">for</span>(i=0; i&lt;5; i++)</span><br><span class="line">					Mesh_Rec[i] = 0x00;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;		 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JDY-10 </tag>
            
            <tag> 蓝牙Mesh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【AD】PCB设计技巧]]></title>
      <url>/zhoujiabo.github.io/2020/05/24/%E3%80%90AD%E3%80%91PCB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>1、<strong>快速设置板框：</strong><br>&emsp;切换到Keep out层，再SHIFT + S 先过滤出Keep out层的板框线，选中所有板框线，然后到 设计 - 板框形状 - 按照选择对象定义。</p>
<p>2、<strong>电源线另外加粗:</strong><br>&emsp;新建一个类，将需要加粗的电源线到添加PWR类；然后新建线宽规则，为PWR类额外设置线宽。</p>
<p>3、<strong>设计规则的导出与导入:</strong><br>&emsp;将常用的PCB设计规则导出，后面就不用再逐一去设置规则了。具体操作见：<a href="https://jingyan.baidu.com/article/8cdccae9bc9a65315413cde2.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/8cdccae9bc9a65315413cde2.html</a></p>
<p>4、<strong>快速设置DRC规则:</strong><br>&emsp;我暂时用的基本都是两层板，要求也不高，DRC主要是要进行电气检测。操作：<br>    先到“Rules To Check”中清除所有规则（右键，在线/批量DRC 都选中“所有关闭”）;<br>然后到“Electrical”中将所有电气检测打开（右键，选中“所有打开”）。</p>
<p>5、<strong>导出材料清单的表格文件:</strong><br>    PCB文件下，“报告——bill of materials”，出现新的窗口，在左下角找到“输出”，再选择.xlsx文件的保存路径即可。</p>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 画板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【CubeMX】时钟树配置介绍]]></title>
      <url>/zhoujiabo.github.io/2020/05/18/%E3%80%90CubeMX%E3%80%91%E6%97%B6%E9%92%9F%E6%A0%91%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/b682defdfd020c9ae723deba04a3018511de0f642e021739.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>①、 LSI 是低速内部时钟， RC 振荡器，频率为 32kHz 左右。供独立看门狗和自动唤醒单元使用。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/e5421c8e0e6c04a808ead53c361898c56627d4b91a714368.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>②、 LSE 是低速外部时钟，接频率为 32.768kHz 的石英晶体。 这个主要是 RTC 的时钟源。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/c52eab012542dad5cc4641556ecadf5d9ae7db88af848405.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>③、HSE 是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz~26MHz。我们的开发板接的是 8M 的晶振。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/10e0acd5935b881282780ff56e9adb424a72cb3620b435b3.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>
**PPL为锁相环倍频输出**。STM32F4有两个PLL：
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/950783e5db07fa82de9cc9c8eda8d215f553cd2b49728fad.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>1）主PLL（Main PLL），由HES或HSI提供时钟信号，并具有两个不同的输出时钟。<br>    第一个输出PLLP，用于生成调整的系统时钟（最高168MHZ）<br>    第二个输出PPLQ，用于生成USB OTG FS的时钟（48MHz），随机器发生器的时钟和SDIO时钟</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/fa9084b3213e29d302d642d15808b3da4c7540d425496cd1.png" alt="" title="" class="">
                <p></p>
            </figure>    
<p>2）专用PLL（PLLI2S），用于生成精确时钟，从而在I2S接口实现高品质音频性能。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/46eedc2e0c17df4640848f31eec8f25b75f6f9bee93951d7.png" alt="" title="" class="">
                <p></p>
            </figure>

<p><strong>STM32F4 输出时钟 MCO1 和 MCO2</strong>。<br>    MCO1 是向芯片的 PA8 引脚输出时钟。它有四个时钟来源分别为： HSI,LSE,HSE 和 PLL 时钟。<br>    MCO2 是向芯片的 PC9 输出时钟，它同样有四个时钟来源分别为： HSE,PLL， SYSCLK 以及 PLLI2S时钟。<br>    MCO 输出时钟频率最大不超过 100MHz。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/2020051818323903b2f7c51bf6bcc7.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>F4内部以太网MAC时钟的来源。<br>对于MII接口来说，必须向外部PHY芯片提供25MHZ的时钟，这个时钟，可以由PHY芯片外接晶振，或者使用芯片的MCO输出来提供。然后，PHY芯片再给F4提供ETH_MII_TX_CLK和ETH_MII_RX_CLK时钟。<br><strong>对于RMII接口来说，外部必须提供50MHZ的时钟驱动PHY和F4的ETH_RMII_REF_CLK</strong>，这个50MHZ时钟可以来自PHY、有源晶振或者F4的MCO。</p>
<p><img src="https://file.moetu.org/images/2020/05/18/1bc56a4a82f8acc6d7cc837139cc84818d50e999135bc67a.png" alt=""><br>HCLK：AHB总线时钟，由系统时钟SYSCLK分频得到，一般不分频，等于系统时钟；或HCLK是高设外设时钟，是给外部设备的，如内存，Flash。<br>FCLK：处理器的自由运行时钟（free running clock），在处理器休眠时，通过FCLK保证可以采样到中断和跟踪休眠事件。</p>
<p>APB1：低速外设，连接在APB1上的设备有，CAN USB I2C1 I2C2 UART2 UART3 SPI2 窗口看门狗 TIM2 TIM3 TIM4；<br>APB2：高速外设，连接在APB2的设备有 UART1 SPI1 TIM1 ADC1 所有普通IO。<br>APB1时钟频率通常为APB2的一半。</p>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 时钟树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CubeMX+F407+LAN8720配置LWIP（测试成功）]]></title>
      <url>/zhoujiabo.github.io/2020/05/18/CubeMX-F407-LAN8720-FreeRTOS%E9%85%8D%E7%BD%AELWIP/</url>
      <content type="html"><![CDATA[<p>CubeMX配置参考：<br><a href="https://blog.csdn.net/sadfdsfff/article/details/89741923" target="_blank" rel="noopener">https://blog.csdn.net/sadfdsfff/article/details/89741923</a></p>
<p>我用的是STM32F407ZG和LAN8720模块。<br>LAN8720模块介绍：<br>①没有引出复位引脚</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/d43d0167d1e533d82126b78edf613c2c01b4b0fff273e186.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>②自带50MHZ的有源晶振<br>③LAN8720模块的PHYAD0引脚接上拉电阻</p>
<p><strong>需先使能ETH，才能配置第三方组件LWIP。选择RMII接口方式时，PHY芯片的时钟信号必须是50MHZ</strong>，可以是有源晶振，或F4的CMO1（PA8引脚复用）时钟输出。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/964c4a61a66c1449a1938738bd0d6e3578237c43e704b326.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>当硬复位结束后，LAN8720A 会读取PHYAD0引脚电平，作为器件的 SMI 地址，接下拉电阻时（浮空也可以，因为芯片内部自带了下拉电阻），设置 SMI 地址为 0，当外接上拉电阻后，可以设置为 1。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/4135d9414079d847bebca2ca56db7f5e15c042477e26558d.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>PHYAD0引脚接的是上拉电阻，所以<strong>PHY_Address设置为1</strong>。<br>ETH的NVIC中断要使能；LWIP使用静态方法分配IP。</p>
<p><strong>因为杜邦线连接的，所以最好将速率改为10Mbits/s</strong>。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/4b22936a73dd86dddede721efee0e1986cf2cc8cf3eab89f.png" alt="" title="" class="">
                <p></p>
            </figure>

<p><strong>超时时间设置也修改一下</strong></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/c5e1d2ef3ad9825896c5aa8b453dbe9b3d117f39077d35b3.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>驱动配置好后，写TCP回显测试函数：<br><a href="https://blog.csdn.net/sadfdsfff/article/details/89787123" target="_blank" rel="noopener">https://blog.csdn.net/sadfdsfff/article/details/89787123</a></p>
<p>arp -a 查看连接网口，的板子mac ,IP.</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/af508081fbd48a179bdbb656d875ca3e421749bc0fad5bc6.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>ping开发板IP地址：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/96998ceaf5815f14067e20fd1f0d8926c3a068e8fcb1ea56.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>终于测试成功！！！</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/22255fedffd8c83ad1ab605d1213e695078944c663975eba.png" alt="" title="" class="">
                <p></p>
            </figure>]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LWIP </tag>
            
            <tag>   </tag>
            
            <tag> LAN8720 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32CubeMX新手入门]]></title>
      <url>/zhoujiabo.github.io/2020/05/18/STM32CubeMX%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>一、安装<br><a href="https://jingyan.baidu.com/article/00a07f38027ef982d028dce2.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/00a07f38027ef982d028dce2.html</a></p>
<p>二、STM32CubeMX特点</p>
<p>优势：<br>&emsp;a. 所选外设和中间件的MCU引脚，时钟树和操作模式配置简单快捷<br>&emsp;b. 为电路板设计人员生成引脚配置报告；<br>&emsp;c. 通过将以前保存的配置导入到新的MCU项目，轻松切换到另一个微控制器；<br>&emsp;d.  由于STM32CubeMX内置STM32微控制器，外设和中间件（LwIP和USB通信协议栈，用于小型嵌入式系统的FatFs文件系统， FreeRTOS）的知识，优化的迁移时间得以实现；<br>&emsp;e.  在配置过程中， STM32CubeMX会检测到冲突和无效设置，并通过有意义的图标和有用的工具提示来突出显示它们<br>&emsp;f. 功耗计算。 从选择微控制器部件号和电池类型开始，用户可以定义一系列代表应用程序生命周期和参数（频率选择，启用的外设，步长）的步骤。 STM32CubeMX功耗计算器返回相应的功耗和电池寿命估计。</p>
<p>特点：<br>&emsp;a. 用户可以通过在用户专用部分添加用户定义的C代码来修改生成的源文件。STM32CubeMX确保用户C代码在下一代C代码生成时保留。<br>&emsp;b. 时钟树配置<br>&emsp;c. 注意：升级到新版本的STM32CubeMX时，请务必在加载新项目之前始终备份项目（特别是当项目包含用户代码时）</p>
<p>（配置驱动十分方便，但多一层抽象后，工程也变得十分庞大，可能是原来标准库工程的3-4倍，，，MDK编译都要几分钟，，）</p>
<p>三、几个常用文件介绍</p>
<p>1、startup_stm32f407xx.s</p>
<p>可调变量—-Stack_Size、Heap_Size<br>工作：<br>&emsp;1、 初始化堆栈指针 SP=_initial_sp<br>&emsp;2、 初始化 PC 指针=Reset_Handler<br>&emsp;3、 初始化中断向量表（设置ISR的入口地址）<br>&emsp;4、 调用SystemInit（配置系统时钟）<br>&emsp;5、 跳转到C库中的__main，即调用main函数（其实，可自定义C语言入口函数，如用user_main代替main，这样系统初始化后就会进入user_main而不是main）<br>（④⑤都是在Reset_Handler中完成的，Reset_Handler是系统上电后第一个运行的程序/函数）</p>
<p>复位之后，CM4处理器处于线程模式，优先级为Privileged，堆栈设置为main。</p>
<p>2、stm32f4xx_hal_msp.c<br>提供MSP初始化函数 HAL_MspInit()</p>
<p>3、 system_stm32f4xx.c</p>
<p>这个文件提供了两个函数SystemInit、SystemCoreClockUpdate，和一个全局变量SystemCoreClock。</p>
<p>SystemInit()：这个函数在复位之后，进入main程序之前被调用（位置：启动文件的Reset_Handler内）。<br>&emsp;-SystemCoreClock：包含内核时钟（HCLK），它可以被用来设置SysTick定时器。<br>&emsp;-SystemCoreClockUpdate()：如果程序运行期间要更改SystemCoreClock，则需要调用这个函数。                        </p>
<p>4、main.c</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HAL_Init()    ：在stm32f4xx_hal. c定义：</span><br><span class="line">①Configure Flash prefetch, Instruction cache, Data cache</span><br><span class="line">②Set NVIC Group Priority to 4</span><br><span class="line">③Configures the SysTick to generate an interrupt each 1 millisecond</span><br><span class="line">④Calls the HAL_MspInit() to <span class="keyword">do</span> the global low level hardware initialization</span><br><span class="line"></span><br><span class="line">SystemClock_Config()：系统时钟配置</span><br><span class="line"></span><br><span class="line">Initialize all configured peripherals：如</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_USART1_UART_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(1)：无限循环</span><br></pre></td></tr></table></figure>

<p>5、HAL驱动文件</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/18/ec49f1328aabfae5042f9b5e8a7de720e1b7d5ee6dc9e6fb.md.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>四、<strong>创建工程心得</strong><br>1、CubeMX生成F103代码时没有启动文件<br>    暂时没有好的方法，只能手动添加。</p>
<p>2、解决printf重定向（串口输出）   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"  </span></span><br><span class="line">int fputc(int ch, FILE *f)    //重定向<span class="built_in">printf</span>函数</span><br><span class="line">&#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xffff);</span><br><span class="line">    <span class="built_in">return</span> (ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//重定向scanf函数到串口 意思就是说接受串口发过来的数据</span><br><span class="line">　　int fgetc(FILE * F)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　HAL_UART_Receive (&amp;huart1,&amp;ch_r,1,0xffff);//接收</span><br><span class="line">　　　　<span class="built_in">return</span> ch_r;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>3、FreeRTOS配置<br>&emsp;时基时钟源不能选择SysTtick<br>&emsp;USE_PREEMPTION Enable（使用抢占）<br>&emsp;RECORD_STACK_HIGH_ADDRESS Enable（使用TCB作为任务堆栈）</p>
<blockquote>
<p>main.c中关于FreeRTOS的配置：<br>①MX_FREERTOS_Init()中创建了用户定义的任务/线程<br>osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);<br>defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);<br>②osKernelStart()实质是vTaskStartScheduler()，空闲任务已在vTaskStartScheduler中自动创建；<br>③用户创建的任务函数在额外生成的freertos.c中。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【编写RTOS】简单任务调度]]></title>
      <url>/zhoujiabo.github.io/2020/05/08/%E3%80%90%E7%BC%96%E5%86%99RTOS%E3%80%91%E7%AE%80%E5%8D%95%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>回顾</p>
<blockquote>
<p>Q3：关于RTOS编写，要解决哪些核心问题<br>A3：<br> a. 系统心跳：SysTick初始化<br> b. SysTick和PendSV的优先级设置<br> c. 任务控制块TCB结构与堆栈初始化<br> d. 上下文切换：PendSV_Handler函数<br> e. 系统延时函数（阻塞，调度）<br> f. 任务调度：SysTick_Handler函数</p>
</blockquote>
<p>理清问题关键所在后，开始动手。</p>
<blockquote>
<p>我是边动手边折腾，慢慢才理楚问题关键；<br>    &emsp;首先，<strong>最基本的功能要先保证</strong>，如SysTick初始化，任务堆栈初始化，上下文切换；<br>    &emsp;然后，开始时<strong>步子不能迈太大</strong>，我就差点裂开了。开始时只想着时间片轮转调度，选择了循环队列来管理列表，结果发现延时列表不能适用，它需要将延时短的任务先取出；然后又傻傻地想，用min_heap来实现优先级队列，它好像很适合动态管理数据，结果因为要判断”叶“的位置，需要额外的空间，多次malloc后失败，因为Heap_Size只有0x00000200 = 512字节（搞来搞去，结构体指针数组初始化，非法访问，数据被破坏，，，）。最后直接用一个结构体指针数组+任务状态来管理了。先搞出来，然后才能谈其它数据结构，优化调度算法</p>
</blockquote>
<br>
<big>1、SysTick</big>

<p>①SysTick的作用：<br>    &emsp;通过SysTick异常周期性地切入系统，进行任务调度。 （SysTick 的最大使命，就是定期地产生异常请求，作为系统的时基。 OS 都需要这种“滴答” 来推动任务和时间的管理。—— CM3权威指南）</p>
<p>②关于SysTick，我们需要知道什么?<br>    &emsp;所有CM3芯片内部都包含了SysTick定时器（简化了在CM3器件间的软件移植工作），该定时器的时钟源可以是内部时钟，或者是外部时钟。<br>    &emsp;SysTick定时器是一个24位的倒计数定时器，当计数到0时，将从RELOAD寄存器中自动重载定时器初值，开始新的一轮计数。STM32的延时一般就是通过内部的SysTick来实现的。<br>     &emsp;STM32基础例程中有关SysTick定时器的初始化设置，可以在delay.c文件（源自正点原子FreeRTOS例程）中查看。delay_init()中也有关于SysTick时钟源的说明：SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK); 由此可知，SysTick的时钟源是HCLK。   </p>
<blockquote>
<p>HCLK ：AHB总线时钟，由系统时钟SYSCLK分频得到，一般不分频，等于系统时钟（72MHZ），HCLK是高速外设时钟，是给外部设备的，比如内存，flash，DMA。</p>
</blockquote>
<p>SysTick控制及状态寄存器：<br> <figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/08/5adc689039222e50b48511a48a43a3f1e380b32518925fd1.md.png" alt="" title="" class="">
                <p></p>
            </figure>   </p>
<p>初始化代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void SysTick_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *Systick_priority = (char *)0xe000ed23;	//Systick中断优先级寄存器</span><br><span class="line">	*Systick_priority = 0x00;           			//设置SysTick中断优先级最高</span><br><span class="line">	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);//选择外部时钟  HCLK</span><br><span class="line">	SysTick-&gt;LOAD  = ( SystemCoreClock / configTICK_RATE_HZ) - 1UL;	//定时周期1ms</span><br><span class="line">	SysTick-&gt;VAL   = 0;                            	//Systick定时器计数器清0</span><br><span class="line">	//SysTick-&gt;CTRL: bit0-定时器使能 bit1-中断使能 bit2-时钟源选择(=1系统主频，=0系统主频/8)</span><br><span class="line">	SysTick-&gt;CTRL = 0x7;	//选择外部时钟，允许中断，开启定时器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>敲重点：<br>①SysTick-&gt;CTRL: bit0-定时器使能 bit1-中断使能 bit2-时钟源选择(=1系统主频，=0系统主频/8)；<br>②重装载值计算原理：系统时钟频率为72M，1秒钟计数72M次，现SysyTick时钟也为72M，但计数72M/1000次（计数范围：72M/1000-1 ~ 0），可得1ms(1/1000秒)重装载一次。</p>
</blockquote>
<br>
<big>2、PendSV</big>

<p>①PendSV作用：任务切换时保存上下文（将一些寄存器和变量的值保存到任务堆栈，或将任务堆栈出栈，恢复过去任务的运行环境)</p>
<blockquote>
<p>将任务堆栈出栈,就是将要运行的任务的堆栈的栈顶赋给sp，只有知道了sp我们才能找到对应的任务堆栈，才能找到堆栈保存任务信息。<br>恢复任务过去的运行环境（如通过恢复PC的值，我们可以知道上一次这个任务运行到哪了）</p>
</blockquote>
<p>②悬起PendSV的方法是：手工往NVIC的PendSV悬起寄存器中写1。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/08/b614e93ce0474a2120ce2fe9605593b5f688e57444646af6.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int* NVIC_INT_CTRL= (int *)0xE000ED04;  //中断控制寄存器地址</span><br><span class="line">void SetPendSV(void)//挂起PendSV</span><br><span class="line">&#123;</span><br><span class="line">	*NVIC_INT_CTRL=0x10000000;//1&lt;&lt;28</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③PendSV的中断优先级</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void PendSVPriority_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">	char* NVIC_SYSPRI14= (char *)0xE000ED22;  		//PendSV优先级寄存器地址</span><br><span class="line">	*NVIC_SYSPRI14=0xFF;							//设置PendSV中断优先级最低 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<big>3、TCB与任务堆栈</big>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######task.h文件######</span></span><br><span class="line"></span><br><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">	eTask_Running = 0,</span><br><span class="line">	eTask_Ready,</span><br><span class="line">	eTask_Suspended,</span><br><span class="line">	eTask_Blocked,</span><br><span class="line">	eTask_Deleted,</span><br><span class="line">&#125;eTaskSta;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define OS_MAX_TASK 8	//最大任务数量</span></span><br><span class="line">typedef struct _TaskControlBlock</span><br><span class="line">&#123;</span><br><span class="line">	stk32 *StkPtr;</span><br><span class="line">	char name[16];</span><br><span class="line">	int state;	//任务状态</span><br><span class="line">	int prio;</span><br><span class="line">	int DlyTim; //任务阻塞时间</span><br><span class="line">&#125;TCB,*pTCB;</span><br><span class="line">extern pTCB TASK_LIST[OS_MAX_TASK];</span><br><span class="line">extern int created_task_num;</span><br><span class="line"></span><br><span class="line">stk32* task_stk_init(void* func, stk32 *TopOfStack);</span><br><span class="line">void create_new_task( void *func, char name[], int prio, stk32 *TopOfStack, pTCB *tcb);</span><br><span class="line">int GetTaskNum(eTaskSta state);</span><br><span class="line">pTCB GetHighRdyTask(void);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######task.c文件######</span></span><br><span class="line"></span><br><span class="line">pTCB TASK_LIST[OS_MAX_TASK];</span><br><span class="line">int created_task_num = 0;//全局变量</span><br><span class="line">//任务堆栈初始化</span><br><span class="line">//入栈顺序：栈顶-&gt;栈尾 xPSR,PC,LR,R12,R3-R0,R4-R11共16个(SP(R13)保存在TCB首个成员变量中)。</span><br><span class="line">stk32* task_stk_init(void* func, stk32 *TopOfStack)</span><br><span class="line">&#123;</span><br><span class="line">    stk32 *stk;</span><br><span class="line">    stk = TopOfStack;</span><br><span class="line">    *(stk)    = (u32)0x01000000L;//xPSR 程序状态寄存器，xPSR T位(第24位)必须置1,否则第一次执行任务时进入Fault中断                                                     </span><br><span class="line">    *(--stk)  = (u32)func;   //PC   初使化时指向任务函数首地址（任务切换时，可能指向任务函数中间某地址）            </span><br><span class="line">	*(--stk)  = (u32)0xFFFFFFFEL;//LR   保存着各种跳转的返回连接地址,初使化为最低4位为E，是一个非法值，主要目的是不让使用R14，即任务是不能返回的              </span><br><span class="line">	stk-=13;	</span><br><span class="line">    <span class="built_in">return</span> stk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void create_new_task( void *func, char name[], int prio, stk32 *TopOfStack, pTCB *tcb)</span><br><span class="line">&#123;</span><br><span class="line">	int name_len = strlen(name);</span><br><span class="line">	irq_disable();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(created_task_num == OS_MAX_TASK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create Task Fail\r\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(tcb)</span><br><span class="line">	&#123;</span><br><span class="line">		*tcb = (pTCB)malloc(sizeof(TCB));</span><br><span class="line">		<span class="keyword">if</span>(*tcb)</span><br><span class="line">		&#123;</span><br><span class="line">			(*tcb)-&gt;StkPtr = task_stk_init(func,TopOfStack);</span><br><span class="line">			memcpy((*tcb)-&gt;name,name,sizeof(char)*name_len);</span><br><span class="line">			(*tcb)-&gt;state = eTask_Ready;</span><br><span class="line">			(*tcb)-&gt;prio = prio;</span><br><span class="line">			(*tcb)-&gt;DlyTim = 0;	</span><br><span class="line">			TASK_LIST[created_task_num] = *tcb;</span><br><span class="line">			created_task_num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	irq_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetTaskNum(eTaskSta state)</span><br><span class="line">&#123;</span><br><span class="line">	int i, num = 0;</span><br><span class="line">	<span class="keyword">for</span>(i = 0; i &lt; created_task_num; i++)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span>(TASK_LIST[i]-&gt;state == state)</span><br><span class="line">			num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">////数字越大，任务优先权越高</span><br><span class="line">extern pTCB pTCB_IDLE;</span><br><span class="line">pTCB GetHighRdyTask(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	pTCB pTtmp ,pTrdy = pTCB_IDLE;</span><br><span class="line">	<span class="keyword">for</span>(i = 0; i &lt; created_task_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(TASK_LIST[i]-&gt;state == eTask_Ready)</span><br><span class="line">		&#123;</span><br><span class="line">			pTtmp = TASK_LIST[i];</span><br><span class="line">			<span class="keyword">if</span>(pTtmp-&gt;prio &gt; pTrdy-&gt;prio)</span><br><span class="line">				pTrdy = pTtmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> pTrdy;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>敲重点：<br>①“stk32 *StkPtr;”必须放在任务控制块的首位；<br>②入栈顺序与PendSV保存和恢复现场过程有关<br>③没有另外维护就绪、延时列表，只用了一个结构体指针数组，利用任务的状态来管理（任务数量少时影响不大）</p>
</blockquote>
<br>
<big>4、上下文切换：PendSV_Handler函数</big>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">	IMPORT pTCB_Cur</span><br><span class="line">	IMPORT pTCB_Rdy	</span><br><span class="line">	EXPORT PendSV_Handler</span><br><span class="line">	EXPORT SP_INIT</span><br><span class="line">		</span><br><span class="line">	PRESERVE8                  ;//字节对齐关键词,指定当前文件八字节对齐。</span><br><span class="line">	AREA |.text|, CODE, READONLY ;//定义一个代码段或数据段。</span><br><span class="line">	THUMB                      ;//指定以下指令都是THUMB指令集(ARM汇编有多种指令集)</span><br><span class="line"></span><br><span class="line">SP_INIT  					   ;初始化PSP指针                      </span><br><span class="line">    CPSID    I                 ;//关闭全局中断 </span><br><span class="line">	</span><br><span class="line">    LDR R4,=0x0                ;//R4装载立即数0(不直接给PSP赋值0而是经进R寄存器作为媒介是因为PSP只能和R寄存器打交道)            </span><br><span class="line">    MSR     PSP, R4            ;//PSP(process stack pointer)程序堆栈指针赋值0。PSP属用户级(特级权下为MSP)，双堆栈结构。 </span><br><span class="line">	</span><br><span class="line">    CPSIE    I                 ;//打开全局中断(此时若没有其他中断在响应，则立即进入PendSV中断函数)  </span><br><span class="line">    BX    LR  </span><br><span class="line">    </span><br><span class="line">;/******************PendSV_Handler************/</span><br><span class="line">PendSV_Handler</span><br><span class="line">    CPSID    I                            ; OS_ENTER_CRITICAL();</span><br><span class="line">	</span><br><span class="line">    MRS     R0, PSP                            ; R0 = PSP;</span><br><span class="line">    CBZ     R0, PendSV_Handler_NoSave          ; <span class="keyword">if</span>(R0 == 0) goto PendSV_Handler_NoSave;</span><br><span class="line">    </span><br><span class="line">    SUB     R0, R0, <span class="comment">#0x20            ; R0 = R0 - 0x20;</span></span><br><span class="line">    </span><br><span class="line">    ; easy method</span><br><span class="line">    STM     R0, &#123;R4-R11&#125;</span><br><span class="line">    </span><br><span class="line">    LDR     R1, =pTCB_Cur            ; R1 = OSTCBCur;</span><br><span class="line">    LDR     R1, [R1]                 ; R1 = *R1;(R1 = OSTCBCur-&gt;OSTCBStkPtr)</span><br><span class="line">    STR     R0, [R1]                 ; *R1 = R0;(*(OSTCBCur-&gt;OSTCBStkPrt) = R0)</span><br><span class="line"> </span><br><span class="line">PendSV_Handler_NoSave				;每次都会进去（因为PendSV_Handler_NoSave不是函数，而是中间的一个标签，用于跳转）</span><br><span class="line"></span><br><span class="line">	;实质就是pTCB_Cur = pTCB_Rdy</span><br><span class="line">	;每次运行PendSV_Handler，都会使pTCB_Cur指向pTCB_Rdy，所以调度时只需从任务数组中获取pTCB_Rdy</span><br><span class="line">    LDR     R0, =pTCB_Cur           ; R0 = OSTCBCur;</span><br><span class="line">    LDR     R1, =pTCB_Rdy           ; R1 = OSTCBNext;</span><br><span class="line">    LDR     R2, [R1]                ; R2 = OSTCBNext-&gt;OSTCBStkPtr;</span><br><span class="line">    STR     R2, [R0]                ; *R0 = R2;(OSTCBCur-&gt;OSTCBStkPtr = OSTCBNext-&gt;OSTCBStkPtr)</span><br><span class="line">    </span><br><span class="line">    LDR     R0, [R2]                 ; R0 = *R2;(R0 = OSTCBNext-&gt;OSTCBStkPtr)</span><br><span class="line">    LDM     R0, &#123;R4-R11&#125;</span><br><span class="line">    ADD    R0, R0, <span class="comment">#0x20</span></span><br><span class="line"> </span><br><span class="line">    MSR     PSP, R0                 ; PSP = R0;(PSP = OSTCBNext-&gt;OSTCBStkPtr)</span><br><span class="line">    ORR     LR, LR, <span class="comment">#0x04           ; LR = LR | 0x04;</span></span><br><span class="line">	</span><br><span class="line">    CPSIE     I                     ; OS_EXIT_CRITICAL();</span><br><span class="line">    BX    LR                        ; <span class="built_in">return</span>;                                       ; Enable interrupts at processor level</span><br><span class="line">	</span><br><span class="line">	align 4                    ;//内存对齐指令(编译器提供的)，以4个字节(32位)对齐</span><br><span class="line">    end                        ;//伪指令,放在程序行的最后,告诉编译器编译程序到此结束</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我也不是特别懂汇编，就说几个注意点：<br>①PendSV_Handler在kernel.asm中定义了，需要注释掉原来的函数（在stm32f10x_it.h）<br>②PendSV_Handler_NoSave不是函数，而是中间的一个标签，用于跳转<br>③每次运行PendSV_Handler，都会使pTCB_Cur指向pTCB_Rdy，所以调度中只需操作pTCB_Rdy<br>④SP_INIT是PSP指针初始化函数，用汇编写的，在其它地方被调用</p>
</blockquote>
<br>
<big>5、OS_Start与系统延时函数（阻塞，调度）</big>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void OS_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">	PendSVPriority_Init();</span><br><span class="line">	SysTick_Init();</span><br><span class="line"></span><br><span class="line">	pTCB_Rdy = GetHighRdyTask();</span><br><span class="line">	pTCB_Rdy-&gt;state = eTask_Running;</span><br><span class="line">	SP_INIT();</span><br><span class="line">	SetPendSV();</span><br><span class="line">	<span class="keyword">while</span>(1);//等待调度</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//任务创建举例：</span><br><span class="line">create_new_task(Print_Task,<span class="string">"Print_Task"</span>,1,&amp;STK_PRINT_TASK[STK_SIZE-1],&amp;pT2);</span><br><span class="line">void Print_Task(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"print task\r\n"</span>);</span><br><span class="line">		OSDelayTicks(1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OSDelayTicks(int ticks)</span><br><span class="line">&#123;</span><br><span class="line">	pTCB_Cur-&gt;state = eTask_Blocked;</span><br><span class="line">	pTCB_Cur-&gt;DlyTim = ticks-1;</span><br><span class="line">	OS_Schedule();</span><br><span class="line">	<span class="keyword">while</span>(pTCB_Cur-&gt;DlyTim != 0);//不能是<span class="keyword">while</span>(1)，否则下次任务解阻塞后，继续运行<span class="keyword">while</span>(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<big>6、任务调度：SysTick_Handler函数</big>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void OS_Schedule(void)</span><br><span class="line">&#123;	</span><br><span class="line">	pTCB pT = GetHighRdyTask();</span><br><span class="line">	//检测是否需要任务切换，如果需要则挂起PendSV中断</span><br><span class="line">	<span class="keyword">if</span>(pT != pTCB_Cur)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(pTCB_Cur-&gt;state == eTask_Running)</span><br><span class="line">			pTCB_Cur-&gt;state = eTask_Ready;</span><br><span class="line">		</span><br><span class="line">		pTCB_Rdy = pT;</span><br><span class="line">		pTCB_Rdy-&gt;state = eTask_Running;</span><br><span class="line">	</span><br><span class="line">		SetPendSV();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SysTick_Handler(void)</span><br><span class="line">&#123;	</span><br><span class="line">		int i = 0;	</span><br><span class="line">		os_cpu_interrupt_disable();</span><br><span class="line">		<span class="keyword">if</span>(GetTaskNum(eTask_Blocked) != 0)//延时任务列表中是否有阻塞任务</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = 0; i &lt; created_task_num; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(TASK_LIST[i]-&gt;state == eTask_Blocked)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(TASK_LIST[i]-&gt;DlyTim == 0)//延时时间到了，解除阻塞</span><br><span class="line">					&#123;</span><br><span class="line">						TASK_LIST[i]-&gt;state = eTask_Ready;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						TASK_LIST[i]-&gt;DlyTim--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(GetTaskNum(eTask_Ready) != 0)</span><br><span class="line">			OS_Schedule();</span><br><span class="line">		</span><br><span class="line">		os_cpu_interrupt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GitHub下载源码:<a href="https://github.com/cral-freedom/myRTOS" target="_blank" rel="noopener">https://github.com/cral-freedom/myRTOS</a></p>
<p>踩了不少坑，终于成功迈出了第一步：编写了一个具有多任务功能的RTOS；后续还有很多可以改动的地方（向FreeRTOS看齐）<br>基础的有：<br>    &emsp;如用双向链表（或其它数据结构）优化调度和管理，不阻塞调度的延时函数，阻塞调度的绝对延时函数，补充挂起和删除的操作。<br>更高级的：<br>    &emsp;内存管理、共享资源（消息队列、信号量、任务通知）的访问、中断管理，，，</p>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SysTick </tag>
            
            <tag> PendSV </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【编写RTOS】前序]]></title>
      <url>/zhoujiabo.github.io/2020/05/08/%E3%80%90%E7%BC%96%E5%86%99RTOS%E3%80%91%E5%89%8D%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>一个RTOS具有的基本功能：<br>&emsp;1. <strong>任务调度策略</strong><br>&emsp;2. 内存管理<br>&emsp;3. 中断处理<br>&emsp;4. 共享资源的访问<br><br><br><big>了解Cortex-M3</big></p>
<p><strong>寄存器组</strong>：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/08/475a85cb529bb8bbcd790b1a1f0d747c806d7bb3c9fdf2b7.md.png" alt="" title="" class="">
                <p></p>
            </figure> 
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/08/a2026ea776279af74e4dc972518f0a9b2f4844ea575a9d10.md.png" alt="" title="" class="">
                <p></p>
            </figure> 

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">R0-R12 通用寄存器</span><br><span class="line">	R0-R12都是32位通用寄存器，用于数据操作。但是注意，绝大多数16位thumb指令只能访问R0-R7，而32位thumb-2指令可以访问所有寄存器。</span><br><span class="line">    </span><br><span class="line">Banked R13: 两个堆栈指针</span><br><span class="line">	Cortex-M3有两个堆栈指针，它们是banked，所以任一时刻只能使用其中之一。</span><br><span class="line">MSP: 复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程</span><br><span class="line">PSP: 由用户的应用程序代码使用</span><br><span class="line">（堆栈的最低两位永远是0，这意味着堆栈问题4字节对齐的）</span><br><span class="line"></span><br><span class="line">	在ARM编程领域，凡是打断程序顺序执行的事件，都被称为异常。除了外部中断，当有指令执行了“非法操作”，或访问被禁的内存区间，因各种错误产生的fault，以及不可屏蔽中断发生时，都会打断程序的执行，这些情况统称为异常。</span><br></pre></td></tr></table></figure>
<p>任务切换时，我们需要保存这些寄存器的值到任务堆栈，以便下次恢复运行。</p>
<p>Cortex-M3有两个堆栈指针（MSP和PSP），但同时刻只能使用一个，我们可以用一个来作为任务切换时保存“上下文”。</p>
<p>任务切换流程：从A任务切换到B任务，把任务A运行时的寄存器参数入栈保存到任务A的栈中，再把任务B栈里的内容出栈处理，最后让程序计数器PC指向任务B（ PC指向哪儿，处理器就去哪 ）。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/08/7f3b1b2049ac45de212ce1c228c03ba6f014a1372b349ff0.md.png" alt="" title="" class="">
                <p></p>
            </figure> 

<p>《Cortex-M3权威指南》给我们的提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在系统中使用双堆栈</span><br><span class="line">	CM3的出现，让单片机业界也能出双枪李向阳。v7-M架构的一个重要能力，就是提供了这个双堆栈的设计，允许把用户应用程序的堆栈与特权级/操作系统内核的堆栈分开。如果再辅以MPU，还能进一步地阻止用户程序访问内核的堆栈，同时也消除了内核数据被破坏的可能。</span><br><span class="line">	要在CM3中创建可靠扛打的系统，必须两手抓，两手都要硬。典型地，一个真正健壮的CM3软件系统都要使用RTOS内核的，其通常会符合如下的要求：</span><br><span class="line">	a. 服务例程使用MSP（在“非基级线程模式”中会讲到例外情况）</span><br><span class="line">	b. 尽管异常服务例程使用MSP，但是它们在形式上返回后，内容却可以依然继续---而且此时还能使用PSP，从而实现“可抢占式的系统调用”，大幅提高实时性能。</span><br><span class="line">	c. 通过SysTick，实时内核的代码每隔固定时间都被调用一次，运行在特权级水平上，负责任务的调度、任务时间管理以及其它系统例行维护。</span><br><span class="line">	d. 用户应用程序以线程的形式运行，使用PSP，并且在用户级下运行</span><br><span class="line">	e. 内核在执行关键部件的代码时，使用MSP，并且在辅以MPU时，MSP对应的堆栈只允许特权级访问</span><br><span class="line">    </span><br><span class="line"> 	假设系统内存是一块SRAM，则我们可以通过MPU，把它分为两个regions，其中一个用于用户级，另一个用于特权级。另外，CM3的堆栈是“向下生长的满栈”，因此需要把这两个SP初始为指向两个regions的顶端。</span><br></pre></td></tr></table></figure>

<p>关键点：<br>&emsp;①SysTick异常，周期性地把执行点转入操作系统，从而使例行的系统管理以及必要轮转调度得以维持（SysTick作为系统“心跳”）。<br>&emsp;②CM3的堆栈是“向下生长的满栈”</p>
<p>关于“上下文切换“的提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PendSV(可悬起的系统调用)，它和SVC协同使用。一方面，SVC异常是必须得到响应的（若因优先级不比当前正处理的高，或是其它原因使之无法得到响应，将上访成硬fault），应用程序执行SVC时都是希望所需的请求立即得到响应。另一方面，PendSV则不同，它是可以像普通的中断中断一样被悬起（不像SVC那样会上访）。OS可以利用它“缓期执行”一个异常---直到其它重要的任务完成后才执行动作。悬起PendSV的方法是：手工往NVIC的PendSV悬起寄存器中写1。悬起后，如果优先级不够高，则将缓期等待执行。</span><br><span class="line">  PendSV的典型使用场合是在上下文切换时（在不同任务之间切换）。例如一个系统中有两个就绪的任务，上下文被触发的场合可以是：</span><br><span class="line">  a. 执行一个系统调用</span><br><span class="line">  b. 系统滴答定时器（SysTick）中断（转轮调度中需要）</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/05/08/cd7b5bd8bd778a021b72a79476a69b63da66cf89647ae0aa.md.png" alt="" title="" class="">
                <p></p>
            </figure> 


<p><big><strong>Q &amp; A：</strong></big><br><br><em>Q1: RTOS最主要的特性（优势）是什么?</em><br><strong>A1: 实时性，不同以往的前后台系统的轮询调度方法，RTOS通过CPU调度使得多个任务并发处理，每个任务都能得到更快的响应。</strong></p>
<blockquote>
<p>补充<br>.前后台系统：单任务系统，应用程序基本都放在一个大循环while(1)中，有时需要在中断中完成一些处理。中断服务函数即为前台程序，while(1)即为后台程序。<br>.轮询：由CPU定时发出询问，依序询问每一个任务是否需要其服务，有即给予服务，服务结束后再问下一个任务。<br>前后台系统中，各个任务都是排队等待执行的，只能轮到这个任务，它才能执行；实时性很差。</p>
</blockquote>
<p><em>Q2：为什么RTOS能够并发处理多个任务？</em><br><strong>A2：处理器在任一时刻只能执行一个任务。但通过快速的任务切换，一个多任务操作系统可以使它看起来好像每个任务并行执行一样。</strong></p>
<p>关于“并行与并发”的解释（来自知乎）：</p>
<blockquote>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。</p>
</blockquote>
<p><em>Q3：关于RTOS编写，要解决哪些核心问题</em><br><strong>A3：<br>&emsp;a. 系统心跳：SysTick初始化<br>&emsp;b. SysTick和PendSV的优先级设置<br>&emsp;c. 任务控制块TCB结构与堆栈初始化<br>&emsp;d. 上下文切换：PendSV_Handler函数<br>&emsp;e. 系统延时函数（阻塞，调度）<br>&emsp;f. 任务调度：SysTick_Handler函数</strong></p>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 任务切换 </tag>
            
            <tag> CM3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[函数指针数组与回调函数]]></title>
      <url>/zhoujiabo.github.io/2020/04/21/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>函数指针：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> a&gt;b? a:b;</span><br><span class="line">&#125;</span><br><span class="line">void task2(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	//p1,p2是函数指针</span><br><span class="line">	int (*p1)(int,int) = max;</span><br><span class="line">	void (*p2)(void) = task2; </span><br><span class="line">    </span><br><span class="line">	//函数调用</span><br><span class="line">	int c = p1(37, 81);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c:%d\n"</span>,c);</span><br><span class="line">	p2();//或(*p2)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数指针数组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"></span><br><span class="line">void task1(void)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void task2(void)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void task3(void)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	void (*p[3])(void) = &#123;task1, task2, task3&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;3; i++)</span><br><span class="line">		(*p[i])();//调用函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>回调函数(函数指针变量作为参数)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"></span><br><span class="line">int check_activate(int activate)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> activate==1;</span><br><span class="line">&#125;</span><br><span class="line">void exec_task(int (*check)(int),int a[])</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;5; i++)</span><br><span class="line">		<span class="keyword">if</span>(check(a[i]))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"task[%d] is activate\n"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int arr[] = &#123;0,1,1,0,1&#125;;</span><br><span class="line">	exec_task(check_activate,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>综合例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TaskSum 3</span></span><br><span class="line">typedef struct _TCB</span><br><span class="line">&#123;</span><br><span class="line">	char name[10];</span><br><span class="line">	char activate;</span><br><span class="line">	char prio;</span><br><span class="line">	void (*task)(void);</span><br><span class="line">&#125;Tcb;</span><br><span class="line"></span><br><span class="line">void task1(void)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void task2(void)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">void task3(void)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check_activate(int t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> t==1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tcb T[TaskSum] = &#123;</span><br><span class="line">	&#123;<span class="string">"task1"</span>, 1, 0, task1&#125;,</span><br><span class="line">	&#123;<span class="string">"task2"</span>, 0, 2, task2&#125;,</span><br><span class="line">	&#123;<span class="string">"task3"</span>, 1, 1, task3&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void exec_task(int (*check)(int))</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;TaskSum; i++)</span><br><span class="line">		<span class="keyword">if</span>(check(T[i].activate))</span><br><span class="line">			T[i].task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	exec_task(check_activate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 函数指针数组 </tag>
            
            <tag> 回调函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Floyd-Warshall算法]]></title>
      <url>/zhoujiabo.github.io/2020/04/19/MultiStage-Graph/</url>
      <content type="html"><![CDATA[<p>如何计算任意两点间的最短路径？<br>&emsp;用Dijkstra算法循环计算，或者用接下来学的Floyd-Warshall算法。它们的时间复杂度都是O(n^3)。</p>
<p>特点：解决任意两点间的最短路径，可以正确处理有向图、无向图的最短路径问题，同时也被用于计算有向图的传递闭包。图中可以出现负边缘，但不能有负环（环中所有边的权值总和为负）。</p>
<p>更多介绍参考：<a href="https://blog.csdn.net/qq_35644234/article/details/60875818" target="_blank" rel="noopener">https://blog.csdn.net/qq_35644234/article/details/60875818</a> 或 <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Algorithm</a></p>
<p>算法核心思想的伪代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k from 1 to |v|</span><br><span class="line">    <span class="keyword">for</span> i from 1 to |v|</span><br><span class="line">        <span class="keyword">for</span> j from 1 to |v|</span><br><span class="line">            <span class="keyword">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j] <span class="keyword">then</span></span><br><span class="line">                dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line">                path[i][j] = path[i][k]</span><br><span class="line">            end <span class="keyword">if</span></span><br></pre></td></tr></table></figure>



<p>求图中任意两点间的最短路径：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/19/e40eec567232b58021b7c4454a10351d493d62113ad0fc18.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>部分代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//数据结构：</span><br><span class="line">typedef struct _graph_fw</span><br><span class="line">&#123;</span><br><span class="line">	int vexnum;</span><br><span class="line">	int edgnum;</span><br><span class="line">	int **matrix;//邻接矩阵</span><br><span class="line">	int **dis;//任意两顶点间的最短路径权值和 </span><br><span class="line">	int **path;//记录各最短路径的路径信息</span><br><span class="line">&#125;*pG_FW;</span><br><span class="line"></span><br><span class="line">//计算最短路径</span><br><span class="line">void Floyd_Washall(pG_FW *pG)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, k;</span><br><span class="line">	int vexnum = (*pG)-&gt;vexnum;	</span><br><span class="line"></span><br><span class="line">	//D矩阵和P矩阵初始化</span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=0; j&lt;vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			(*pG)-&gt;dis[i][j] = (*pG)-&gt;matrix[i][j];</span><br><span class="line">			(*pG)-&gt;path[i][j] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(k=0; k&lt;vexnum; k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=0; i&lt;vexnum; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=0; j&lt;vexnum; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(	(*pG)-&gt;dis[i][k] != MAX_INT &amp;&amp; (*pG)-&gt;dis[k][j] != MAX_INT</span><br><span class="line">					&amp;&amp; (*pG)-&gt;dis[i][j] &gt; (*pG)-&gt;dis[i][k] + (*pG)-&gt;dis[k][j] )</span><br><span class="line">				&#123;</span><br><span class="line">					(*pG)-&gt;dis[i][j] = (*pG)-&gt;dis[i][k] + (*pG)-&gt;dis[k][j];</span><br><span class="line">					(*pG)-&gt;path[i][j] = (*pG)-&gt;path[i][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C代码下载：<a href="https://github.com/cral-freedom/datastruct_and_algorithm" target="_blank" rel="noopener">https://github.com/cral-freedom/datastruct_and_algorithm</a></p>
<p>测试结果：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/19/3eef89c03ed5eb3eb2b0a5fe5f2c01aeec5d684feeabe3a6.md.png" alt="" title="" class="">
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> all pairs shortest path </tag>
            
            <tag> floyd-warshall </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dijkstra算法]]></title>
      <url>/zhoujiabo.github.io/2020/04/17/Dijkstra%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>单源最短路径问题与求解过程草稿：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/17/IMG_20200417_23105499464dadc2f00b24.md.jpg" alt="字丑见谅" title="" class="">
                <p>字丑见谅</p>
            </figure> 

<p>别人的文章写得更详细：<a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">最短路径问题—Dijkstra算法详解【Ouyang_Lianjun的博客】</a></p>
<p>这里主要补充一点：<br><strong>dijkstra算法在出现负边缘（权值为负的边）的情况下可能有效，可能无效</strong>。<br>因为没有考虑负边缘的情况，所以也不会再检查被选中过的点。</p>
<p>我的C代码实现：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/17/2020041722381483701072e47acd20.md.png" alt="" title="" class="">
                <p></p>
            </figure> 


<p>#dijkstra.h文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef _DIJKSTRA_H</span></span><br><span class="line"><span class="comment">#define _DIJKSTRA_H</span></span><br><span class="line"><span class="comment">#pragma once //保证头文件只被编译一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"><span class="comment">#include "string.h"</span></span><br><span class="line"><span class="comment">#include "stdlib.h"</span></span><br><span class="line"><span class="comment">#define MAX_INT 0x7fffffff</span></span><br><span class="line"></span><br><span class="line">//记录起点到每个顶点的最短路径的信息</span><br><span class="line">typedef struct _dis</span><br><span class="line">&#123;</span><br><span class="line">	char path[50];</span><br><span class="line">	int value;</span><br><span class="line">	int visit;</span><br><span class="line">&#125;Dis;</span><br><span class="line"></span><br><span class="line">typedef struct _graph_dj</span><br><span class="line">&#123;</span><br><span class="line">	int vexnum;</span><br><span class="line">	int edgnum;</span><br><span class="line">	int **matrix;</span><br><span class="line">	Dis *dis;</span><br><span class="line">&#125;*pG_DJ;</span><br><span class="line"></span><br><span class="line">void init_Graph_Dj(pG_DJ *pG, int vexnum, int edgnum);</span><br><span class="line">void print_matrix(pG_DJ pG);</span><br><span class="line">void print_path(pG_DJ pG, int begin);</span><br><span class="line">void creat_Graph_Dj(pG_DJ *pG);</span><br><span class="line">void Dijkstra(pG_DJ *pG,int begin);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<p>#dijkstra.c文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "dijkstra.h"</span></span><br><span class="line"></span><br><span class="line">//有向图</span><br><span class="line">void init_Graph_Dj(pG_DJ *pG, int vexnum, int edgnum)</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	(*pG)-&gt;vexnum = vexnum;</span><br><span class="line">	(*pG)-&gt;edgnum = edgnum;</span><br><span class="line">	(*pG)-&gt;matrix = (int **)malloc(sizeof(int *)*vexnum);</span><br><span class="line">	(*pG)-&gt;dis = (Dis *)malloc(sizeof(Dis)*vexnum);</span><br><span class="line">	//邻接矩阵初始化</span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		(*pG)-&gt;matrix[i] = (int *)malloc(sizeof(int)*vexnum);</span><br><span class="line">		<span class="keyword">for</span>(j=0; j&lt;vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == j)</span><br><span class="line">				(*pG)-&gt;matrix[i][j] = 0;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				(*pG)-&gt;matrix[i][j] = INT_MAX;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//最短路径信息初始化</span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		(*pG)-&gt;dis[i].visit = 0;</span><br><span class="line">		(*pG)-&gt;dis[i].value = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_matrix(pG_DJ pG)</span><br><span class="line">&#123;</span><br><span class="line">	int row,col;</span><br><span class="line">	int vnum = pG-&gt;vexnum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the matrix:\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(row=0; row&lt;vnum; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(col=0; col&lt;vnum; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pG-&gt;matrix[row][col] != MAX_INT)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d   "</span>,pG-&gt;matrix[row][col]);</span><br><span class="line">			<span class="keyword">else</span>	</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"INF   "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_path(pG_DJ pG, int begin)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	char buff[50];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the shortest path while v%d is the begin\n"</span>,begin);</span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;pG-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(pG-&gt;dis[i].value != INT_MAX)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s = %d\n"</span>,pG-&gt;dis[i].path,pG-&gt;dis[i].value);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s is none\n"</span>,pG-&gt;dis[i].path);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void creat_Graph_Dj(pG_DJ *pG)</span><br><span class="line">&#123;</span><br><span class="line">	int start,end,weight,edgenum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"input the start,end,and weight of each edges:\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>(edgenum != (*pG)-&gt;edgnum)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(<span class="string">"%d%d%d"</span>,&amp;start,&amp;end,&amp;weight);</span><br><span class="line">		<span class="keyword">if</span>(start&lt;1 || end&lt;1 || start&gt;(*pG)-&gt;vexnum || end&gt;(*pG)-&gt;vexnum || weight&lt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the value is not legal, please input again\n"</span>);</span><br><span class="line">			// scanf(<span class="string">"%d%d%d"</span>,&amp;start,&amp;end,&amp;weight);</span><br><span class="line">			<span class="built_in">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		(*pG)-&gt;matrix[start-1][end-1] = weight;</span><br><span class="line">		//如果是无向图，加上(*pG)-&gt;matrix[end-1][start-1] = weight;</span><br><span class="line">		edgenum++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Dijkstra(pG_DJ *pG,int begin)</span><br><span class="line">&#123;</span><br><span class="line">	int i,visit_count=0;//已计算完成的点的个数</span><br><span class="line">	int tmp,min;//tmp保存当前dis数组中value最小的点的下标</span><br><span class="line">	char buff[50]=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">	//先选中起点</span><br><span class="line">	(*pG)-&gt;dis[begin-1].visit = 1;</span><br><span class="line">	visit_count++; </span><br><span class="line">	<span class="keyword">for</span>(i=0; i&lt;(*pG)-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		(*pG)-&gt;dis[i].value = (*pG)-&gt;matrix[begin-1][i];</span><br><span class="line">		sprintf((*pG)-&gt;dis[i].path,<span class="string">"v%d--&gt;v%d"</span>,begin,i+1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//计算起点到其它所有顶点的最短路径</span><br><span class="line">	//更新和记录dis[i]中的visit和value信息</span><br><span class="line">	<span class="keyword">while</span>(visit_count != (*pG)-&gt;vexnum)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = 0;min = INT_MAX;</span><br><span class="line"></span><br><span class="line">		//在所有unvisit的顶点中找出最小的value，并记下其对应的下标</span><br><span class="line">		<span class="keyword">for</span>(i=0; i&lt;(*pG)-&gt;vexnum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!((*pG)-&gt;dis[i].visit) &amp;&amp; (*pG)-&gt;dis[i].value &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = (*pG)-&gt;dis[i].value;</span><br><span class="line">				tmp = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;//每经过一次循环，在unvisit中选中一个点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		(*pG)-&gt;dis[tmp].visit = 1;//选中tmp对应的顶点</span><br><span class="line">		visit_count++;</span><br><span class="line">		//更新剩下的顶点的路径信息</span><br><span class="line">		<span class="keyword">for</span>(i=0; i&lt;(*pG)-&gt;vexnum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!((*pG)-&gt;dis[i].visit) &amp;&amp; (*pG)-&gt;matrix[tmp][i]!=INT_MAX </span><br><span class="line">			&amp;&amp; ((*pG)-&gt;dis[tmp].value + (*pG)-&gt;matrix[tmp][i] &lt; (*pG)-&gt;dis[i].value))</span><br><span class="line">			&#123;</span><br><span class="line">				(*pG)-&gt;dis[i].value = (*pG)-&gt;dis[tmp].value + (*pG)-&gt;matrix[tmp][i];</span><br><span class="line">				sprintf(buff,<span class="string">"%s--&gt;v%d"</span>,(*pG)-&gt;dis[tmp].path,i+1);</span><br><span class="line">				strcpy((*pG)-&gt;dis[i].path,buff);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#main.c文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "dijkstra.h"</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int vexnum,edgnum;</span><br><span class="line">	pG_DJ pG;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"input the vexnum and edgnum:"</span>);</span><br><span class="line">	scanf(<span class="string">"%d%d"</span>,&amp;vexnum,&amp;edgnum);</span><br><span class="line">	init_Graph_Dj(&amp;pG,vexnum,edgnum);</span><br><span class="line">	creat_Graph_Dj(&amp;pG);</span><br><span class="line">	print_matrix(pG);</span><br><span class="line">	Dijkstra(&amp;pG,1);</span><br><span class="line">	print_path(pG,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/17/2020041722562529f8d3987b4f9753.md.png" alt="" title="" class="">
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dijkstra算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter8: 从源文件到可执行文件]]></title>
      <url>/zhoujiabo.github.io/2020/04/15/chapter8/</url>
      <content type="html"><![CDATA[<p>问题：<br>    &emsp;1. CPU可以解析和运行的程序形式称为什么代码？<br>    &emsp;2. 将多个目标文件结合生成exe文件的工具称为什么？<br>    &emsp;3. 扩展名为.obj的目标文件的内容，是源代码还是本地代码？<br>    &emsp;4. 把多个目标文件收录在一起的文件称为什么？<br>    &emsp;5. 仅包含Windows的DLL文件中存储的函数信息的文件称为什么？<br>    &emsp;6. 在程序运行时，用来动态申请分配的数据和对象的内存区域形式称为什么？</p>
<p>答案：<br>    &emsp;1. 本地代码<br>    &emsp;2. 链接工具<br>    &emsp;3. 本地代码<br>    &emsp;4. 库文件（链接器会从库文件中抽取出必要的目标文件并将其结合到exe文件中）<br>    &emsp;5. 导入库（把导入库信息结合到exe文件，这样程序在运行时就可以利用dll内的函数了）<br>    &emsp;6. 堆</p>
<p>8.1 计算机只能运行本地代码</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/15/1f0a752133a68c883086cb54ca013148add9caeda021c75e.md.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>8.3 编译器负责转换源代码<br>    &emsp;编译器首先读入代码的内容，然后再把源代码转换成本地代码。编译器中就有一个源代码同本地代码的对应表，但这还不够，读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/15/3aa867fa746d41fb36567d5dd97566e8ead9766fbbb89252.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>有一种编译器，<u>它生成的是和运行环境中CPU不同的CPU所使用的本地代码</u>，这种编译器叫做<em>交叉编译器</em>。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/15/97d81ac058f9a3dd32ea386388b3a43ab147c3a6aebd853b.md.png" alt="" title="" class="">
                <p></p>
            </figure>

<p><strong>编写源代码的语言、编译器程序本身运行的环境、编译输出要在哪种CPU运行的本地代码</strong></p>
<p>8.4 仅造编译是无法得到可执行文件的<br>    &emsp;编译器转换源代码后，就会生成本地文件（<em>编译后生成的是扩展名为.obj的目标文件</em>）。不过，本地文件是无法直接运行的（因为当前程序还处于未完成状态）。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。</p>
<p>8.5 启动及库文件<br>    &emsp;即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。<br>    &emsp;库文件（扩展名为.lib）指的是把多个目标文件集成保存到一个文件中的形式。链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成exe文件。<br>    &emsp;spintf()等函数，不是通过源代码形式而是库文件形式和编译器一起提供的。这样的函数叫做标准函数。如此一来，编译器厂商也不用公开标准函数的源代码内容，避免了代码被其它公司任意转用而造成的损失。</p>
<p>8.6 dll文件及导入库<br>    &emsp;Windows以函数的形式为应用提供了各种功能。这些形式的函数称为API。如MessageBox()，它还是C语言的标准函数而Windows提供的API的一种，它提供了显示消息框的功能。<br>   &emsp;windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL文件的特殊库文件中。import32.lib是导入库，它存储着两个信息，一是MessageBox()在user32.dll这个dll文件中，另一个是存储着dll文件的文件夹信息。<br>    &emsp;存储着目标文件的实体，并直接和exe文件结合的库文件形式称为静态链接库。<br><img src="https://file.moetu.org/images/2020/04/15/89f5bcf86aebc56763c00526a6b33b3b8b36a89d7f38bd1a.md.png" alt=" "></p>
<p>8.7 可执行文件运行时的必要条件<br>    &emsp;每次运行，程序内的变量和函数被分配到的内存地址都是不同的。  exe文件中，变量和函数的内存地址的值是如何来表示的？<br>   &emsp;exe文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在exe文件的开头，追加转换内存地址所需的必要信息，这个信息称为再配置信息。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/15/f67ac31a3a98e29ccb36c408837bb663b05d9a41e598dfb5.md.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>8.8 程序加载时会生成栈和堆<br>    &emsp;exe文件中并不存在栈和堆的组，栈和堆需要的内存空间是在exe文件加载到内存后开始运行时得到分配的。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/15/f9555108668af540654e71bce8010917266b24641898673b.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>   &emsp;栈和堆的内存空间都是在程序运行时得到申请分配的，不过在内存的使用方法上，二者存在不同。栈中对数据进行存储和清理的代码，是由编译器自动生成的，不需要程序员的参与。而堆的内存空间则要根据程序员定的程序来明确进行申请分配或释放（<em>堆的内存空间不及时释放，会造成内存泄露，如果内存泄露一直存在，就有可能会造成内存不足而导致宕机</em>）。</p>
<p>8.9 有点难度的Q&amp;A</p>
<p>Q：编译器和解释器有什么不同？<br>A：编译器是在<u>运行前</u>对所有源代码进行解释处理，而解释器则是在<u>运行时</u>对源代码的内容一行一行地进行解释处理的。</p>
<p>Q：”分割编译”指的是什么？<br>A：<u>将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个exe文件</u>。这样每个源代码都相对变短，便于程序管理。</p>
<p>Q：”build”指的是什么？<br>A：根据开发工具种类的不同，有的编译器可以通过选择”build”菜单来生成exe文件，这种情况下，<u>build指的是连续执行编译和链接</u>。</p>
<p>Q：使用dll文件的好处是什么？<br>A：dll文件中的函数可以被多个程序共用，因此<strong>可以节约内存和磁盘。此外，在对函数内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序</strong>。</p>
<p>Q：不链接导入库的话就无法调用dll文件中的函数吗？<br>A：通过LoadLibrary()及GetProcAddress这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一些。</p>
<p>Q：”叠加链接”这个术语指的是什么？<br>A：<u>将不会同时执行的函数，交替加载到同一个地址中运行</u>。通过“叠加链接器”这一特殊的链接器即可实现。在内存容量不多的MS-DOS时代，经常使用叠加链接。</p>
<p>Q：和内存管理相关的“垃圾回收机制”指的是什么呢？<br>A：垃圾回收机制指的是对处理完毕后不再需要的堆内存空间的数据和对象进行清理，释放它们所使用的内存空间。这里把不需要的数据比喻为了垃圾。C和C++要手动调用函数释放内存，而<strong>在C++基础上开发出来的Java和C#编程语言中，程序运行环境会自动进行垃圾回收。这样就可以避免由于程序的疏忽（忘了释放内存）而造成内存泄露了</strong>。    </p>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序是怎么跑起来的 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter7: 程序是在何种环境中运行的]]></title>
      <url>/zhoujiabo.github.io/2020/04/14/chapter7-%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%9C%A8%E4%BD%95%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>问题：<br>    &emsp;1. 应用的运行环境，指的是什么？<br>    &emsp;2. Macintosh用的操作系统（MacOS），在AT兼容机上能运行吗？<br>    &emsp;3. Windows上的应用，在MacOS上运行吗？<br>    &emsp;4. FreeBSD提供的Ports，指的是什么？<br>    &emsp;5. 在Macintosh上可以利用的Windows环境模拟器称为什么？<br>    &emsp;6. Java虚拟机的功能是什么？<br>答案：<br>    &emsp;1. 操作系统和计算机本身（硬件）的种类<br>    &emsp;2. 无法运行<br>    &emsp;3. 无法运行<br>    &emsp;4. 通过源代码来提供应用，并根据运行环境进行整合编译，从而得以在该环境下运行的机制<br>    &emsp;5. Virtual PC for Mac<br>    &emsp;6. 运行Java应用的字节代码（只要分别为各个环境安装专用的Java虚拟机，同样的字节代码就能在各种环境下运行了）</p>
<p>7.1 运行环境 = 操作系统 + 硬件<br>    &emsp;CPU只能解释其自身固有的机器语言。x86、MIPS、SPARC、PowerPC等几种类型的CPU，它们的各自的机器语言是完全不同的。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/14/3faad29e926e7f5658f45e8256cc1cb360514dc098191599.png" alt="" title="" class="">
                <p></p>
            </figure>   
<p>机器语言的程序称为本地代码。程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件(排除文字编码的问题)在任何环境下都能显示和编辑，我们称之为源代码。通过对源代码进行编译，就可以得到本地代码。<br>   &emsp;windows应用程序的本地代码，通常是EXE文件及DLL文件等形式。<br><img src="https://file.moetu.org/images/2020/04/14/598e5e9201a9331faabb40eb48c62efa2a3875898f8cf35c.png" alt=""></p>
<p>7.2 Windows克服了CPU以外的硬件差异<br>    &emsp;计算机的硬件不仅仅是由CPU构成的，还包括用于存储程序指令和数据的内存，以及通过I/O连接的键盘、显示器、硬盘、打印机等外围设备。<br>    &emsp;计算机对这些外围设备的控制与计算机的机型有着很大关系。在MS-DOS（Windows前身）时代，日本国内市场上有NEC的PC-9801、富士通的FMR、东芝的Dynabook等各种机型的计算机。这些机型虽然都搭载了486及Pentiunm等x86系列的CPU，不过内存和I/O地址的构成等都是不同。<br>    &emsp;每个机型，都需要有专门的MS-DOS应用。因为应用软件的功能中，存在着直接操作计算机硬件的部分。一是因为当时MS-DOS的功能功能尚不完善，二是为了提高程序的运行速度。<br>    &emsp;不过，随着windows的广泛使用，这样的局面得到了大幅改善。因为只要windows能正常运行，同样的应用（本地代码）在任何机型上都是可以运行的。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/14/85e4d0be53ef85bc1de3c636960a31288b4eb343f63f4bc4.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>MS-DOS中，不同机型的应用是不同的；而Windows则可以使用同一个应用。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/14/73017b66b5bced341317f98f4d8c5be95a89350ce0bfad2a.png" alt="" title="" class="">
                <p></p>
            </figure>
<blockquote>
<p>windows应用基本上都由windows来完成对硬件的控制。windows操作的是硬件，而不同机型的硬件构成有所差异（主要是CPU类型差异），所以windows本身也需要为不同机型分别提供专用的版本。</p>
</blockquote>
<p>7.3 不同操作系统的API不同<br>   &emsp;应用程序向操作系统传递指令的途径称为API。操作系统的类型不同，应用程序向操作系统传递指令的途径不同，即不同操作系统的API不同。<br>（API也称为“系统调用”，是应用调用操作系统功能的手段。）<br>    &emsp;因为不同操作的API有差异，因此将应用程序移植到其它操作系统时，就必须要重写应用中利用到API的部分。像键盘输入、鼠标输入、显示器输出、文件输入输出等同外围设备进行输入输出操作的功能，都是通过API提供的。<br>   &emsp;在同类型的操作系统下，不管硬件如何，API基本上没有差别。因而，针对某特定操作系统的API所编写的程序，在任何硬件上都可以运行。当然，由于CPU种类不同，机器语言也不相同，因此本地代码当然也是不同的。这种情况下，<u>就需要利用对源代码进行重新编译</u>。</p>
<p>7.4 FreeBSD Port帮你轻松使用源代码<br>    &emsp;既然CPU类型不同会导致同样的本地代码无法重复利用，那么为何不直接把源代码分发给程序呢？<br>    &emsp;FreeBSD中存在一种名为Ports的机制，该机制能够结构当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码。如果目标应用的源代码没有在硬件上的话，ports就会自动使用FTP连接到相关站点来下载代码。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/14/a018452c1e6c0e95cbe09c78116a8a16c2007c317ab2219c.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>FTP（File Transfer Protocol）是连接到互联网上的计算机之间传递文件的协议。<br>   &emsp;全球很多站点都提供适用于FreeBSD的应用源代码。下载好后，C编译器可以结合FreeBSD的运行环境生成合适的本地代码。Ports表示的是porting（移植）的意思。而根据不同的运行环境来重新调整程序，一般也称为移植。</p>
<p>7.5 利用虚拟机获得其他操作系统环境</p>
<p>7.6 提供相同运行环境的Java虚拟机<br>   &emsp; 除虚拟机的方法外，还有一种方法能够提供不依赖于特定硬件及操作系统的程序运行环境，那就是Java。<br>    &emsp;大家说的Java，有两个层面的意思。一个是作为编程语言的Java，另一个是作为程序运行环境的Java。同其他编程语言相同，Java也是将Java语法记述的源代码编译后运行。不过，编译后生成的并不是特定CPU使用的本地代码，而是名为字节代码的程序。字节代码的运行环境就称为Java虚拟机。Java虚拟机是一边把Java字节逐一转换成本地代码一边运行的。（实现同样的字节代码在不同的环境下运行）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/14/e1cbf62669aa3d290cd40b26a35e7979b920b1436b8274da.png" alt="" title="" class="">
                <p></p>
            </figure>
<blockquote>
<p>从操作系统方面来看，Java虚拟机（JVM）是一个应用，而从Java应用方面来看，JVM就是运行环境。<br>但也存在一些问题，一是不同的JVM之间无法进行完整互换，二是运行速度。</p>
</blockquote>
<p>7.7     BIOS和引导<br>    &emsp;程序的运行环境中，存在着名为BIOS(Basic Input/Output System)的系统。BIOS存储在ROM中，是预先内置在计算机内部的程序，除了键盘、磁盘、显示等基本控制程序外，还有启动“引导程序”的功能。</p>
<blockquote>
<p>开机后，BIOS会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的OS加载到内存中运行。虽然启动应用是OS的功能，但OS并不能启动自己，而是通过引导程序来启动。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序是怎么跑起来的 </tag>
            
            <tag> 运行环境 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[背包问题---贪心算法]]></title>
      <url>/zhoujiabo.github.io/2020/04/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>#从一个问题出发了解贪心算法#：</p>
<p>问题：张三要从广州赶往杭州出差<br>限制（constraint）：8个小时内到达<br>可选择的方法：走路、骑自行车、开车、坐火车、坐飞机<br>可行解（feasible solutions）：开车、坐火车、坐飞机<br>最优解（optimal solution）：坐飞机<br>minimum cost one in feasible solutions → optimal solution </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">algorithm Greedy( a, n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> i=1 <span class="keyword">in</span> n <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = select(n);</span><br><span class="line">        <span class="keyword">if</span> feasible(x) <span class="keyword">then</span>    //如果可行，则添加到解集</span><br><span class="line">            solutions += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> optimal(solutions); //从可行解中找出最优解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背包问题：<br>    将n种物品装入一个承重为M的背包，每种物品的属性如下;</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/11/27d2bb3b0b669f58043045756c740f7c7cfe1196fe9b829f.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>已知：n = 7（种）; M =15（kg）<br>限制（constraint）:  ∑ Xi*Wi &lt;= M (物品总质量不能超过背包承重)<br>目标（Objective）：max∑ Xi*Pi（利润最大）<br>注意：这里的每个物品，不是单一的个体（如洗衣机，不可分割的），而是一类物品的集合</p>
<p>基本思路：从收益率高的物品开始放入背包。<br>问题分析：解决思路不难，主要问题在数据结构上<br>上述问题的答案：55.33</p>
<p>算法实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**********main.c********************/</span><br><span class="line"><span class="comment">#include "knapsack.h"</span></span><br><span class="line"><span class="comment">#include "quicksort.h"</span></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    pSack S;</span><br><span class="line">    init_sack(&amp;S,ObjN);</span><br><span class="line">    quick_sort(S-&gt;pObjs,0,ObjN-1);</span><br><span class="line">    print_sack(S);</span><br><span class="line"></span><br><span class="line">    SnapSack(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max_profit:%f\n"</span>,S-&gt;profit_sum);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*********kanpsack.h：数据结构定义********************/</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef _KNAPSACK_H</span></span><br><span class="line"><span class="comment">#define _KNAPSACK_H</span></span><br><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define ObjN 7  //设置目标个数</span></span><br><span class="line"><span class="comment">#define MaxWeight 15    //设置背包承重</span></span><br><span class="line">typedef struct _obj</span><br><span class="line">&#123;</span><br><span class="line">    int weight;//重量</span><br><span class="line">    int profit;//利润</span><br><span class="line">    <span class="built_in">float</span> pw_rate; //收益率</span><br><span class="line">&#125;Obj,*pObj;</span><br><span class="line">//这里的目标不是单一的整体（可分割的）</span><br><span class="line">//单一的整体：洗衣机、电脑；集合：可称重卖的商品，如白糖，花生油</span><br><span class="line"></span><br><span class="line">typedef struct _pack</span><br><span class="line">&#123;</span><br><span class="line">    int capicity;   //总容量</span><br><span class="line">    int weight_sum;     //已放入的重量</span><br><span class="line">    <span class="built_in">float</span> profit_sum;       //已有收益</span><br><span class="line">    pObj pObjs;     //目标物品</span><br><span class="line">    int obj_num;        //物品个数</span><br><span class="line">&#125;*pSack;</span><br><span class="line"></span><br><span class="line">int init_Objs(pObj *objs, int n);</span><br><span class="line">void init_sack(pSack *S, int objn);</span><br><span class="line">void print_sack(pSack S);</span><br><span class="line">void SnapSack(pSack S);</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/*********kanpsack.c：数据结构初始化，函数实现********************/</span><br><span class="line"></span><br><span class="line">int init_Objs(pObj *objs, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,w=0,p=0;</span><br><span class="line">    <span class="built_in">float</span> rate;</span><br><span class="line">    *objs = (Obj *)malloc(sizeof(Obj)*n);</span><br><span class="line">    <span class="keyword">if</span>(*objs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"enter each obj's weight and profit:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"obj[%d]'s weight and profit:"</span>,i);   </span><br><span class="line">            scanf(<span class="string">"%d%d"</span>,&amp;w,&amp;p);</span><br><span class="line">            (*objs)[i].weight = w;</span><br><span class="line">            (*objs)[i].profit = p;</span><br><span class="line">            (*objs)[i].pw_rate = (<span class="built_in">float</span>)p/w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_sack(pSack *S, int objn)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    *S = (pSack)malloc(sizeof(pSack));</span><br><span class="line">    <span class="keyword">if</span>(*S)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(init_Objs(&amp;((*S)-&gt;pObjs), objn) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            (*S)-&gt;capicity = MaxWeight;</span><br><span class="line">            (*S)-&gt;weight_sum = 0;</span><br><span class="line">            (*S)-&gt;profit_sum = 0;   </span><br><span class="line">            (*S)-&gt;obj_num = objn;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"sack init success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_sack(pSack S)</span><br><span class="line">&#123;</span><br><span class="line">    int i,objn = S-&gt;obj_num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"weight_sum:%d\tprofit_sum:%d\tcapcity:%d\tobj_num:%d\n"</span>,S-&gt;weight_sum,S-&gt;profit_sum,S-&gt;capicity,S-&gt;obj_num);</span><br><span class="line">    <span class="keyword">for</span>(i=0; i&lt;objn; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S-&gt;pObjs[%d]    weight:%d\tprofit:%d\tpw_rate:%f\n"</span></span><br><span class="line">        ,i,S-&gt;pObjs[i].weight,S-&gt;pObjs[i].profit,S-&gt;pObjs[i].pw_rate);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SnapSack(pSack S)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    <span class="keyword">while</span>( S-&gt;capicity - S-&gt;weight_sum &gt; S-&gt;pObjs[i].weight)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;profit_sum += S-&gt;pObjs[i].profit;</span><br><span class="line">        S-&gt;weight_sum += S-&gt;pObjs[i].weight;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;weight_sum &lt; S-&gt;capicity)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;profit_sum += S-&gt;pObjs[i].pw_rate * (S-&gt;capicity - S-&gt;weight_sum);</span><br><span class="line">        S-&gt;weight_sum = S-&gt;capicity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/***************快速排序的主要函数************************/</span><br><span class="line"></span><br><span class="line">typedef Obj elemtype;</span><br><span class="line">void swap(elemtype *p1, elemtype *p2)</span><br><span class="line">&#123;</span><br><span class="line">    elemtype tmp;</span><br><span class="line">    tmp = *p1; *p1 = *p2; *p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对Obj的收益率进行，降序排序</span><br><span class="line">int partition(elemtype arr[], int l, int h)</span><br><span class="line">&#123;</span><br><span class="line">    int i=l,j=h,mid=(l+h)/2;</span><br><span class="line">    <span class="built_in">float</span> pivot = arr[mid].pw_rate;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i].pw_rate &gt; pivot)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span>(arr[j].pw_rate &lt; pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].pw_rate == pivot &amp;&amp; arr[j].pw_rate == pivot) <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            swap(&amp;arr[i],&amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">void quick_sort(elemtype arr[], int l, int h)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; h)</span><br><span class="line">    &#123;</span><br><span class="line">        j = partition(arr,l,h);</span><br><span class="line">        quick_sort(arr,l,j-1);</span><br><span class="line">        quick_sort(arr,j+1,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果（图片大小截得不一样，见谅）：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/11/20200411184315052f99f0a7a2714f.png" alt="" title="" class="">
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/11/20200411184329424279cf9b3556fb.png" alt="" title="" class="">
                <p></p>
            </figure>




























]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心算法 </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二维数组与二维指针]]></title>
      <url>/zhoujiabo.github.io/2020/04/10/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<ol>
<li><p>指针包含两个方面：地址值，和所指向的数据类型</p>
</li>
<li><p>解引用操作符，会根据指针当前的地址值，以及所指向的数据类型，访问一块连续的内存空间（大小由指针所指向的数据类型决定），将这块空间的内容转换成相应的数据类型，并返回左值</p>
</li>
<li><p>因此，<u>两个指针的值相同（指向相同的地址)，但数据类型不同，解引用取到的值也是不同的</u>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char str[] = &#123;0,1,2,3&#125;; //以字符的ASCII码初始化</span><br><span class="line">char *pc = str;</span><br><span class="line">int *pi = (int *)str;    </span><br><span class="line">//pc和pi指向的地址相同，而因为指针pi指向的数据类型是int，因此在解引用时，需要访问4个字节的连续空间，并将其转换为int返回。<span class="built_in">printf</span>(<span class="string">"*pi:%x"</span>,*pi); 打印得到03020100（计算机为小端模式）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证大小端：<br>int num = 0x12345678;<br>char <em>pc = &num;<br>printf(“&amp;num:%x\tpc:%x\n”,&amp;num,pc);<br>printf(“%x:%x(H)\t”,pc,</em>pc);<br>打印得到：<br>&amp;num:61fe14     pc:61fe14<br>61fe14:78(H)<br>由上面结果可知，低地址存放低位，为小端模式。</p>
</blockquote>
</li>
<li><p>对数组名的认识：作为右值时数组名可视为指针常量；作为左值时，例如sizeof，则不能视为指针。//<strong>sizeof(数组名) 返回的是数组大小*每个元素占字节数；而sizeof(一个指针)返回4或8</strong>。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/aafb000d259aed4351933e86ee548e452df9b45ddf46cfc5.md.png" alt="" title="" class="">
                <p></p>
            </figure>
</li>
<li><p>数组和指针参数是如何被编译器修改的？</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/54e3c4a8c51822db8ce30759c94641af0146f05c41fc68ec.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;数组名被改写成一个指针参数这个规则不是递归定义的，<u>也就是说虽然我们可以将一维数组名传递给一维指针，但不能将二维数组传递给二维指针</u>，如上图，二维数组匹配的形参是数组指针。</p>
<blockquote>
<p>int a[2][3];<br>int (<em>p1)[3]=a //( a = &amp;a[0]）;<br>int</em>p2=a[0]=&amp;a[0][0]=*a;</p>
</blockquote>
</li>
</ol>
<p>将二维数组名作为参数传递，形参的形式有：<br>void func( int a[2][3] );<br>void func( int a[][3] );<br>void func( int (*a)[2] );</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/5be31ea8f157dc25ff95c8850a85a067438e936bf3946e16.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>参数不能为int a[][]（会报错），至少需要告诉编译器第二维的大小</strong>。</p>
<p><strong>如何实现不告诉编译器数组的维数，也能进行矩阵（多维数组）运算呢？</strong></p>
<blockquote>
<p>答案就是，模仿编译器的行为把arr[i][j]进行手工转变。</p>
</blockquote>
<br>
###转变形式1：\*((int\*)array + col\*i + j); 对应传参：数组名，&arr[0]
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line">//pMatrix[row][col]</span><br><span class="line"><span class="comment">#define GetValue(pResult,col,i,j) (*((int*)pResult + col*i + j))</span></span><br><span class="line"></span><br><span class="line">void print_matrix(int **a, int row, int col)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=0; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=0; j&lt;col; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,GetValue(a,col,i,j));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int a[2][2] = &#123;&#123;2,4&#125;,&#123;1,6&#125;&#125;;</span><br><span class="line">    print_matrix((int **)a,2,2); //传数组名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/858abbea06571251c44144a225ae24ce61c4db625a3fefca.png" alt="" title="" class="">
                <p></p>
            </figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int GetValue(int **pResult,int col,int i,int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> (*((int*)pResult + col*i + j));</span><br><span class="line">&#125;</span><br><span class="line">//矩阵乘法</span><br><span class="line">void MatrixMultiplyGeneral(int **pMatrix1, int row1, int col1,</span><br><span class="line">                int **pMatrix2, int row2, int col2, int **pResult)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k,sum,val1=0,val2=0;</span><br><span class="line">    <span class="keyword">if</span>(col1!=row2) <span class="built_in">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i=0; i&lt;row1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=0; j&lt;col2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = 0;</span><br><span class="line">            <span class="keyword">for</span>(k=0; k&lt; col1; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                val1 = GetValue(pMatrix1,col1,i,k);</span><br><span class="line">                val2 = GetValue(pMatrix2,col2,k,j);</span><br><span class="line">                sum += val1*val2;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d*%d   "</span>,val1,val2);</span><br><span class="line">                //pResult[i][j] = pMatrix1[i][k]*pMatrix2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%d\n"</span>,sum);</span><br><span class="line">            *((int*)pResult + col2*i + j) = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int a[2][2] = &#123;&#123;2,4&#125;,&#123;1,6&#125;&#125;;</span><br><span class="line">    int b[2][3] = &#123;&#123;6,4,3&#125;,&#123;2,2,1&#125;&#125;;</span><br><span class="line">    int c[2][3] = &#123;0&#125;;</span><br><span class="line">    MatrixMultiplyGeneral((int **)a,2,2,(int **)b,2,3,(int **)c);</span><br><span class="line">    print_matrix((int **)c,2,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/bc27f22aae76515bfe2bf0c55c9a0bcfbde0e1b1dfc35fbe.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>
###形式2：\*(pResult + col \* i + j) 对应传参：arr[0]=&arr[0][0]=*arr
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//不传二维数组名，传int *类型的数组地址。</span><br><span class="line">int GetValue(int *pResult,int col,int i,int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> (*(pResult + col*i + j));</span><br><span class="line">&#125;</span><br><span class="line">void print_matrix(int *a, int row, int col)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=0; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=0; j&lt;col; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,GetValue(a,col,i,j));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int b[2][3] = &#123;&#123;6,4,3&#125;,&#123;2,2,1&#125;&#125;;</span><br><span class="line">    print_matrix(b[0],2,3);</span><br><span class="line">    //因为b[0]=&amp;b[0][0]=*b, 均为int *型，所以还可写成：</span><br><span class="line">    //print_matrix(&amp;b[0][0],2,3);</span><br><span class="line">    // print_matrix(*b,2,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找出矩阵中的最大值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"></span><br><span class="line">int find_matrix_max(int *a, int row, int col, int *rpos, int *cpos)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,max=*a;</span><br><span class="line">    <span class="keyword">for</span>(i=0; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=0; j&lt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; *(a + i*col + j))</span><br><span class="line">            &#123;</span><br><span class="line">                max = *(a + i*col + j);</span><br><span class="line">                *rpos = i;</span><br><span class="line">                *cpos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> max;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int a[2][3] = &#123;&#123;2,4,19&#125;,&#123;15,1,6&#125;&#125;;</span><br><span class="line">    int *p = a[0],rpos,cpos;</span><br><span class="line">    int max = find_matrix_max(a[0],2,3,&amp;rpos,&amp;cpos);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max = a[%d][%d] = %d\n"</span>,rpos,cpos,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/4e02a009c673a12ef88e4417b442ff705de25ceb0de9ce2d.png" alt="" title="" class="">
                <p></p>
            </figure>

<br>
普通矩阵乘法，要做8次乘法
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/91f849f4f19da71bb3bf83c38867f4a7dfb842fd5f138567.png" alt="" title="" class="">
                <p></p>
            </figure>
矩阵乘法的迭代和递归方法的时间复杂数均为O(n^3)

<p>strassen算法，可以减少一次乘法 —O(n^log7)= O(n^2.81)</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/10/2c3f900cdb55560a2b367b77239ccced4ae764213e14f6ea.png" alt="" title="" class="">
                <p></p>
            </figure>



]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 矩阵乘法 </tag>
            
            <tag> 二维数组作参 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter6: 数据压缩]]></title>
      <url>/zhoujiabo.github.io/2020/04/09/chapter6/</url>
      <content type="html"><![CDATA[<p>问题：<br>&emsp;1. 文件储存的基本单元是什么？<br>    &emsp;2. doc、lzh和txt这些扩展名中，哪一个是压缩文件的扩展名？<br>    &emsp;3. 文件内容用“数据的值 x 循环次数”来表示的压缩方法是RLE算法还是哈夫曼算法？<br>    &emsp;4. 在windows计算机经常使用的shift jis字符编码中，1个半角英数是用几个字节的数据来表示的？<br>    &emsp;5. BMP格式的图像文件，是压缩过的吗？<br>    &emsp;6. 可逆压缩和非可逆压缩的不同点是什么？</p>
<p>答案：<br>    &emsp;1. 1字节（文件是字节数据的集合体）<br>    &emsp;2. lzh<br>    &emsp;3. RLE算法（如AAABB这个数据压缩后就是A3B2）<br>    &emsp;4. 1字节（半角英文数字是1个字节，汉字等全角字符是2个字节）<br>    &emsp;5. 没有压缩过<br>    &emsp;6. 压缩后的数据能复原的是可逆压缩，无法复原的是非可逆压缩</p>
<p>6.1 文件以字节为单位保存<br>    &emsp;文件是将数据存储在磁盘等存储媒介中的一种形式。程序文件中存储数据的单位是字节 。文件大小用xxKB, xxMB表示（B = Byte）。在任何情况下，文件中的字节数据都是连续存储的。</p>
<blockquote>
<p>从物理上对磁盘进行读写时是以扇区（512字节）为单位的，但另一方面，程序则可以在逻辑上以字节为单位对文件的内容进行读写</p>
</blockquote>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/Imagee5b55a20084dedfb.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>6.2 RLE算法的机制</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/Image24103de488ef09b7.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>RLE（run length encoding，行程长度编码)算法，通常被用于压缩传真的图像等。</p>
<p>&emsp;由于文本文件中字符连续出现的情况并不多见，因此使用RLE算法后文件大小反而变成了原来的2倍。</p>
<blockquote>
<p>压缩后同压缩前文件大小的比率，称为压缩比率或压缩比。</p>
</blockquote>
<p>6.4 通过莫尔斯编码来看哈夫曼算法的基础<br>    &emsp;为了更好地理解哈夫曼算法，首先要抛弃掉”半角英文数字的1个字符是1个字节的数据”这一概念。文本文件是由不同类型的字符组合而成的，而且不同的字符出现的次数也是不同的。例如，在某一个文本文件中，A出现了100次，Q仅用到了3次，类似这样的情况很常见。<br>    &emsp;而哈夫曼算法的关键就在于”多次出现的数据用小于8位的字节数来表示，不常用的数据可以用超过8位的字节数来表示”。A和Q都用8位来表示时，原文件的大小就是100次x8位+3次x8位=824位；而假设A用2位、Q用10位来表示，压缩后的大小就是100次x2位+3次x10位 = 230位。<br>    &emsp;不过有一点需要注意，不管是不满8位的数据，还是超过8位的数据，最终都要以8位为单位保存到文件中。为了实现这一处理，压缩程序的内容会复杂很多，不过，作为回报，最终的压缩率也是相当高的。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/e4a49c2c8741fe21df64d0331785a2ad669292d387f4e025.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;莫尔斯编码把一般文本中出现频率高的签字用短编码来表示。现尝试用莫尔其编码来表示AAAAAABBCDDEEEEEF这个17个字符的文本。<br>4位（A）x6次+8位x2次+9位x1次+6位x2次+1位x5次+8位x1次+2位（字符间隔)x16 = 106位（约14字节）。如果文件只能以字节为单位来存储数据，因为不满1字节的部分就要整成一个字节， 莫尔斯电码的压缩比率就为14÷17 = 82%，并不太突出（不能以偏概全，这个文本中A出现的次数最频繁，给A分配数据长度最短的编码会使压缩率更高）。</p>
<p>6.5 用二叉树实现哈夫曼编码<br>    &emsp;哈夫曼算法是指，为各压缩对象文件分别构造最佳的编码体系，并以该编码体系为基础来进行压缩。因此，用什么样式的编码对数据进行分割，就要由各个文件而定。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/100f0107c34c527d0af439d26cb849c003585d6e0d582a5a.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>将AAAAAABBCDDEEEEEF按照“出现频率高的字符用尽量少的位数编码来表示”这一原则进行整理。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/48bf73b13b36c28c410c8d6148d01ce870e4f83c26c3ded8.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;有个问题：如100这个3位的编码，它的意思是用1、0、0表示E、A、A，还是用10、0表示B、A，或者是表示C。如果我们不加入分隔符，编码方案就无法使用。</p>
<p>&emsp;而在哈夫曼算法中，通过借助哈夫曼树构造编码体系，即使在不使用字符区分符号的情况下，也可以构建能够明确进行区分的编码体系。</p>
<p><big><strong>借助哈夫曼树构造编码体系</strong></big><br>①列出数据及其出现频率，括号中的数字表示频率，降序排列：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/1b30183795f5c6391a6401f56fcc288f9461ee5956a38ead.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>②选择两个出现频率最小的数字，拉出两条线，并在交叉地方写上这两个数字的和；当有多个选项是任意选取即可：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/0f121569cc40641ae16012b106b828e536224c3faa806fd0.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>③重复步骤②，可以连接任何数值：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/28e0f2b2f8aa6de0abf1504b3246c5269db2ecd6bd17a197.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>④最后这些数字会被汇集到1个点上，该点就是根，这样哈夫曼树也就完成了。<strong>按照从树根到叶的顺序，左树枝（线）上写0，右树枝上写1；然后从树根沿着树枝到树叶，将沿途的树枝上的0或1写下来，就可以得到哈夫曼编码</strong>。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/c76b83714679a6fd1c65f40aca5b0f1fc2e82fd8b6ead7d2.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>6.6 哈夫曼算法能够大幅提升压缩比率</p>
<blockquote>
<p><strong>为什么出现频率越高的数据所占用的数据位数就越少？</strong><br>    在用枝条连接数据时，我们是从出现频率较低的数据开始的，这就意味着出现频率越低的数据到达根部的枝条数就越多，从而编码的位数也随之增多。</p>
</blockquote>
<blockquote>
<p><strong>数据的区分是如何实现的</strong><br>    从哈夫曼算法压缩过的文件中读取数据后，就会以位为单位对该数据进行排查，并与哈夫曼树进行比较看是否到达了目标编码。</p>
</blockquote>
<p>使用LHA（一种使用哈夫曼算法的压缩应用软件）对各种文件的压缩结果：（不管是哪种类型的文件，都得到了很高的压缩比率）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/6a2dd33f9a94321b74755a41e24b3c25270d11b597ea6dcd.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>6.7 可逆压缩和非可逆压缩<br>    &emsp;windows的标准图像数据形式为BMP，是完全未压缩的。由于显示及打印机输出的bit(点)是可以直接映射的(mapping)，因此有了bmp = bitmap这一名称。<br>    &emsp;其他格式的图像数据形式，如JPEG、TIFF、GIF等格式的图像数据都会用一些方法来对数据进行压缩。<br>   &emsp; 对于程序的EXE文件以及每个字符 、数值者有具体含义的文本文件，我们必须要还原到和压缩前同样的内容。<em>而对于图像文件来说，我们有时并不要求压缩后的图像文件必须还原到与压缩前同等的质量</em>，只要肉眼看不出什么区别，有一些模糊也勉强可以接受。我们把能还原到压缩前状态的压缩称为可逆压缩，无法还原到压缩前状态的压缩称为非可逆压缩。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/120534a480c5492225ae4b443b0302daa908d544beffa756.png" alt="" title="" class="">
                <p></p>
            </figure> 

<p>四种图片格式比较</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/09/3dcfc40ed0d3a8ce7d005f4d95d587f9bf85644aa7f7317a.png" alt="" title="" class="">
                <p></p>
            </figure>













]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈夫曼树 </tag>
            
            <tag> 数据压缩 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter5: 内存和磁盘的亲密关系]]></title>
      <url>/zhoujiabo.github.io/2020/04/07/chapter5/</url>
      <content type="html"><![CDATA[<p>问题：<br>&emsp;1. 存储程序方式指的是什么？<br>&emsp;2. 通过使用内存来提高磁盘访问速度的机制称为什么？<br>&emsp;3. 把磁盘的一部分作为假想内存来使用的机制称为什么？<br>&emsp;4. windows中，在程序运行时，存储着可以动态加载调用的函数和数据的文件称为什么？<br>&emsp;5. 在exe程序文件中，静态加载函数的方式称为什么？<br>&emsp;6. 在windows计算机中，一般磁盘的1个扇区是多少字节？</p>
<p>答案：<br>&emsp;1. 在存储装置中保存程序，并逐一运行的方式<br>&emsp;2. 磁盘缓存<br>&emsp;3. 虚拟内存（借助虚拟内存，哪怕是内存容量不足的计算机，也可以运行很大的程序）<br>&emsp;4. DLL文件（Dynamic Link Liabrary）<br>&emsp;5. 静态链接（函数的加载方式有静态链接和动态链接两种）<br>&emsp;6. 512字节（扇区是磁盘保存数据的物理单位）</p>
<p>&emsp;内存和磁盘都属于计算机5大部件中的存储器（其它4个分别是输入装置，输出装置，运算器和控制器）。不过，利用电流来实现存储的内存，同利用磁效应来实现存储的磁盘（内存的存取是电子动作，而磁盘的存取是I/O动作） ，是有差异的。内存高速高价，磁盘低速廉价。<br>内存主要是指主存，磁盘主要是指硬盘。</p>
<p>5.1 不读入内存就无法运行<br>&emsp;程序保存在存储设备中，通过有序地被读出来实现运行。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/13ffa9195366d8d5996d11eabc66a4931f7111acd63e23cb.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>5.2 磁盘缓存加快了磁盘访问速度<br>&emsp;磁盘缓存指的是从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/ca45f27f9203804e2a7cad5f53f48ca3f5ef324b60b730fd.png" alt="" title="" class="">
                <p></p>
            </figure>
<blockquote>
<p>磁盘缓存分类：<br>读缓存：操作系统为已读取的文件数据，在内存较空闲的情况下留在内存空间，当下次软件或用户再次读取同一文件时就不必重新从磁盘中读取，从而提高速度；<br>写缓存：将要写入磁盘的数据先保存于系统为写缓存分配的内存空间中，当保存到内存池中的数据达到一定程度，再将数据一起保存到硬盘中（可以减少实际的磁盘操作）。</p>
</blockquote>
<p>5.3 虚拟内存把磁盘的一部分作为假想的内存来使用<br>&emsp;CPU只能执行加载到内存中的程序。所以虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在于内存中的。也就是说，为了实现虚拟内存，就必须把实际内存中的内容，和磁盘上的待运行的程序进行置换（swap)。<br>&emsp;虚拟内存的方式有分页式和分段式两种。windows采用的是分页式：在不考虑程序构造的情况下，把运行的程序按照一定大小的页（一般为4KB）进行分割，并以页为单位在内存和磁盘间进行置换。</p>
<p>&emsp;为了实现虚拟内存功能，windows在磁盘上提供了虚拟内存用的文件（page file，页文件），该文件由windows自动生成和管理。文件的大小，也就是虚拟内存的大小，通常是实际内存的相同程度至两倍。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/dcbe0429d9140d30fc51ce0a4a33b0676fd543b9daf3678d.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>5.4 节约内存的编程方法<br>&emsp;虚拟内存能避免因内存不足导致应用无法启动的问题。不过，由于使用虚拟内存时发生的Page In和Page Out往往伴随着低速的磁盘访问，在这个过程中应用的运行会变得迟钝。<br>&emsp;从根本上解决内存不足的问题，需要增加内存的容量（费钱），或者尽量把运行的应用文件变小（费脑）。</p>
<p>两个把应用文件变小的编程方法：<br>1）通过DLL文件实现函数共有<br>&emsp;DLL文件，顾名思议，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。此外，多个应用可以共有一个DLL文件。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/57009d84bd185245dcebc445428249e32acc864730823d52.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;内存中存在具有同一函数的两个程序，会导致内存的利用效率降低。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/495798ae037d7a41d8e66f32f9c739aeb209f13db5d5c715.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;有时我们安装新应用时，会看到目录下有不少.dll文件。应用通过利用这些dll文件的功能来运行。之所以要利用多个dll文件，其中的一个原因就是可以节约内存。而且dll文件还有一个优点，就是在不变更exe文件的情况下，只通过升级dll文件就可以更新。</p>
<p>2）通过调用_stdcall来减小程序文件的大小</p>
<blockquote>
<p>_stdcall是standard call（标准调用）的略称。windows提供的dll文件内的函数，基本上都是_stdcall调用方式。这主要是为了节约内存，另外，用C语言编写的程序内的函数，默认设置都不是_stdcall。这是因为C语言所对应的函数的传入参数是可变的，这种情况下，栈的清理作业无法进行。只有在函数的参数数量固定的情况下，能指定_stdcall。</p>
</blockquote>
<p>&emsp;C语言中，在调用函数后，需要执行栈清理处理指令。栈清理处理是指，把不需要的数据从（接收和传递函数的参数时使用的内存上的）栈区域中清理出去。该命令是在程序编译时由编译器自动附加到程序中的，编译器默认将该处理附加在函数调用方。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/e5c4ed21728855fdca0db0185448c54d8171b5203e4c29f2.png" alt="" title="" class="">
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/86e23e3920dae4b3b88efe3c503ac3d443f490039f0d5a46.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>&emsp;C语言通过栈来传递函数的参数。（通过寄存器来返回返回值）。<br>&emsp;栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/07/2b02a3738156743e9626342cbcabc81900320f4b50136f14.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>5.5 磁盘的物理结构<br>&emsp;磁盘的物理结构是指磁盘存储数据的形式。磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有扇区方式和可变长方式两种，windows中所使用的硬盘和软盘（ 早期计算机上的一种可移储存硬件，适用于一些需要被物理移动的小文件，软盘的读写是用过软驱也就是软盘驱动器来完成的），采用的都是固定长度的扇区方式。<br>&emsp;扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小划分而成的空间就是扇区。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/08/8b7e4dcd4646a8e3c47f0e6fd021c0f2074e517810e7bd8a.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>&emsp;扇区是对磁盘进行物理读写的最小单位。不过，windows在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍——簇。1簇可以是512字节，1KB（2个扇区），2KB，4KB，，，磁盘的容量越大，簇的容量也越大。不过，在软盘中，簇和扇区的大小是相等的。</p>
<p>&emsp;无论是硬盘还是软盘，不同的文件是不能存储在同一簇中的（无论多么小的文件，都会占用1簇的空间）。</p>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序是怎么跑起来的 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[优先级队列(by max_heap)]]></title>
      <url>/zhoujiabo.github.io/2020/04/07/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-by-max-heap/</url>
      <content type="html"><![CDATA[<p>1、Array Representation of Binary Tree<br>2、Complete Binary Tree<br>3、Heap<br>4、Insert &amp; Delet<br>5、Heap Sort<br>6、Heapify<br>7、Priority Queue</p>
<p>Array Representation of Binary Tree：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/06/798d7852c24ae76094e8d1de90b62d52bd1d7e521fbbf869.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>数组存储二叉树的存储规则：</p>
<blockquote>
<p>if a hole is at index i, then its leftchild is 2<em>i,<br>its rightchild is (2</em>i+1), and its parents is i/2.</p>
</blockquote>
<p>Full Binary Tree has [2^(n+1)-1] leaves (n is the high of tree)</p>
<p>Complete Binary Tree — there are no spaces in array representation.</p>
<p>非完全二叉树：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/05/0f9a8ff99adaabdddfbc1c9ad178ec0755e47919e7663f2c.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>其顺序存储结构：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/05/47e127808e0122d834c4306eddbf0f693724981e9eb6c570.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>满二叉树和完全二叉树：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/06/f05bb045bf3352bf3920d29c704fe5e89689cf32fee98bf7.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>完全二叉树：前n层为满二叉树，最后一层从左到右依次填充</strong>。</p>
<p>heap — 首先要是完全二叉树<br><strong>max heap —根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆</strong><br>min heap —与max heap相反</p>
<p>operations：Insert &amp; Delete<br>插入：<br>①先将待插入的值回到数组末尾<br>②与其父节点比较，大于则swap, 位置调换<br>③重复②，直到其为根节点</p>
<p>删除：（一般只删除根节点 —取出堆的最大值）<br>①删除根节点，用数组的最后一个元素放入数组首位（原来根节点的位置）<br>②若其子节点大于它，将更大的子节点与其交换<br>③重复②，将元素向下推向”树叶”，直到恢复为max heap</p>
<p>Heap sort：<br>&emsp;逐个地将所有数据添加到堆中（create max heap），然后从堆中连续删除元素，并将其填充到自由空间中，即可自动完成排序。（因为每次删除，都会取出堆中的最大值）</p>
<p>Heapify：<br>&emsp;先一次性复制数组元素到新的数组，然后新数组自我调整成最大堆（其中调整的过程就叫做heapify）。（ 或者说，使得一个数组是堆有序的操作就叫做“heapify”）</p>
<p>&emsp;索引从1开始计数时，第一个非叶子的结点的索引是index/2；从index/2递减到根节点依次去完成shift down，即可使堆有序。</p>
<blockquote>
<p>思考：为什么不用shift up(上浮)，而用shift down（下沉）<br>使用shift up的话，得将数组中所有的元素都shift up，才能使堆有序；而用shift down的话，工作量可以减少一半！</p>
</blockquote>
<p>&emsp;将n个元素逐一插入到一个空堆中，时间复杂度是O(nlogn)；而Heapify过程的时间复杂度是O(n)。</p>
<p><em>重要结论</em>：堆排序在整体的性能上不如归并排序和快排。但是，堆这种数据结构更多的时候用于<strong>动态数据的维护</strong>。</p>
<p>Priority Queue：<br>&emsp;堆是实现优先级队列的最佳数据结构，每次从队列中取出具有最高优先权的元素。</p>
<p>算法实现代码：</p>
<p><em>priqueue.h</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _PRIQUEUE_H</span><br><span class="line">#define _PRIQUEUE_H</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#define MAXSIZE 30</span><br><span class="line"></span><br><span class="line">typedef struct _item</span><br><span class="line">&#123;</span><br><span class="line">	char name[10];	&#x2F;&#x2F;数据部分</span><br><span class="line">	int prio;	&#x2F;&#x2F;优先级	</span><br><span class="line">&#125;Item;</span><br><span class="line"></span><br><span class="line">typedef struct _heap</span><br><span class="line">&#123;</span><br><span class="line">	int capcity;</span><br><span class="line">	int size;</span><br><span class="line">	Item *pItem;	&#x2F;&#x2F;piro[0]空着，下标从1开始</span><br><span class="line">&#125;*pQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void pQ_init(pQueue *pQ);</span><br><span class="line">void pQ_print(pQueue Q);</span><br><span class="line">int is_empty(pQueue Q);</span><br><span class="line">int is_full(pQueue Q);</span><br><span class="line">void EnQueue(pQueue *pQ, Item item);</span><br><span class="line">void DeQueue(pQueue *pQ, Item *item);</span><br><span class="line">void exam_queue(pQueue *pQ);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>


<p><em>priqueue.c</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;priqueue.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; priority queue, implemented by max_heap</span><br><span class="line">void pQ_init(pQueue *pQ)</span><br><span class="line">&#123;</span><br><span class="line">	*pQ &#x3D; (pQueue)malloc(sizeof(pQueue));</span><br><span class="line">	if(*pQ)</span><br><span class="line">	&#123;</span><br><span class="line">		(*pQ)-&gt;pItem &#x3D; (Item *)malloc(sizeof(Item)*(MAXSIZE+1));</span><br><span class="line">		if((*pQ)-&gt;pItem)</span><br><span class="line">		&#123;</span><br><span class="line">			(*pQ)-&gt;capcity &#x3D; MAXSIZE;</span><br><span class="line">			memset((*pQ)-&gt;pItem,-1,sizeof(Item)*(MAXSIZE+1));</span><br><span class="line">			(*pQ)-&gt;size &#x3D; 0;</span><br><span class="line">			printf(&quot;init success\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pQ_print(pQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	printf(&quot;Q-&gt;size:%d\n&quot;,Q-&gt;size);</span><br><span class="line">	for(i&#x3D;1; i&lt;&#x3D;Q-&gt;size; i++)</span><br><span class="line">		printf(&quot;(%s,%d) &quot;,Q-&gt;pItem[i].name,Q-&gt;pItem[i].prio);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef Item swaptype;</span><br><span class="line">void swap(swaptype *p1, swaptype *p2)</span><br><span class="line">&#123;</span><br><span class="line">	swaptype tmp;</span><br><span class="line">	tmp &#x3D; *p1;</span><br><span class="line">	*p1 &#x3D; *p2;</span><br><span class="line">	*p2 &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int is_empty(pQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">	return Q-&gt;size&#x3D;&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">int is_full(pQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">	return Q-&gt;size&#x3D;&#x3D;Q-&gt;capcity;</span><br><span class="line">&#125;</span><br><span class="line">void DeQueue(pQueue *pQ, Item *item)</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	if(!is_empty(*pQ))</span><br><span class="line">	&#123;</span><br><span class="line">		*item &#x3D; (*pQ)-&gt;pItem[1];</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;调整位置</span><br><span class="line">		(*pQ)-&gt;pItem[1] &#x3D; (*pQ)-&gt;pItem[(*pQ)-&gt;size]; &#x2F;&#x2F;最后一个调到前面</span><br><span class="line">		memset(&amp;(*pQ)-&gt;pItem[(*pQ)-&gt;size],-1,sizeof(Item));&#x2F;&#x2F;最后项的位置清空</span><br><span class="line"></span><br><span class="line">		i &#x3D; 1,j&#x3D;1;</span><br><span class="line">		while((*pQ)-&gt;pItem[i*2+1].prio !&#x3D; -1)</span><br><span class="line">		&#123;</span><br><span class="line">			if((*pQ)-&gt;pItem[i*2].prio &gt;&#x3D; (*pQ)-&gt;pItem[i*2+1].prio)</span><br><span class="line">				j &#x3D; i*2;</span><br><span class="line">			else  </span><br><span class="line">				j &#x3D; i*2 + 1;</span><br><span class="line"></span><br><span class="line">			swap(&amp;((*pQ)-&gt;pItem[j]),&amp;((*pQ)-&gt;pItem[i]));</span><br><span class="line">			i &#x3D; j; 		</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		(*pQ)-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EnQueue(pQueue *pQ, Item item)</span><br><span class="line">&#123;</span><br><span class="line">	int i,tmp;</span><br><span class="line">	if(!is_full(*pQ))</span><br><span class="line">	&#123;	</span><br><span class="line">		(*pQ)-&gt;size++;	</span><br><span class="line">		memcpy(&amp;(*pQ)-&gt;pItem[(*pQ)-&gt;size],&amp;item,sizeof(Item));</span><br><span class="line"></span><br><span class="line">		i &#x3D; (*pQ)-&gt;size;</span><br><span class="line">		while(i&gt;&#x3D;2 &amp;&amp; (*pQ)-&gt;pItem[i].prio &gt; (*pQ)-&gt;pItem[i&#x2F;2].prio ) &#x2F;&#x2F;新添项的优先级比父节点要大</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F; 调整位置</span><br><span class="line">			swap(&amp;((*pQ)-&gt;pItem[i]),&amp;((*pQ)-&gt;pItem[i&#x2F;2]));</span><br><span class="line">			i &#x2F;&#x3D; 2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;heapify：使一个数组是堆有序的操作，sink：调整方式为下沉</span><br><span class="line">void HeapifyBySink(pQueue *pQ)</span><br><span class="line">&#123;</span><br><span class="line">	int i,start &#x3D; (*pQ)-&gt;size&#x2F;2;</span><br><span class="line">	int indexofmax;</span><br><span class="line">	for(i&#x3D;start; i&gt;&#x3D;1; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		if((*pQ)-&gt;pItem[i*2].prio &gt;&#x3D; (*pQ)-&gt;pItem[i*2+1].prio)</span><br><span class="line">			indexofmax &#x3D; i*2;</span><br><span class="line">		else  </span><br><span class="line">			indexofmax &#x3D; i*2 + 1;</span><br><span class="line">		printf(&quot;indexofmax:%d\n&quot;,indexofmax);</span><br><span class="line">		if((*pQ)-&gt;pItem[i].prio &gt;&#x3D; (*pQ)-&gt;pItem[indexofmax].prio)</span><br><span class="line">			;</span><br><span class="line">		else	&#x2F;&#x2F;如果小于其子节点，就交换</span><br><span class="line">			swap(&amp;((*pQ)-&gt;pItem[i]),&amp;((*pQ)-&gt;pItem[indexofmax]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;heapify：使一个数组是堆有序的操作，sink：调整方式</span><br><span class="line">void HeapifyBySink(pQueue *pQ)</span><br><span class="line">&#123;</span><br><span class="line">	int i,start &#x3D; (*pQ)-&gt;size&#x2F;2;</span><br><span class="line">	int indexofmax;</span><br><span class="line">	for(i&#x3D;start; i&gt;&#x3D;1; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		if((*pQ)-&gt;pItem[i*2].prio &gt;&#x3D; (*pQ)-&gt;pItem[i*2+1].prio)</span><br><span class="line">			indexofmax &#x3D; i*2;</span><br><span class="line">		else  </span><br><span class="line">			indexofmax &#x3D; i*2 + 1;</span><br><span class="line">		printf(&quot;indexofmax:%d\n&quot;,indexofmax);</span><br><span class="line">		if((*pQ)-&gt;pItem[i].prio &gt;&#x3D; (*pQ)-&gt;pItem[indexofmax].prio)</span><br><span class="line">			;</span><br><span class="line">		else	&#x2F;&#x2F;如果小于其子节点，就交换</span><br><span class="line">			swap(&amp;((*pQ)-&gt;pItem[i]),&amp;((*pQ)-&gt;pItem[indexofmax]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exam_queue(pQueue *pQ)</span><br><span class="line">&#123;</span><br><span class="line">	Item a[] &#x3D; &#123;&#123;&quot;zhou&quot;,1&#125;,&#123;&quot;wang&quot;,4&#125;,&#123;&quot;li&quot;,3&#125;,&#123;&quot;niu&quot;,29&#125;,&#123;&quot;yang&quot;,15&#125;,&#123;&quot;ji&quot;,8&#125;&#125;;</span><br><span class="line">	int i,len &#x3D; sizeof(a)&#x2F;sizeof(a[0]);</span><br><span class="line">	printf(&quot;len:%d\n&quot;,len);</span><br><span class="line"></span><br><span class="line">	pQ_init(pQ);</span><br><span class="line">	memcpy(&amp;((*pQ)-&gt;pItem[1]),a,sizeof(Item)*len);&#x2F;&#x2F;起始地址不要搞错了</span><br><span class="line">	(*pQ)-&gt;size &#x3D; len;</span><br><span class="line"></span><br><span class="line">	HeapifyBySink(pQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*************main.c************&#x2F;</span><br><span class="line"></span><br><span class="line">#include &quot;priqueue.h&quot;</span><br><span class="line">int test();</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dsp()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;priority queue test:\n&quot;);</span><br><span class="line">	printf(&quot;1.create a priority queue\n&quot;);</span><br><span class="line">	printf(&quot;2.enqueue\n&quot;);</span><br><span class="line">	printf(&quot;3.dequeue\n&quot;);</span><br><span class="line">	printf(&quot;4.printf queue\n&quot;);</span><br><span class="line">	printf(&quot;9.exit\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">	int i,opt;</span><br><span class="line">	Item item;</span><br><span class="line">	pQueue pQ;</span><br><span class="line">	dsp();</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;your option:&quot;);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;opt);</span><br><span class="line">		switch(opt)</span><br><span class="line">		&#123;</span><br><span class="line">			case 1:exam_queue(&amp;pQ);break;</span><br><span class="line">			case 2:</span><br><span class="line">				printf(&quot;item.name and item.prio:&quot;);</span><br><span class="line">				scanf(&quot;%s%d&quot;,&amp;item.name,&amp;item.prio);</span><br><span class="line">				EnQueue(&amp;pQ,item);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				DeQueue(&amp;pQ,&amp;item);</span><br><span class="line">				printf(&quot;delqueue:\nname:%s\tprio:%d\n&quot;,item.name,item.prio);</span><br><span class="line">			case 4:</span><br><span class="line">				pQ_print(pQ);break;</span><br><span class="line">			case 9:</span><br><span class="line">				printf(&quot;exit\n&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 优先级队列 </tag>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【算法】渐近符号]]></title>
      <url>/zhoujiabo.github.io/2020/04/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%B8%90%E8%BF%91%E7%AC%A6%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p><strong>Asymptotic Notation</strong>：<br>    &emsp;• O —— big-oh：upper bound<br>    &emsp;• Ω —— big-omega：lower bound<br>    &emsp;• θ  —— big-theta：average bound</p>
<p>big-oh:<br>&emsp;The function f(n) = O(g(n))，存在constant c and n0，such that f(n) &lt;= c*g(n)，对于所有n &gt;= n0成立。<br>&emsp;eg: f(n) = 2n + 3<br>因为2n + 3 &lt;= 10n (n &gt;= 1)    — c为10，g(n)为n，n0为1，<br>所以f(n) = O(g(n)) = O(n)<br>补充：推出O(n^2)，O(n^3)，，，也不能说错，不过O(n)是最接近的。</p>
<p>big-theta：<br>&emsp;The function f(n) = θ(g(n))，存在constant c1, c2, n0；使得c1<em>g(n) &lt;= f(n) &lt;= c2</em>g(n)，对于n &gt;= n0成立。<br>&emsp;eg: f(n) = 2n + 3<br>因为 2n &lt;= 2n + 3 &lt;= 5n    — c1=2, c2=5, n0=1, g(n)=n<br>所以f(n) = θ(g(n)) = θ(n)</p>
<p>big-omega：<br>&emsp;The function f(n) = Ω(g(n))，存在constant c , n0；使得f(n) &gt;= c<em>g(n)，对于n &gt;= n0成立。<br>&emsp;eg: f(n) = 2n + 3<br>因为 2n + 3 &gt;= 1</em>n &gt;= 1*logn   — c=1,n0=1, g(n)=n或logn<br>所以f(n) = θ(g(n)) = Ω(n) 或 Ω(logn) ，n &gt;= 1<br>补充：一般写最接近的，即Ω(n)</p>
<p><strong>Analysis</strong>:<br>①f(n) = 2n^2 + 3n + 4<br>2n^2 + 3n + 4&lt;= 2n^2 + 3n^2+4n^2 = 9n^2，n &gt;= 1    —f(n) = O(n^2)<br>2n^2 + 3n + 4 &gt;= n^2，n &gt;= 0    —f(n) = Ω(n^2)<br>n^2 &lt;= 2n^2 + 3n + 4 &lt;= 9n^2    —f(n) = θ(n^2)</p>
<p>②f(n) = (n^2)logn + n<br>(n^2)logn &lt;= (n^2)logn + n &lt;= 10*(n^2)logn<br> —O( (n^2)logn ), θ( (n^2)logn ), Ω( (n^2)logn )</p>
<p>③ f(n) = (n!) = n<em>(n-1)</em>(n-2)……<em>2</em>1<br>1<em>1……<em>1 &lt; 1</em>2*3……</em>(n-1)<em>n &lt;= n</em>n<em>n……</em>n<br>—Ω(1)，O(n^n)，不存在θ</p>
<p><strong>General properties</strong>：<br>①f(n)乘上常数，其对应的O(g(n))不变 —Ω和θ同样适用</p>
<blockquote>
<p>if f(n) is O(g(n)), then a<em>f(n) also is O(g(n))<br>eg: f(n) = 2n^2+5，is O(n^2)，<br>      7</em>f(n) = 14n^2+35，also is (O^2)</p>
</blockquote>
<p>②reflexive（反身的）</p>
<blockquote>
<p>if f(n) is given, then f(n) is O(f(n))<br>eg: f(n) = n^2 → f(n) = O(n^2)</p>
</blockquote>
<p>③trasitive（传递性质）</p>
<blockquote>
<p>if f(n) is O(g(n)) and g(n) is O(h(n)),<br>then f(n) is O(h(n)).<br>eg:f(n) = n, g(n) = n^2, h(n) = n^3<br>f(n) = O(n^2) &amp;&amp; g(n) = O(n^3) → f(n) = O(n^3)</p>
</blockquote>
<p>④symmetric（对称的）</p>
<blockquote>
<p>if f(n) is θ(g(n)), then g(n) is θ(f(n))<br>eg:f(n) = n^2, g(n^2)<br>f(n) = θ(n), is θ(g(n))<br>g(n) = θ(n), is θ(f(n))</p>
</blockquote>
<p>⑤tranpose symmetric（转置对称）</p>
<blockquote>
<p>if f(n) is O(g(n))，then g(n) is Ω(f(n))</p>
</blockquote>
<p>⑥</p>
<blockquote>
<p>if f(n) is O(g(n))，and f(n) is Ω(g(n))<br>then f(n) = θ(g(n))</p>
</blockquote>
<p>⑦</p>
<blockquote>
<p>if f(n) = O(g(n)), d(n) = O(e(n))<br>then f(n) + d(n) = O{max[g(n),e(n)]}<br>eg:f(n) = n = O(n)<br>   d(n) = n^2 = O(n^2)<br>f(n) + d(n) = n + n^2 = O(n^2）</p>
</blockquote>
<p>⑧</p>
<blockquote>
<p>if f(n) = O(g(n)), d(n) = O(e(n)),<br>then f(n)<em>d(n) = O{g(n)</em>e(n)}</p>
</blockquote>
<p><strong>比较大小</strong>：<br>① f(n) = (n^2)logn    g(n) = n(logn)^10<br>两边取对数，2logn+loglogn    logn+10loglogn<br>∴ (n^2)logn &gt; n(logn)^10</p>
<p>② f(n) = 3n^(n^1/2)    g(n) = 2^{(n^1/2)* logn}<br>两边取对数，(根号n)* log3n    (根号n)logn<br>n →无穷时，f(n) = g(n)</p>
<p>③f(n) = n^(logn)    g(n) = 2^(根号n)<br>apply log:    logn<em>logn=(logn)^2    根号n<br>apply log again:    2loglogn    0.5</em>logn<br>∴  n^(logn) &lt; 2^(根号n)</p>
<p>④f(n) = 2^(logn)    g(n) = n^(根号n)<br>apply log:    logn    (根号n)logn<br>∴f(n) &lt; g(n)</p>
<p>⑤f(n) = 2n    g(n) = 3n<br>n →无穷，f(n) = g(n)</p>
<p>⑥f(n) = 2^n    g(n) = 2^(2n)<br>f(n) &lt; g(n)=4^n    —常数和底数不同</p>
<p>⑦如果f(n)和g(n)都是分段函数，我们可以分段讨论，但在算法分析中，我们更关注无穷时的情况。</p>
<p><strong>判断</strong>：</p>
<p>①(n+k)^m = θ(n^m)    (√)    —级数展开，只保留底数最大次幂最高的项</p>
<p>②2^(n+1) = O(2^n)    （√） —相比只是多乘了个2，系数可以忽略</p>
<p>③2^(2n) = O(2^n)        (×)    —4^n与2^n在n趋于无穷时，相去甚远</p>
<p>④(logn)^1/2 = O(loglogn)    （×）    — 0.5loglogn &gt;logloglogn</p>
<p>⑤n^(logn) = O(2^n)     (√)    — 两次log后，2loglogn &lt; logn</p>
]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter4: 熟悉使用有棱有角的内存]]></title>
      <url>/zhoujiabo.github.io/2020/04/03/chapter4/</url>
      <content type="html"><![CDATA[<p>问题：<br>    &emsp;1. 有十个地址信号引脚的内存IC可以指定的地址范围是多少？<br>    &emsp;2. 高级编程语言中的数据类型表示的是什么？<br>    &emsp;3. 在32位内存地址的环境中，指针变量的长度是多少位？<br>    &emsp;4. 与物理内存有着相同构造的数组的数据类型长度是多少？<br>    &emsp;5. 用LIFO方式进行数据读写的数据结构称为什么？<br>    &emsp;6. 根据数据的大小链表分叉成两个方向的数据结构称为什么？</p>
<p>答案：<br>    &emsp;1. 0~1023<br>    &emsp;2. 占据内存区域的大小和存储在该内存区域的数据类型<br>    &emsp;3. 32位，4字节<br>    &emsp;4. 1字节（物理地址是以字节为单位进行数据存储的）<br>    &emsp;5. 栈（LIFO = Last In First Out）<br>    &emsp;6. 二叉查找树</p>
<p>4.1 内存的物理机制很简单<br>&emsp;内存实际上是一种名为内存IC的电子元件。内存IC包括DRAM、SRAM、ROM等多种形式，但从外部来看，其基本机制都是一样的。内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚，通过为其指定地址，来进行数据的读写。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/03/aa0601616e49ce91cf689938fa198a3f1cde2fcebebd60e0.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>问题1：上图中的内存IC中能存储多少数据？<br>解析：数据信号引脚有D0-D7共八个，表示一次可以输入输出8位（即一个字节）的数据。此外，地址信号引脚有A0-A9共十个，表示可以指定0000000000-1111111111共1024个地址。而地址用来表示数据的存储场所，因此我们可以得出这个内存IC中可以存储1024个1byte的数据。所以内存IC的容量就是1KB。</strong><br>问题2：如何向内存IC中写入1字节的数据？<br>解析：先通电，给VCC接入+5V，GND接入0V的电源；使用A0-A9的地址信号指定数据的存储场所，然后把数据的值输入给D0-D7的数据信号，最后把WR信号设定成1使能写模式。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/03/1799c43c67501406fb5649eab5c5678f89d040c7f7a0af02.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>总体来讲，内存IC内部有大量可以存储8位数据的地方，通过地址指定这些场所之后即可进行数据的读写。</p>
<p>4.2 内存的逻辑模型是楼房 </p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/03/e93ff135ef3ad213c5af007e9c2eeb9a5ded0594707ab01a.png" alt="" title="" class="">
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/03/2b58c1f5da55a4660944578c579e2832f73352d0ea701666.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>根据程序中所指定的变量的数据类型的不同，读写的物理内存大小也会随之发生变化。</p>
<p>4.3 简单的指针<br>&emsp;指针是一种变量，存储着数据的内存的地址。window上使用的程序通常是32位的内存地址，这种情况下，指针变量的长度也是32位。</p>
<p>char *d; short *e; long *f; //假设d,e,f的值都是100.</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/03/0cf78aa2b00b13024fc3e7dc25bc2bfdeb5fa5f4dcd14fc5.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>char、short、long这些数据类型在指针中表示的是，从指针存储的地址中一次能够读写的数据字节数</strong>。</p>
<p>4.4 数组是高效使用内存的基础<br>&emsp;数组是指多个同样数据类型的数据在内存中连续排列的形式。作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引（index）。（索引和内存地址的变换工作由编译器自动实现，有借助CPU中的的基址和变址寄存器）</p>
<p>&emsp;虽然是通过索引来使用数组，但这种内存的物理读写并没有特别在区别，因此很多程序都会在数组的使用上花费大量工夫。所以我们接下来了解一下栈、队列、代码清单和二叉查找树这些数组的变形方法，当然还要会灵活使用这些方法。</p>
<p>4.5 栈、队列以及环形缓冲区</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/03/9f686c3360201428d5154fd3dcc652f64241ecd86a87b6aa.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>4.6 链表使元素的追加和删除更加容易<br>4.7 二叉查找树使数据搜索更有效<br>（4.6和4.7将放在数据结构和算法中，这里就不论述了）</p>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 【程序是怎么跑起来的】 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【英语】计划]]></title>
      <url>/zhoujiabo.github.io/2020/04/03/%E3%80%90%E8%8B%B1%E8%AF%AD%E3%80%91%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>&emsp;今天又看了一遍朱伟老师考研英语的导学部分，感觉有种醍醐灌顶的感觉。这么多年的英语确实是学岔了，老是去死记单词，然后收效甚微，导致学英语的积极性很低落，可平时学一些专业的东西又要和英语打交道，英语也是算以后发展的一个阶段门槛，十分想学好却又不得门路（当然也有大佬底子强，暴力破解）。</p>
<p>先上笔记：</p>
<blockquote>
<p>1.英语，是一门不重意思而重情感的语言。（有时就算全部词都认识，但放在一起就难以理解）<br>2.学中文时我们不会天天背单词，而注重语境，同理，，，<br>3.多关注搭配和原句<br>4.词组搭配中的关键不在动词，而在介词。<br>5.所谓生词，不能脱口说出它的一到两个短语、用法。（这么说来不是生词没几个，确实让我随口用xx词说几句有些困难，，，）<br>6.背作文模板（X），如with the development of…, more and more,,,用了不少这样的句子，你可能自我感觉不错，但改卷老师见多，多即平庸，没有亮点，甚至会让人反感。<br>7.正确的写作姿势：tell story or ask question开头。并且学搭配，造句（和以前学中文那样）。<br>8.只背单词中文意思，英语注定学不好；要看英文解释+例句（英文环境），一般来说单词的英文是非常容易懂的。<br>9.少一些功利主义的追求，多一些不为什么的坚持<br>10.阅读，做到看了一遍之后，能复述main idea，说出全文的结构。双语阅读，先看中文，再看英文，多记搭配，造句。</p>
</blockquote>
<p>周计划：<br>&emsp;1.每天跟着朱伟老师学1~2小时的单词；<br>&emsp;2.每天进行一两次双语阅读，记词组搭配+自己造句；<br>&emsp;3.每周5发一篇周笔记。</p>
<p>找到了名师很开心，这次要打好英语底子，多积累。</p>
]]></content>
      
        <categories>
            
            <category> 英语 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言---是眼界窄还是情有独钟]]></title>
      <url>/zhoujiabo.github.io/2020/04/02/C%E8%AF%AD%E8%A8%80-%E6%98%AF%E7%9C%BC%E7%95%8C%E7%AA%84%E8%BF%98%E6%98%AF%E6%83%85%E6%9C%89%E7%8B%AC%E9%92%9F/</url>
      <content type="html"><![CDATA[<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/02/9618073ab90ef1b50b51ac84775631f1ca48675bdeba9a89.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>&emsp;今天在某乎上看到了上面的一个问题，第一个感觉就是，泥马，感觉和自己好像，，，EE专业，学了编程又学了ARM单片机，EE专业涉及的知识比较宽泛，硬件工程师职位少薪资较低，而互联网方面，自己又不是科班的（我也没转专业）。基本是在嵌入式和互联网徘徊。</p>
<p>&emsp;互联网方面，无论是前端的JS还是后端的JAVA,C++，或者是安卓开发，运维，感觉自己都不太合适；主要是觉得和自己现在学的东西有些脱节，而自己又没有下定决心跳入纯软行业（<em>自己内心已经有了选择？</em>）；因为自己现在学的东西，单片机，RTOS，linux等方面，C语言应用的也比较多，所以就想着找找C语言在互联网上的岗位信息。</p>
<p><u>感觉这不仅是我正在面临的问题，还是很多EE专业学生同样在迷茫的问题。</u></p>
<p>下面是某乎中关于上面问题的一些回答：</p>
<ol>
<li><p>你不是对C语言和计算机底层情有独钟，纯粹是你眼界太窄、偏见太重、固执己见甚至叶公好龙罢了</p>
</li>
<li><p>看不出题主对C/C++有多大热情，冒昧的猜一下，题主是不是觉得学好C/C++和Python就天下无敌，下可搞嵌入式，系统编程，高性能服务器，上可搞web开发，机器学习，如果是这样想，那一般最后的结果就是啥都搞不好</p>
</li>
<li><p>你现在喜欢C,主要还是因为你比较熟悉C.等你眼界开阔了,你就知道,都是工具.将来主要还是看你要做什么工作,这样的工作适合用什么语言来写.</p>
</li>
<li><p>年轻人不要想太多。你现在喜欢C,主要还是因为你比较熟悉C.等你眼界开阔了,你就知道,都是工具.将来主要还是看你要做什么工作,这样的工作适合用什么语言来写.大学四年很珍贵,希望你以成为一个工程师为目标,而不是C工程师,Python工程师亦或其他.</p>
</li>
<li><p>C语言应该在偏硬件的领域，比如单片机或者嵌入式中还有比较多的应用，纯后端服务器开发用C的应该很少了。有不少网络基础设施的库是C写的，但是你如果只是写应用用C写太累了，然后C 加Python确实是利器，但是另一方面，需要用这个利器解决问题的场合确实不多。作为一个学生，千万不要让用什么语言限制了自己的眼界。就算你对C情有独钟，也要考虑市场需要，即便将来你自己创业还要考虑团队水平。</p>
</li>
<li><p><strong>工程师是道，语言是术，大学应多学道，而不是术，这是和技校的区别</strong>。</p>
</li>
<li><p>如果你真的对c和底层感兴趣，可以尝试转向信息安全方面，现在国家大力扶持信息安全行业的发展，安全行业很缺人才，尤其是搞软件安全，二进制漏洞挖掘方面。这方面正好符合你的胃口，对c语言，对计算机底层，汇编语言，有着很高的要求，你可以尝试向软件逆向，漏洞挖掘方面走。</p>
</li>
<li><p>研究和学习C语言与系统底层，未来发展的方向必然不是那种随处可见的面向消费者的IT公司，而是像阿里云基础架构部门、系统软件提供商等等to B的部门；另一方面偏向硬件的有未来的智能硬件、嵌入式系统之类的。深入学习C语言；服务器；计算机底层。考虑上面三个条件，坚持走这条路的话，楼主必然要涉及这二者：Linux（应用、驱动、内核）；ACM竞赛。</p>
</li>
</ol>
<p>咋说呢，感觉都占了一点；对C有点是因为熟悉，有点是喜欢，但也不排除偏见的可能。</p>
<blockquote>
<p>心情复杂，对EE专业又爱又恨。有接触硬件层，又接触软件层，可玩硬件渣本学历玩不动，玩软件又不是专业的；还有一些些舍不得单片机。</p>
</blockquote>
<p>不过不管怎么说都要打好C的基础，无论是后面转行，还是继续在单片机相关的职业，C语言学扎实了，学其它语言也会事半功倍，而且C在微机控制上也十分重要。</p>
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
            <category> 话题类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 话题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter3: 计算机进行小数运算时出错的原因]]></title>
      <url>/zhoujiabo.github.io/2020/04/01/chapter3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%9B%E8%A1%8C%E5%B0%8F%E6%95%B0%E8%BF%90%E7%AE%97%E6%97%B6%E5%87%BA%E9%94%99%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      <content type="html"><![CDATA[<p>问题：<br>    &emsp;1. 二进制数0.1，用十进制数表示的话是多少？<br>    &emsp;2. 用小数点后有3位的二进制数，能表示十进制数0.625吗？<br>    &emsp;3. 将小数分为符号、尾数、基数、指数4部分进行表现的形式称为什么？<br>    &emsp;4. 二进制数的基数是多少？<br>    &emsp;5. 通过把0作为数值范围的中间值，从而在不使用符号位的情况下来表示负数的表示方法称为什么？<br>    &emsp;6. 10101100.01010011这个二进制数，用十六进制数表示的话是多少？</p>
<p>答案：<br>    &emsp;1. 2^(-1) = 0.5<br>    &emsp;2. 能0.101<br>    &emsp;3. 浮点数<br>    &emsp;4. 2<br>    &emsp;5. EXECESS系统表现<br>    &emsp;6. AC.53<br>    <br><br>解析：<br>&emsp;3、浮点数是指把小数用“符号 尾数 x 基数的指数次幂”这种形式来表示。<br>&emsp;4、十进制的基数是10，二进制的基数是2；类推，xx进制的基数就是xx。<br>&emsp;5、EXCESS是”剩余”的意思。如把01111111看作是0的话，比这个数小的01111110就是-1</p>
<p><big><strong>计算机不会出现计算错误?</strong></big></p>
<p>3.1 将0.1累加100次</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> sum;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;100;i++)</span><br><span class="line">        sum += 0.1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f"</span>,sum);    ---得到10.000002</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.2 用二进制数表示小数</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/cb24b4b9d230927c0b51902a4b192d44a9beaf5a57b1358b.png" alt="" title="" class="">
                <p></p>
            </figure>    
<p>3.3 计算机运算出错的原因<br><strong>—有一些十进制的小数无法转换成二进制数</strong><br>如十进制数0.1，就无法用二进制数正确表示。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/bd5f97ef664a25febae9eee9fe5168d12d004c94fe2355e8.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>&emsp;无论怎么增加二进制小数点后面的位数，怎么拼凑，都无法相加得到1/10这个结果。实际上，十进制数转换成二进制数后，会变成0.00011001100……(1100循环)这样的循环小数。这和无法用十进制数来表示1/3的道理差不多。</p>
<p>&emsp;因为无法正确表示数值，最后都变成了近似值。计算机在遇到循环小数时会根据变成数据类型所对应的长度将数值从中间截断或者四舍五入。</p>
<p>3.4 什么是浮点数<br>&emsp;像1011.0011这样带小数点的表现形式，完全是纸面上的二进制数表现形式，在计算机内部是无法使用的。<br>&emsp;两种表示小数的数据类型，分别是双精度浮点数(64bit)和单精度浮点数(32bit)。</p>
<blockquote>
<p>浮点数是指用符号、尾数、基数和指数这部分来表示的小数。因为计算机内部使用的是二进制数，所以基数自然就是2，因此实际的数据中往往不考虑基数。</p>
</blockquote>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/b5c5329ef40bf6a66480829573add2b92831774274550478.png" alt="" title="" class="">
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/7a0cc64f1176f1bd9147989e6c152203b614d74f302eeb16.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>符号部分是符号位（1表示负数，0表示正或’0’）；<br>尾数部分用的是”将小数点前面的值固定为1的正则表达式”；<br>指数部分用的则是”EXCESS系统表现”。</p>
<p>3.5 正则表达式和EXCESS系统</p>
<blockquote>
<p>按照特定的规则来表示数据的形式即为正则表达式。除了小数之外，字符串以及数据库等，也都有各自的正则表达式。</p>
</blockquote>
<p>&emsp;将小数点前面的值固定为1的正则表达式，具体来讲，就是将二进制数表示的小数左移或右移(这里指逻辑移位)数次后，整数部分的第1位变为1。而且第1位在实际的数据中不保存。由于第1位必须是1，因此，省略该部分后就节省了一个数据位，从而也就可以表示更多的数据范围。如单精度浮点数中尾数部分实际上可以表示23+1位的数值。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/3b8e8e483ae805ed494edc29e2c509d6550c4badc3e5f6a5.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;<strong>EXCESS系统表现是指，将指数部分表示范围的中间值设为0，使得负数不需要用符号来表示</strong>。当指数部分是8位单精度浮点数时，最大值11111111=255的1/2，即127表示0。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/7779f51e02d51f13fc21c19f1d254718f69c2e67e2c9c0ec.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>3.6 在实际的程序中进行确认</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"><span class="comment">#include "string.h"</span></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> data; //32位</span><br><span class="line">    unsigned long buff;</span><br><span class="line">    int i;</span><br><span class="line">    char s[35];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将0.75以单精度浮点数的形式存储在变量data中</span><br><span class="line">    data = (<span class="built_in">float</span>)0.75;</span><br><span class="line">    //将数据复制到4字节长度的整数变量buff中以逐个提取出每一位</span><br><span class="line">    memcpy(&amp;buff,&amp;data,4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //提取出每一位</span><br><span class="line">    <span class="keyword">for</span>(i=33;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==1||i==10)</span><br><span class="line">            s[i] = <span class="string">'-'</span>;//用破折号区分符号部分、指数部分和尾数部分</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buff % 2 == 1)</span><br><span class="line">                s[i] = <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[i] = <span class="string">'0'</span>;</span><br><span class="line">            buff /= 2;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    s[34] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,s);    //0-01111110-10000000000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>十进制数0.75，在计算机内部的单精度浮点数表现形式为0-01111110-10000000000000000000000。</p>
<blockquote>
<p>其中0为符号部分，表示正数；<br>01111110为指数部分，转换成十进制数后是126，在EXCESS系统下表示的是126-127 = -1；<br>10000000000000000000000为尾数部分，表示的是1.以后的部分，也就是1.10000000000000000000000<br>该数据用二进制数表示为1.1 x 2^(-1)。</p>
</blockquote>
<p>3.7 如何避免计算机计算出错<br>&emsp;计算机计算出错的原因之一是，采用浮点数来处理小数（另外，也有因”位溢出“而造成计算错误的情况）。作为程序的数据类型，不管是使用单精度浮点数还是双精度浮点数，都存在计算出错的可能性。下面介绍两种避免该问题的方法：<br>&emsp;<strong>1. 回避策略，即无视这些错误</strong>。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题。<br>&emsp;<strong>2. 把小数转换成整数来计算</strong>。拿之前的例子来说，可以0.1扩大10倍后再将1相加100次，最后把结果除以10即可。在涉及到财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD码方法，以确保最终得到准确的数值。</p>
<p>3.8 二进制和十六进制</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/7de29c354aba015816351be6993268e44f53b4bb94a7604f.png" alt="" title="" class="">
                <p></p>
            </figure>

]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag>   </tag>
            
            <tag> 程序是怎么跑起来的 </tag>
            
            <tag> 小数运算出错 </tag>
            
            <tag> 浮点数表式方法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter2: 数据是用二进制数表示的]]></title>
      <url>/zhoujiabo.github.io/2020/04/01/Untitled/</url>
      <content type="html"><![CDATA[<p>问题：<br>    1. 32位是几个字节？<br>    2. 二进制数01011100转换成十进制数是多少？<br>    3. 二进制数00001111左移两位后，会变成原数的几位？<br>    4. 补码形式表示的8位二进制数11111111，用十进制数表示的话是多少？<br>    5. 补码形式表示的8位二进制数10101010，用16位的二进制数表示的话是多少？<br>    6. 反转部分图形模式时，使用的是什么逻辑运算？<br>答案：<br>    1. 4字节<br>    2. 92<br>    3. 4<br>    4. -1<br>    5. 1111111110101010<br>    6. XOR运算</p>
<p> 解析：<br>4、负数的反码 = 符号位不变，其余位取反；其补码 = 反码 + 1<br>5、100000000（9bit）- 10101010 = 01010110（原码的绝对值），原码的绝对值+补码 = 2^n，n为位数。<br>6、异或运算只反转与1相对应的位。</p>
<blockquote>
<p>要想对程序的运行机制形成一个大致印象，就要了解信息（数据）在计算机内的是以怎样的形式来表现的，又是以怎样的方法进行运算的。</p>
</blockquote>
<p>C语言中，数值、字符串和图像等信息在计算机内部都是以二进制数值的形式来表现的。</p>
<p>2.1 用二进制数表示计算机信息的原因<br>    计算机内部是由IC这种电子部件构成。之前介绍的CPU和内存也是IC的一种。而IC中所有引脚只有高电平和低电平两种状态（暂不考虑不接收电流信号的高阻抗状态），这个特性决定了计算机信息数据只能用二进制数来处理。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/4a6a711299f748f438f245a81cabd199c2f6f7e79b8dcd44.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>IC是集成电路（Integrated Circuit）的简称，有模拟IC和数字IC两种；本章指的是数字IC。</p>
<p>计算机信息处理的最小单位是位（bit）；二进制数的位数一般是8位、16位、32位，，，也就是8的倍数，这是因为计算机所处理的信息的基本单位是8位二进制数（一个字节）。内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据，因此，字节是信息的基本单位。</p>
<p>用字节单位处理数据时，如果数字小于存储数据的字节数（=二进制数的位数），那么高位上就用0填补。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/cb24b4b9d230927c0b51902a4b192d44a9beaf5a57b1358b.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>程序中，即使是用十进制数和文字等记述信息，在编译后也会转换成二进制数的值。对于二进制数表示的信息，计算机不会区分它是数值、文字不是某种图片的模式，而是根据编写程序的各位对计算机发出指令来进行信息的处理（运算）。</p>
<p>2.2 什么是二进制数<br>    数值表示的就是构成数值的各数位的数值和位权相乘后再相加的结果。例如39这个十进制数，表示的就是3与9两个数值分别和它们的位权10与1相乘再相加的结果。</p>
<p>数字的位数不同，位权也不同，第一位（最右边的一位）是xx的0次幂，第二位是xx的1次幂，，，依此类推；其中xx称为基数，十进制的基数是10，二进制的基数是2.<br>故用二进制数00100111表示十进制数39，是因为(0x128)+(0x64)+(1x32)+(0x16)+(0x8)+(1x4)+(1x2)+(1x1)=39。</p>
<p>2.3 移位运算和乘除运算的关系<br>    十进制数左移后会变成原来的10倍，100倍，1000倍，，，同样，二进制数左移后就会变成原来的2倍，4倍，8倍，，，反之二进制数右移后则会变成原来的1/2，1/4，1/8，，，因此，移位运算能代替乘法运算和除法运算。</p>
<p>2.4 便于计算机处理的“补数”<br>    二进制表示负数值时，最高位作为符号来使用，符号位是0时表示正数，为1时表示负数。负数补码求解：反码+1。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/f53ba4229106832c611ba8a82cbaa1a4e1db917ee7296684.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>法则：将二进制数的值取反加1的结果和原来的值相加，结果为0。<br>例如：求-12的8位二进制数的补码表示为 1 1110011 + 1 = 11110100（加上0000 1100 = 0）</p>
<p>char占一个字节（8位），unsigned char的数值范围为0<del>255共256位；而char的范围为[-128，127]，其中-1 ~ -128负数部分有128位，占一半；而0</del>127包含在另一半（虽然0不是正数）。</p>
<blockquote>
<p>char a = -129;<br>printf(“%d”,a);//打印127<br>//为什么 —127 + |-129| = 2^8<br>//同理，a赋值为128，打印得-128</p>
</blockquote>
<p>2.5 逻辑右移和算术右移的区别<br>逻辑右移：移位后在最高位补0；<br>算术右移：移位后在最高位填充移位前符号位的值；</p>
<blockquote>
<p>11001011 逻辑右移2位得到00110010，算术右移2位得到11110010<br>补充：只有右移时才必须区分逻辑位移和算术位移。</p>
</blockquote>
<p>如果数值是用实数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2，1/4，1/8等的数值运算，如果是正数，只需在最高位补0即可。(即，补符号位的值)</p>
<p>符号扩充：在保持值不变的前提下，扩充位数。<br>—用符号位的值（1或0）填充高位即可。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/04/01/62e9e5845ad2ddf065fd25c46e9d09cc70d07f405ab28291.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>2.6 掌握逻辑运算的窍门<br>    将二进制数表示的信息作为四则运算的数值来处理就是算术；而像图形模式那样，将数值处理为单纯的0和1的罗列就是逻辑。<br>    计算机能处理的运算，大体可分为算术运算和逻辑运算。算术运算是指加减乘除四则运算；<strong>逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非NOT，逻辑与AND，逻辑或OR和逻辑异或XOR四种</strong>。</p>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序是怎么跑起来的 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chapter1: 对程序员来说CPU是什么？]]></title>
      <url>/zhoujiabo.github.io/2020/03/28/%E3%80%90%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%91-day01/</url>
      <content type="html"><![CDATA[<p><strong>前言：</strong><br><br>&emsp;&emsp;有各种IDE，图形化操作界面，大大提高了计算机操作的便利性；但我们在享受这些方便的同时也付出了代价。虽然拥有一定的编程能力，却无法进一步提高自身技能，知识应用能力的不足导致无法编写源程序。原因在于，大家不了解程序运行的根本机制。<br>&emsp;&emsp;“双击程序图标，程序开始运行”，作为一句程序员，对程序的了解仅仅停留在这一表层是不行的。我们还应该了解更深层的机制：加载到内存中的机器语言程序，由CPU进行解析和运行，进而计算机系统整体的控制和数据运算也开始运行。了解了程序的运行机制后，就能找到编写源程序的方法。<br></p>
<p>第一章：对程序员来说CPU是什么？</p>
<p>问题：<br>    1. 程序是什么<br>    2. 程序是由什么组成的<br>    3. 什么是机器语言<br>    4. 正在运行的程序存储在什么位置<br>    5. 什么是内存地址<br>    6. 计算机的构成元件中，负责程序的解释和运行的是哪个</p>
<p>答案：<br>    1. 指示计算机每一步动作的一组指令<br>    2. 指令和数据<br>    3. CPU可以直接识别并使用的语言<br>    4. 内存<br>    5. 内存中，用来表示命令和数据存储位置的数值<br>    6. CPU</p>
<p>解析：<br>    1. 一般所说的程序，譬如运行会、音乐会的程序等，指的是“做事的先后次序”，计算机程序也是一样的道理。<br>    2. 程序是指令和数据的组成体。例如printf(“hello”);这个简单程序，printf是指令，”hello”是数据。<br>    3. <strong>CPU能够直接识别和执行的只有机器语言</strong>，使用C、JAVA编写的程序，最后都会转化成机器语言。<br>    4. <strong>硬盘和磁盘等媒介上保存的程序被复制到内存后才能运行</strong>。<br>    5. <strong>内存中保存命令和数据的场所，通过地址来标记和指定</strong>；地址由整数值表示。<br>    6. 计算机的构成中，根据程序的指令来进行数据运算，并控制整个计算机的设备称作CPU。<br><br><br>1.1 CPU的内部结构解析：<br>如图为程序运行的一般流程：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/28/6469f8bf0c5c06b2f161df621835c5e22a84075513c8416e.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>CPU所负责的就是解释和运行最终转换成机器语言的程序内容。<br><br><br>CPU和内存是由许多晶体管组成的电子部件，通常称为IC( integrated circuit，集成电路 )。从功能方面来看，<u>CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通</u>。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/28/ba903da0327e18bb37860986402db27eaa74d9f3a3908cd4.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>①寄存器：有限存贮容量的高速存贮部件，用来暂存指令、数据等处理对象。</p>
<blockquote>
<p>   寄存器的功能是存储二进制代码，它是由具有存储功能的锁存器或触发器组合起来构成的（一个锁存器或触发器可以存储1位二进制代码，故存放n位二进制代码的寄存器，需要用n个锁存器或触发器来构成。）<br>补充：锁存器和触发器<br>A. 每个锁存器或触发器都能存储1位二值信息<br>B. 锁存器是对脉冲电平敏感的电路；触发器是对时钟脉冲边沿敏感的电路。</p>
</blockquote>
<p>②控制器：负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机<br>③运算器：负责运算从内存读入寄存器的数据<br>④时钟：负责发出CPU开始计时的时钟信号。时钟信号的频率越高，CPU的运行速度越快，有些计算机的时钟位于CPU的外部。</p>
<p>主存：计算机主存储器的简称。主存通过控制芯片等与CPU相连，主要负责存储指令和数据。注意，主存中存储的指令和数据会随着计算机的关机而自动清除（主存通常使用DRAM芯片）。</p>
<blockquote>
<p>   程序启动后，根据时钟信号，控制器会从内存中读取指令和数据到寄存器；通过对这些指令加以解释和运行，运算器就会对寄存器中的数据进行运算，控制器根据该运算结果来控制计算机。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序是怎么跑起来的 </tag>
            
            <tag> CPU内部结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python语法2]]></title>
      <url>/zhoujiabo.github.io/2020/03/26/python%E8%AF%AD%E6%B3%952/</url>
      <content type="html"><![CDATA[<p>if语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"zhou"</span></span><br><span class="line">is_male = True</span><br><span class="line">is_tall = False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"zhou"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"welcome to "</span> + name)</span><br><span class="line">    <span class="keyword">if</span> is_male and is_tall:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"you are a tall male"</span>)</span><br><span class="line">    <span class="keyword">elif</span> is_male and not(is_tall):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"you are a male but not tall"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"you are a female"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"you are not zhou"</span>)</span><br><span class="line">```    </span><br><span class="line">   </span><br><span class="line">简易计算器： </span><br><span class="line">```bash</span><br><span class="line">num1 = <span class="built_in">float</span>(input(<span class="string">"enter a number: "</span>))</span><br><span class="line">op = input(<span class="string">"enter a operator: "</span>)</span><br><span class="line">num2 = <span class="built_in">float</span>(input(<span class="string">"enter another number: "</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> op == <span class="string">"+"</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1 + num2)</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">"-"</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1 - num2)</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">"*"</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1 * num2)</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">"/"</span>:</span><br><span class="line">    <span class="built_in">print</span>(num1 / num2)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"invalid operator"</span>)</span><br><span class="line">```   </span><br><span class="line">&lt;br&gt;   </span><br><span class="line">   </span><br><span class="line">**字典dict** : </span><br><span class="line">```bash</span><br><span class="line">monthtraslate = &#123;</span><br><span class="line"><span class="comment">#关键字 : 关联内容，一一对应</span></span><br><span class="line">    <span class="string">"Jan"</span> : <span class="string">"January"</span>,</span><br><span class="line">    <span class="string">"Feb"</span> : <span class="string">"February"</span>,</span><br><span class="line">    <span class="string">"Mar"</span> : <span class="string">"March"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(len(monthtraslate))     <span class="comment">#计算元素个数</span></span><br><span class="line"><span class="built_in">print</span>(monthtraslate[<span class="string">"Jan"</span>])   <span class="comment">#通过关键查找相关内容</span></span><br><span class="line"><span class="built_in">print</span>(monthtraslate.get(<span class="string">"Jan"</span>))</span><br><span class="line"></span><br><span class="line">monthtraslate[<span class="string">"Jun"</span>] = <span class="string">"June"</span>   <span class="comment"># 字典中没有，添加内容</span></span><br><span class="line">monthtraslate[<span class="string">"Jan"</span>] = <span class="string">"1111"</span>   <span class="comment"># 字典中已有，修改内容</span></span><br><span class="line">del monthtraslate[<span class="string">"Feb"</span>]        <span class="comment"># 删除内容</span></span><br><span class="line">monthtraslate.clear()           <span class="comment"># 清空字典</span></span><br><span class="line"><span class="built_in">print</span>(monthtraslate)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字可以是字符串，数字或者是元组，但不能用列表</span></span><br><span class="line"><span class="comment">#关联的内容可以是列表</span></span><br><span class="line"><span class="comment">#monthtraslate["Oct"] = [123, "M322", "adf"]</span></span><br><span class="line"><span class="comment">#通过monthtraslate["Oct"][2]访问列表中的"adf"</span></span><br></pre></td></tr></table></figure>

<p>while语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#猜字</span></span><br><span class="line">secret = <span class="string">"zhou"</span></span><br><span class="line">guess = <span class="string">""</span></span><br><span class="line">guess_count = 0</span><br><span class="line">guess_limit = 4</span><br><span class="line">out_of_guess = False</span><br><span class="line"><span class="keyword">while</span> guess != secret and not(out_of_guess):</span><br><span class="line">    <span class="keyword">if</span>(guess_count &lt;= guess_limit):</span><br><span class="line">        guess_count += 1</span><br><span class="line">        guess = input(<span class="string">"enter guess: "</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        out_of_guess = True</span><br><span class="line"><span class="keyword">if</span> out_of_guess:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"out of game, you are lose"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"you are win!"</span>)</span><br></pre></td></tr></table></figure>

<p>for语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">friends = [<span class="string">"jim"</span>, <span class="string">"ken"</span>, <span class="string">"lisa"</span>]</span><br><span class="line"><span class="comment">#for friend in friends:</span></span><br><span class="line"><span class="comment">#print(friend)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#for index in range(10):    # [0,10)</span></span><br><span class="line"><span class="comment">#for index in range(3, 10):  # [3,10)</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(friends)):</span><br><span class="line">    <span class="built_in">print</span>(friends[index])</span><br><span class="line"></span><br><span class="line"><span class="comment">#num = 2**3  #指数运算，2^3</span></span><br><span class="line">def raise_to_power(base_num, pow):</span><br><span class="line">    result = 1</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(pow):</span><br><span class="line">        result = result*base_num</span><br><span class="line">    <span class="built_in">return</span>  result</span><br><span class="line"><span class="built_in">print</span>(raise_to_power(3,3))</span><br></pre></td></tr></table></figure>

<p>multi-list:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">num_grid = [</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [4, 5, 6],</span><br><span class="line">    [7, 8, 9],</span><br><span class="line">    [0],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(num_grid[3][0])</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> num_grid:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">```   </span><br><span class="line">--------------------------------------------------------- </span><br><span class="line">try语句：</span><br><span class="line">```bash</span><br><span class="line">try:</span><br><span class="line">    <span class="comment"># a = 10/0</span></span><br><span class="line">    number = int(input(<span class="string">"enter a num: "</span>))</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">except ZeroDivisionError as err:</span><br><span class="line">    <span class="built_in">print</span>(err)</span><br><span class="line">except ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"invalid input"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应用场景：把可能发生错误的语句放在try模块里，用except来处理异常。except可以处理一个专门的异常，如果except后没有指定异常，则默认处理所有的异常。每一个try，都必须至少有一个except；<br>补充用法：<br>try ….except…else — 当没有异常发生时，else中的语句将会被执行<br>try …finally — 无论异常是否发生，在程序结束前，finally中的语句都会被执行</p>
</blockquote>
<br> 
加密小游戏：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def translator(phrase):</span><br><span class="line">    translation = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> phrase:</span><br><span class="line">        <span class="keyword">if</span> letter.lower() <span class="keyword">in</span> <span class="string">"aeiou"</span>:</span><br><span class="line">            <span class="keyword">if</span> letter.isupper():</span><br><span class="line">                translation = translation + <span class="string">'G'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                translation = translation + <span class="string">'g'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            translation = translation + letter</span><br><span class="line">    <span class="built_in">return</span> translation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(translator(input(<span class="string">"enter a phrase: "</span>)))</span><br><span class="line">```    </span><br><span class="line">---------------------------------------------------------</span><br><span class="line">多文件：</span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#mdl文件中定义一些常用的数据或函数</span></span><br><span class="line">B = [11, 42, 4, 12]</span><br><span class="line">def array_sum(A):</span><br><span class="line">    s = 0</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        s += i</span><br><span class="line">    <span class="built_in">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment">#main文件中引入</span></span><br><span class="line">import mdl</span><br><span class="line">A = mdl.B.copy()</span><br><span class="line"><span class="built_in">print</span>(mdl.array_sum(A))</span><br></pre></td></tr></table></figure>
-------------------------------------------
**类和对象**
例1：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Student文件</span></span><br><span class="line">class Student:</span><br><span class="line">    def __init__(self, name, major, gpa, is_on_probation):</span><br><span class="line">    self.name = name</span><br><span class="line">    self.major = major</span><br><span class="line">    self.gpa = gpa</span><br><span class="line">    self.is_on_probation = is_on_probation</span><br><span class="line"></span><br><span class="line"> def is_on_honor_roll(self):</span><br><span class="line">    <span class="keyword">if</span> self.gpa &gt;= 4.0:</span><br><span class="line">        <span class="built_in">return</span> True</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="comment">#main文件</span></span><br><span class="line">from Student import Student    <span class="comment"># 从xxx文件导入xxx类</span></span><br><span class="line">stu1 = Student(<span class="string">"jim"</span>, <span class="string">"business"</span>, 3.5, False)</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="built_in">print</span>(stu1.is_on_probation)</span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Question文件</span></span><br><span class="line">class Question:    </span><br><span class="line">	def __init__(self, prompt, answer):        	   	   self.prompt = prompt        </span><br><span class="line">    	self.answer = answer</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">#main文件</span></span><br><span class="line">from Question import Question</span><br><span class="line">question_prompt = [</span><br><span class="line">        <span class="string">"what color is the sky?\n(a)blue\n(b)green\n(c)yellow\n"</span>,</span><br><span class="line">        <span class="string">"most of asian skin is yellow?\n(a)False\n(b)True\n"</span>,</span><br><span class="line">        <span class="string">"can fish breath in air?\n(a)False\n(b)True\n(c)i don't konw\n"</span></span><br><span class="line">    ]</span><br><span class="line">quests = [   <span class="comment">#对象</span></span><br><span class="line">        Question(question_prompt[0], <span class="string">"a"</span>),</span><br><span class="line">        Question(question_prompt[1], <span class="string">"b"</span>),</span><br><span class="line">        Question(question_prompt[2], <span class="string">"a"</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run_test(questions):</span><br><span class="line">    score = 0</span><br><span class="line">    <span class="keyword">for</span> question <span class="keyword">in</span> questions:</span><br><span class="line">        answer = input(question.prompt)</span><br><span class="line">        <span class="keyword">if</span> answer == question.answer:</span><br><span class="line">            score += 1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"you got "</span> + str(score) + <span class="string">"/"</span> + str(len(questions)) + <span class="string">" correct."</span>)</span><br><span class="line"></span><br><span class="line">run_test(quests)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>继承：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基类</span></span><br><span class="line">class chef:</span><br><span class="line"></span><br><span class="line">    def make_soup(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"the chef can make soup"</span>)</span><br><span class="line">    def make_salad(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"the chef can make salad"</span>)</span><br><span class="line">    def make_specialty(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"the chef can make barbecue"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#派生类</span></span><br><span class="line">from chef import chef</span><br><span class="line">class chinesechef(chef):        <span class="comment"># 继承</span></span><br><span class="line"></span><br><span class="line">    def make_specialty(self):   <span class="comment"># 派生类能修改基类的内容</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"the chef can make noodle"</span>)</span><br><span class="line">    def make_fired_rice(self):  <span class="comment"># 派生类独有的内容</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"the chef can make fired rice"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#main文件</span></span><br><span class="line">from chinesechef import chinesechef</span><br><span class="line"></span><br><span class="line">mychef = chinesechef()      <span class="comment"># 创建对象</span></span><br><span class="line">mychef.make_soup()          <span class="comment"># 基类的成员函数</span></span><br><span class="line">mychef.make_specialty()     <span class="comment"># 调用派生类中修改过的成员函数</span></span><br><span class="line">mychef.make_fired_rice()    <span class="comment"># 调用派生类中新增的成员函数</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法介绍与例子分析]]></title>
      <url>/zhoujiabo.github.io/2020/03/25/%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BE%8B%E5%AD%90%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/25/b3eb4fe01a5b2b25cacfb847d9afa29309ab16f5b6cfad49.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>算法工作特点：<br>    工作内容主要是设计和分析算法，不关心硬件和操作系统，没有固定的语法和编程语言，可能需要其它相关领域（金融、物理、电子。。。）的知识。</p>
<p>分析层面和标准(criteria)：</p>
<blockquote>
<p>time<br>sapce<br>network consumption<br>power<br>CPU registers</p>
</blockquote>
<p>算法设计的特点：<br>    Input        —— none or more<br>    Output     —— at least one<br>    definitence     —— 确定性<br>    finitness    —— 有限性<br>    effectiveness   —— 效能</p>
<blockquote>
<p>rule: each statement take one unit of time<br>u =  7<em>x + 2</em>y;    — O(1)</p>
</blockquote>
<p><strong>loop analysis:</strong><br><br>case 1: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">algorithm sum(A,n)    ---A is an array</span><br><span class="line">&#123;</span><br><span class="line">        s = 0;        --- 1</span><br><span class="line">    <span class="keyword">for</span>(i=0; i&lt;n; i++)    ---n+1</span><br><span class="line">    &#123;</span><br><span class="line">        s += A[i];        ---n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> s;    --- 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(n) = 2n+3  --- O(n)</span><br><span class="line">s(n) = n+3</span><br></pre></td></tr></table></figure>

<p>case 2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(A,B,n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=0; i&lt;n; i++)&#123;			--- n+1</span><br><span class="line">        <span class="keyword">for</span>(j=0;j&lt;n;j++)&#123;		--- n*(n+1)</span><br><span class="line">		C[i][j] = A[i][j] + B[i][j];	--- n*n </span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(n) = 2n^2+2n+1	--- O(n^2)</span><br><span class="line">s(n) = 3n^2+3</span><br></pre></td></tr></table></figure>

<p>//分析时间复杂度，只看最大的量级，忽略其它细节</p>
<p>case 3:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=0;i&lt;n;i++)&#123;		</span><br><span class="line">	<span class="keyword">for</span>(j=0;j&lt;i;j++)&#123;	</span><br><span class="line">		statement;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">f(n) = 1+2+3+4+……+n = n*(n+1)/2 ---O(n^2)</span><br></pre></td></tr></table></figure>

<p>case 4:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = 0;</span><br><span class="line"><span class="keyword">for</span>(i=0;p&lt;=n;i++)</span><br><span class="line">	p++;</span><br><span class="line">	</span><br><span class="line">assume p = 1+2+3+……+k &gt; n (i计数到k)</span><br><span class="line">即k*(k+1)/2=n —— 得k &gt; n^(1/2)</span><br><span class="line">所以O( n^(1/2) )</span><br></pre></td></tr></table></figure>

<p>case 5:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=1;i&lt;n;i=i*2)</span><br><span class="line">	statement;</span><br><span class="line">    </span><br><span class="line">assume 2^k &gt;= n</span><br><span class="line">k = log2(n) --- O(logn)	//以下的logn指的是log2(n)</span><br></pre></td></tr></table></figure>

<p>case 6:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=n;i&gt;=1;i=i/2)</span><br><span class="line">	statement;</span><br><span class="line">	</span><br><span class="line">assume n/(2^k) &lt; 1</span><br><span class="line">n &lt; 2^k	→ k&gt;logn --- O(logn)</span><br></pre></td></tr></table></figure>

<p>case 7:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = 0;</span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;n;i=i*2)	①</span><br><span class="line">	p++;</span><br><span class="line"><span class="keyword">for</span>(j=1;j&lt;p;j=j*2)	②</span><br><span class="line">	statement;</span><br><span class="line">    </span><br><span class="line">先看②, assume j=1*2*2……*2=2^k = p </span><br><span class="line">k = logp;</span><br><span class="line">再看①, <span class="keyword">while</span> i=1*2*2……*2=2^p = n </span><br><span class="line">p = logn;</span><br><span class="line">所以，k = <span class="built_in">log</span>(logn)	--- O(loglogn)</span><br></pre></td></tr></table></figure>
<p>case 8:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=1;i&lt;n;i++)&#123;		--- n</span><br><span class="line">	<span class="keyword">for</span>(j=1;j&lt;n;j=j*2)&#123;	--- n*log2(n) </span><br><span class="line">		statement;		--- (n-1)*log2(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">f(n) = 2nlogn+n-logn	--- O(nlogn)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 算法类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言 知识补漏1]]></title>
      <url>/zhoujiabo.github.io/2020/03/25/C%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E8%A1%A5%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>1、64位系统指针的sizeof为8<br>char *a;<br>printf(“%d\n”,sizeof(a)); //8</p>
<p>2、return read == write;<br>等同于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span> == write)</span><br><span class="line">	<span class="built_in">return</span> 1;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	<span class="built_in">return</span> 0;</span><br></pre></td></tr></table></figure>

<p>3、*elem=p-&gt;data与elem=&amp;p-&gt;data<br>*elem=p-&gt;data：修改的是elem指针所指向地址存放的数据<br>elem=&amp;p-&gt;data：修改的是elem指针指向的地址。</p>
<p>4、结构体初始化错误<br>参考：<a href="https://www.cnblogs.com/Fsiswo/p/9291458.html" target="_blank" rel="noopener">https://www.cnblogs.com/Fsiswo/p/9291458.html</a><br>结构体指针初始化必须赋予一个有效地址，才能进行正常的操作<br>结构体声明和定义其实就是在堆上申请一段连续内存，而如果只是对结构体指针赋 0或NULL，是让其指向内存地址0X0000的地方。这里不可读不可写！！！</p>
<p>5、printf在循环中打印两次（输入输出流问题）<br>找的一些回答：</p>
<blockquote>
<p>可能是缓冲区东西读多了<br>是的，这个要考虑到缓冲区，对于这个例子中，只要把那个在缓冲区保留enter 键用getchar（）读走就可以了<br>因为scanf已经把回车字符读进去了，再清空缓存就没意义了，fflush(stdin)在scanf之前加就好了 </p>
</blockquote>
<p>while(i != 5)<br>{<br>    scanf(“%c”,&amp;a);<br>    printf(“%d\n”,++i);<br>}<br>//<strong>scanf同时会把’\n’读进去</strong>，所以本来输入5次的，结果只输入了3次就退出循环了。<br>在scanf前面加入fflush(stdin);能解决这个问题。</p>
<p>但MSDN 文档写明<strong>“fflush on input stream is an extension to the C standard”</strong><br>并非所有编译器都支持这个功能（linux 下的 gcc 就不支持）</p>
<p>C99 对 fflush 函数的定义：<br>    int fflush(FILE *stream);<br>    如果 stream 指向输出流或者更新流（update stream），<br>    并且这个更新流最近执行的操作不是输入，<br>    那么 fflush 函数将把这个流中任何待写数据传送至宿主环境（host environment）写入文件。<br>    否则（stream指向输入流stdin），它的行为是未定义的。</p>
<p><strong>虽然上面能用fflush(stdin)解决循环输入问题，但无论从移植性还是稳定性来说，都不应该用fflush。</strong><br>使用 scanf(“%*[^\n]”); 也可以清空输入流。<br>（和编译器也有关系，最好用标准C的方法）</p>
<p>6、特殊符号的ASCII码<br>printf(“%d %d %d\n”,’\0’,’\n’,’ ‘);<br>换行符的ascii码为10，空格的ascii码为32，结束符是0</p>
<p>7、L是结构体指针，ElemType* elem，elem是其中的数据单元;L-&gt;elem[1]是地址还是数据？<br>L-&gt;elem是地址, 如数组名; 所以L-&gt;elem[1]是数据元素。</p>
<p>8、链表数据结构定义，好像用到了二维指针，可不可以不用。。。</p>
<blockquote>
<p>二维指针例子：<br> char <em>a[2] = {“123”,”456”};//a是指针数组，a[0]=”123”<br> char *</em>p=a;//p为指针数组首地址，<em>p为指定”123”的指针，*</em>p为1。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"><span class="comment">#include "stdlib.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define maxlen 10</span></span><br><span class="line">typedef struct stu1</span><br><span class="line">&#123;</span><br><span class="line">	char *name;	</span><br><span class="line">	int age;</span><br><span class="line">&#125;stu;</span><br><span class="line"></span><br><span class="line">void init1(stu **s,char *yourname,int yourage)</span><br><span class="line">&#123;</span><br><span class="line">	*s = (stu *)malloc(sizeof(stu));</span><br><span class="line">	<span class="keyword">if</span>(*s)</span><br><span class="line">	&#123;</span><br><span class="line">		(*s)-&gt;name = (char *)malloc(sizeof(char)*maxlen);</span><br><span class="line">		<span class="keyword">if</span>((*s)-&gt;name)</span><br><span class="line">		&#123;</span><br><span class="line">			(*s)-&gt;name = yourname;</span><br><span class="line">			(*s)-&gt;age = yourage;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init2(stu *s,char *yourname,int yourage)</span><br><span class="line">&#123;	</span><br><span class="line">	(*s).name = yourname;</span><br><span class="line">	(*s).age = yourage;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	// stu *S;</span><br><span class="line">	// init1(&amp;S,<span class="string">"zhou"</span>,21);//将一维指针取地址（二维指针）传入函数</span><br><span class="line">	// <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>,S-&gt;name,S-&gt;age); </span><br><span class="line"></span><br><span class="line">	/***可以传结构体首地址，在函数内对结构体进行修改，前提是先初始化***/</span><br><span class="line">	stu S = &#123;<span class="string">"yourname"</span>,0&#125;;	</span><br><span class="line">	init2(&amp;S, <span class="string">"wang"</span>,18);//将结构体首地址（一维指针）传入函数</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>,S.name,S.age);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数参数问题：<br>要实际改变的是普通变量的值，则需将其地址传入<br>要实际改变的是指针，则应将指针存放的地址传入</p>
<p>链表初始化，为什么不将结构体的首地址传入，而传入其二维指针<br>可以传结构体首地址，在函数内对结构体进行修改，前提是先初始化<br><strong>之前用二维指针是因为要malloc动态给结构体分配空间</strong></p>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 结构体指针 </tag>
            
            <tag> 输入输出流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python语法]]></title>
      <url>/zhoujiabo.github.io/2020/03/25/python%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>python 特点：<br>①变量不用指定数据类型，变量可以比喻为容器<br>②不用分号”;”，直接换行分割语句<br>③三种基本类型，字符串，数字，布尔<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"zhou"</span></span><br><span class="line">weight = 63.23432</span><br><span class="line">is_male = True</span><br></pre></td></tr></table></figure>

<p>用户输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1 = input(<span class="string">"type a num: "</span>)</span><br><span class="line">num2 = input(<span class="string">"type another num: "</span>)  <span class="comment">#input的返回值是字符串</span></span><br><span class="line">result = <span class="built_in">float</span>(num1) + <span class="built_in">float</span>(num2)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>字符串用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">phrase = <span class="string">"Girffe Academy"</span>    </span><br><span class="line"><span class="built_in">print</span>(phrase + <span class="string">"is cool "</span> + <span class="string">"!"</span>)  <span class="comment"># 字符串拼接</span></span><br><span class="line"><span class="built_in">print</span>(phrase.lower())             <span class="comment"># 转换为小写</span></span><br><span class="line"><span class="built_in">print</span>(phrase.upper().isupper())   <span class="comment"># 检测是否为大写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(len(phrase))</span><br><span class="line"><span class="built_in">print</span>(phrase[0])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(phrase.index(<span class="string">"Academy"</span>))      <span class="comment"># 字符串从哪开始</span></span><br><span class="line"><span class="built_in">print</span>(phrase.replace(<span class="string">"ffe"</span>, <span class="string">"dde"</span>)) <span class="comment"># 字符串替换</span></span><br></pre></td></tr></table></figure>

<p>数字用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(-3.203491)</span><br><span class="line">my_num = -5</span><br><span class="line"><span class="built_in">print</span>(str(my_num) + <span class="string">" my favorite number"</span>)</span><br><span class="line"><span class="built_in">print</span>(abs(my_num))  <span class="comment"># 绝对值</span></span><br><span class="line"><span class="built_in">print</span>(pow(4, 3))    <span class="comment"># 幂函数</span></span><br><span class="line"><span class="built_in">print</span>(max(5, 8))    <span class="comment"># 比较大小</span></span><br><span class="line"><span class="built_in">print</span>(round(4.6))   <span class="comment"># 四舍五入</span></span><br></pre></td></tr></table></figure>

<p>数学函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from math import *</span><br><span class="line"><span class="built_in">print</span>(sqrt(49))     <span class="comment">#开方</span></span><br><span class="line"><span class="built_in">print</span>(ceil(4.2))    <span class="comment">#向上取整</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>list：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">friends = [<span class="string">"mike"</span>, <span class="string">"jim"</span>, <span class="string">"tom"</span>, <span class="string">"toby"</span>]</span><br><span class="line"><span class="built_in">print</span>(friends)</span><br><span class="line">friends[0] = <span class="string">"zhou"</span>     <span class="comment"># 修改</span></span><br><span class="line"><span class="built_in">print</span>(friends[0])</span><br><span class="line"><span class="built_in">print</span>(friends[-1])      <span class="comment"># 末尾开始索引</span></span><br><span class="line"><span class="built_in">print</span>(friends[1:])      <span class="comment"># 下标大于1(包含1)的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(friends[:2])      <span class="comment"># 下标小于2(不包含2)的所有元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># friends = ["zhou", "wu"]</span></span><br><span class="line"><span class="comment"># nums = [24, 35]</span></span><br><span class="line"><span class="comment"># friends.extend(nums)    # 合并列表</span></span><br><span class="line"><span class="comment"># friends.append(True)    # 追加内容</span></span><br><span class="line"><span class="comment"># friends.insert(1, "xu") # 插入内容</span></span><br><span class="line"><span class="comment"># friends.remove("wu")    # 删除内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># friends.pop()           # 出栈</span></span><br><span class="line"><span class="comment"># print(friends.index("zhou")) # 索引</span></span><br><span class="line"><span class="comment"># friends.clear()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = [21, 32, 21, 3, 10, 23, 21, 52, 3]</span><br><span class="line"><span class="built_in">print</span>(num.count(21))    <span class="comment"># 统计</span></span><br><span class="line">num.sort()              <span class="comment"># 升序排序</span></span><br><span class="line">num2 = num.copy()       <span class="comment"># 复制</span></span><br><span class="line">num2.reverse()          <span class="comment"># 逆序</span></span><br><span class="line"><span class="built_in">print</span>(num2)</span><br></pre></td></tr></table></figure>

<p>元组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组被定义后，不能更改其中的元素（只读的）</span></span><br><span class="line">coordinate = (<span class="string">"zhou"</span>, False, 63.23, 22)</span><br><span class="line"><span class="built_in">print</span>(coordinate[1])</span><br><span class="line"><span class="comment"># 元组能进行的操作：</span></span><br><span class="line"><span class="comment"># 计算个数，拼接（元组级），返回最值，判断元素是否存在，和将列表转换成元组；</span></span><br><span class="line"><span class="comment"># 但不能追加，插入，删除元素</span></span><br></pre></td></tr></table></figure>

<p>两种特殊情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表中的元组</span></span><br><span class="line">coordinates = [(12, 3), (23, 51), (3, 1)]</span><br><span class="line"><span class="built_in">print</span>(coordinates[1][0])</span><br><span class="line">coordinates[1] = 1  <span class="comment">#只能整体上替换元组，不能修改元组的单个元素</span></span><br><span class="line"><span class="built_in">print</span>(coordinates)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组中的列表</span></span><br><span class="line">info = (<span class="string">"zhou"</span>, 21, [<span class="string">"dongguang"</span>, <span class="string">"heyuan"</span>])</span><br><span class="line"><span class="built_in">print</span>(info[2][1])</span><br><span class="line">info[2].insert(0, <span class="string">"guangzhou"</span>)<span class="comment"># 元组中，列表元素的内容可以被修改</span></span><br><span class="line"><span class="built_in">print</span>(info[2])</span><br><span class="line">info[2] = 1234    <span class="comment"># 报错，元组中的元素（列表整体）不能被替换、删除，，，</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[x86和arm]]></title>
      <url>/zhoujiabo.github.io/2020/03/23/x86%E5%92%8Carm/</url>
      <content type="html"><![CDATA[<p><strong>背景知识：</strong><br>    指令的强弱是CPU的重要指标，指令集是提高微处理器效率的最有效工具之一。现阶段的主流体系结构有两种指令集：<br>    CISC（复杂指令集）：是一种为了<strong>便于编程和提高存储器访问效率</strong>的芯片设计体系（X86体系架构）<br>    RISC（精简指令集）：是为了<strong>提高处理器运行速度</strong>而设计的芯片设计体系。它的关键技术在于<em>流水线操作</em>（pipelining）：在一个时钟周期完成多条指令。（ARM体系架构）<br></p>
<p>CISC体系的指令特征：</p>
<blockquote>
<p>1）<strong>使用微代码</strong>。指令集可以直接在微代码存储器（比主存储器的速度快很多）里执行；<br>2）<strong>庞大的指令集</strong>。可以减少编程所需要的代码行数，减轻程序员的负担。<br>优点：<strong>向后兼容</strong>，较早电脑上的软件在新的系统上运行。另外微程序指令的格式与高级语言相匹配，因而编译器并不一定要重新写；<br>缺点：指令集以及芯片的设计比上一代更复杂，不同的指令，需要<strong>不同的时钟周期</strong>来完成，执行较慢的指令，将影响整台机器的执行效率。</p>
</blockquote>
<p>RISC体系的指令特征：</p>
<blockquote>
<p>1）<strong>精简指令集</strong>，只包含了简单和基本的指令，复杂指令可由这些指令组合而成；<br>2）指令长度相同，可以在一个单独的操作里完成；<br>3）单机器周期指令，大多数指令可以在一个机器周期里完成，并且允许处理器在同一时间内执行一系列的指令。<br>优点：运行速度快，由于其指令集是精简的，它的内存管理单元、浮点单元等都能设计在同一块芯片上；处理器设计所需时间更短，可以应用更多先进的技术，开发更快的处理器；<br>缺点：多指令的操作使得程序开发者必须小心地选用合适的编译器，而且编写的代码会变得非常大；另外RISC体系的处理器<strong>需要更快的存储器</strong>，这通常都集成于处理内部，就是L1 Cache(一组缓存)。</p>
</blockquote>
<p><big>CISC和RISC三个方面综合对比</big></p>
<p>1、指令的形成：<br>    CISC因指令复杂，故采用微指令码控制单元的设计；而RISC的<em>指令90%由硬件直接完成</em>，所以指令执行很快，但RISC所须ROM空间相对比较大。至于RAM使用大小和程序的应用有关系;</p>
<p>2、寻址模式：<br>    CISC需要较多的寻址模式，而RISC只有少数的寻址模式，因此CPU在计算存储器有效位时，CISC占用的汇流排（主机板上汇集资料并传去的中继站，也称为总线）周期较多。</p>
<p>3、指令的执行：<br>    CISC指令的格式长短不一，执行的周期次数也不统一，而RISC结构刚好相反，故适合采用流水线处理架构的设计。在设计上RISC较CISC简单，同时因为CISC的执行步骤过多，闲置的单元电路等待时间增长，不利于并行处理的设计。所以就效能而言，RISC较CISC还是占了上风；但RISC因其指令精化后造成应用程序代码变多，需要较大的存储器空间，且存在指令种类多等缺点。</p>
<p><big>X86指令集和ARM指令集：</big><br>1、x86指令集<br>    intel公司为了保证电脑能继续运行以往开发的种类应用程序以保护和继承丰富的软件资源，所以其生产的所有CPU仍然继续使用x86指令集。</p>
<p>几个突出缺点：<br>    ①<strong>通用寄存器组</strong> —— x86指令集只有8个通用寄存器，所以CISC的CPU大多数时间是在访问存储器中的数据，而不是寄存器中的，这拖慢了整个系统的速度。RISC系统往往具有非常多的通用寄存器，并采用了重叠寄存器窗口和寄存器堆等技术使寄存器资源得到充分利用。<br>    ②<strong>解码</strong> —— 对CPU外核的影响。解码器是x86 CPU才有的东西，其作用是将长度不定的x86指令转换为长度固定的类似RISC的指令。解码分为硬件解码和微解码，对于简单的x86r指令只需硬件解码即可，而遇到复杂的x86指令则要进行微解码，速度较慢且很复杂；这严重制约了CPU的性能。<br>    ③寻址范围小 —— 约束了用户需要。</p>
<p>2、ARM指令集<br>    以RISC为架构的ARM指令集的指令格式统一，种类和寻址方式较少，故而处理速度很快。指令简单，意味着相应硬件线路可以尽量做到最佳化，提高执行效率，相对的使一个指令所需的时间送到减到最短。而因为指令集的精简，针对较复杂组合的工作便需要由编译器来执行。</p>
<p>总结ARM指令集架构的特点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">体积小，低功耗，低成本，高性能；</span><br><span class="line">支持Thumb(16位)/ARM(32位)双指令集，能很好的兼容8位/16位操作；</span><br><span class="line">大量使用寄存器，指令执行速度快；</span><br><span class="line">寻址方式灵活简单，执行效率高；</span><br><span class="line">指令长度固定</span><br><span class="line">流水线处理方式</span><br><span class="line">load-store结构</span><br></pre></td></tr></table></figure>

<p>load-store结构 —— 装载和存储指令：<br>    ARM体系架构中，是<strong>不允许cpu直接访问内存单元</strong>。为了解决访问内存单元的需要，使用寄存器作为中继，内存和寄存器通过load/store指令交互。（x86 CPU可以直接对内存操作）</p>
<p>ARM的一些非RISC思想的指令结构：<br>    &gt;①允许一些特定指令的执行周期数字可变，以降低功耗，减小面积和代码尺寸；<br>    ②增加了桶形移位器来扩展某些指令的功能；<br>    ③使用了16位thumb指令集来提高代码密码；<br>    ④使用条件执行指令来指令代码密度和性能；<br>    ⑤使用增强指令来实现数字信号处理的功能</p>
<p><big>总结：</big></p>
<blockquote>
<p>a.大量的复杂指令，可变的指令长度，多种的寻址方式，这些CISC特点，也是其缺点，因为这些都大大增加了解码的难度，而在现在的高速硬件发展下，复杂指令所带来的提升早已不及其在解码上浪费的时间。<br>b.除了PC市场还在用X86指令集外，服务器以及更大的系统都早已不用CISC了，x86仍然存在的理由就是为了兼容大量的x86平台上的软件。同时它的体系结构组成的实现不太困难。<br>c.RISC体系的ARM指令集，指令长度固定，指令格式种类少，寻址方式种类少，大多数是简单指令且都能在一个时钟周期内完成，易于设计超标题与流水线；寄存器数量多，大量操作在寄存器之间进行。优点是不言而喻的，因此，ARM处理器才成为是当前最流行的处理器系列，是几种主流的嵌入式处理体系结构之一。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> x86 </tag>
            
            <tag> ARM </tag>
            
            <tag> 指令集 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[科学上网 ]]></title>
      <url>/zhoujiabo.github.io/2020/03/23/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      <content type="html"><![CDATA[<p>折腾了两天，花费了不少精力，现在总结一下。<br>只给出总体的步骤，和一些相应的建议（我踩过的坑）。</p>
<p>步骤：<br>1、买外国服务器      vultr<br>2、域名购买，域名解析    namesilo<br>3、获取SLL证书 cloudflare<br>4、v2ray（一款网络代理工具）配置<br>5、部署nginx，用安全证书配置其ssl/tls证书。<br>6、下载v2rayN客户端，代理ip<br><br></p>
<p>1、买外国服务器   【vultr】(<a href="https://my.vultr.com/" target="_blank" rel="noopener">https://my.vultr.com/</a>)<br><strong>目标：能ssh登陆，本地能ping通服务器ip</strong><br>多试几次，不行就多换几个地方，要有耐心。<br>听说日本、新加坡等地区的服务器容易被墙，推荐买美国西雅图的服务器，5dollar/month<br></p>
<p>2、域名购买，设置A记录    【namesilo（<a href="https://www.namesilo.com/）" target="_blank" rel="noopener">https://www.namesilo.com/）</a><br><strong>目标：通过这个网站<a href="http://tool.chinaz.com/dns/?type=1&host=&ip=" target="_blank" rel="noopener">（点我进入）</a>进行DNS查询，能找到ip地址，说明解析成功。</strong><br>（域名解析协议（DNS）：就是将域名和ip地址联系起来，映射关系。）<br>想要使通过域名访问网站，需要将域名解析到服务器的IP（可以由namesilo设置A记录解析，不过不推荐）。<br>网站访问有点慢，要有心理准备。<br></p>
<p>3、更换DNS平台<br><strong>目标：在namesilo的dns管理中，设置域名交由cloudflare托管</strong><br>    1.<br>Cloudflare是比较出名的且少有能免费使用的美国CDN服务商，管理也比较方便。<br>    2.<br>一个cloudflare账户免费绑定多个网站<br>    3.<br>防止网络攻击，网站缓存和加速</p>
<p>获取证书教程：<a href="https://www.imhunk.com/cloudflare-tutorials/" target="_blank" rel="noopener">https://www.imhunk.com/cloudflare-tutorials/</a><br>（获取的源证书和私钥要保留好）<br></p>
<p>4、安装v2ray和nginx，并SSL证书<br>目标：将SSL源证书和私钥，粘贴到/etc/nginx/ssl中.crt文件和.key文件，在本地浏览器输入域名，进入nginx网页。<br></p>
<p>安装v2ray和nginx教程：<a href="https://www.v2rayssr.com/v2raynginx.html" target="_blank" rel="noopener">https://www.v2rayssr.com/v2raynginx.html</a><br>(教程只看前面的安装和配置部分，不看ssl配置，我们直接手动新建添加ssl/tls证书，证书获取)<br>踩过的坑：/etc/nginx/conf.d/default.conf中配置ssl路径要用<strong>绝对路径</strong><br></p>
<p>6、github下载v2rayN客户端，代理ip<br>目标：代理成功，能google进入youtube<br>踩的坑：客户端下了两天，失败了N次（github下载真的太难了）；百度网盘，码云中都找不到相关链接。用手机端下载压缩包成功了一次，不过下载的文件中没有.exe执行文件，各种尝试，，，<br></p>
<p><strong>v2ray干货：</strong><br>全平台客户端下载地址：</p>
<blockquote>
<p>链接 ： <a href="https://pan.baidu.com/s/11WQ8idI6D0uZ9vK-A9oYcQ" target="_blank" rel="noopener">https://pan.baidu.com/s/11WQ8idI6D0uZ9vK-A9oYcQ</a><br>提取码:  gzy7</p>
</blockquote>
<p>【恨没有早点遇到】服务器端安装配置一条龙：</p>
<blockquote>
<p>bash &lt;(curl -s -L <a href="https://git.io/v2ray.sh" target="_blank" rel="noopener">https://git.io/v2ray.sh</a>)<br>（有操作指导和提示；作者真是太有心了）</p>
</blockquote>
<p>搭梯子花了一整个周末，，，其中最难的是网站访问慢和下载问题，当然配置也遇到过几个问题，花了不少精力；后面我也没去ws+tsl了。</p>
]]></content>
      
        <categories>
            
            <category> 折腾类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 科学上网  </tag>
            
            <tag> v2ray </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[架构常识]]></title>
      <url>/zhoujiabo.github.io/2020/03/23/%E6%9E%B6%E6%9E%84%E5%B8%B8%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>闲话：没用oneonte了，换成了印象笔记（比较好看，管理方便），不过表格复制后不能保留格式，就上图片吧。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/23/544de23b9480e11802861512a377b6a19cbfa34480d6706f.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>ARM（Advanced RISC Mechines）<br><strong>什么是指令架构？什么是IP核？</strong></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/23/f3811e43ac2a2d2cfe1afb02a8e6d70b6439e317e11b0c9f.png" alt="" title="" class="">
                <p></p>
            </figure>

<blockquote>
<p>买了ARM的指令集授权，可以对其进行修改适应，发布自己的架构；<br>买了ARM的IP核，可以Soc设计，在产品上要注明是arm架构。</p>
</blockquote>
<p><strong>Soc：片上系统，系统级芯片，一块芯片上除了有CPU架构这个大脑外，还有GPU显卡处理器、NPU神经网络处理器、ISP图像信号处理器和基带芯片（华为做的，5G的前提）等其它结构。</strong></p>
<p>ARM的Cortex(IP核)家族：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/23/042fbe7f6fed3a88a9eecadb55b690fa8dafb117aa5922ac.png" alt="" title="" class="">
                <p></p>
            </figure>]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ARM </tag>
            
            <tag> 架构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字节对齐]]></title>
      <url>/zhoujiabo.github.io/2020/03/16/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
      <content type="html"><![CDATA[<p>编译器默认将结构、栈中的成员数据进行内存对齐。</p>
<p>但这样也会导致这个结构所需的内存空间变大。我们要有意识地对结构中的数据成员的位置进行调整,因为这可以避免空间浪费.</p>
<p>例如:</p>
<blockquote>
<p>struct stu1<br>{<br>    char a;<br>    short c;<br>    char b;<br>};<br>struct stu2<br>{<br>    char a;<br>    short c;<br>    char b;<br>};</p>
</blockquote>
<p><strong>结构中把两个char相邻放置可避免自动对齐，节约空间</strong>。</p>
<p>#pragma pcak(n) 编译器将按照n个字节对齐<br>#pragma pcak()    取消自定义字节对齐方式<br><strong>如果没有使用pragmaf,编译器默认按照4字节对齐</strong><br>对齐参数=min(n,sizeof(item))。<br>对齐原则:<br>&emsp;a/每个成员分别按自己的方式对齐，并能最小化长度<br>&emsp;b/复杂类型（如结构）的默认对齐方式是它最长的成员的对齐方式<br>&emsp;c/对齐后的长度必须是成员中最大的对齐参数的整数倍</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"></span><br><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">	int c;</span><br><span class="line">	char a;</span><br><span class="line">	char b;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct tmp</span><br><span class="line">&#123;</span><br><span class="line">	char a;</span><br><span class="line">	short b;</span><br><span class="line">	struct stu st;</span><br><span class="line">	char c;	</span><br><span class="line">&#125;;//最大对齐参数不是8，是4</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line">	struct tmp p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"tmp size:%d\n"</span>,sizeof(p));//16</span><br><span class="line">	//地址偏移量</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a\t%p\n"</span>,(unsigned int)(void*)&amp;p.a-(unsigned int)(void*)&amp;p);	//00000000</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b\t%p\n"</span>,(unsigned int)(void*)&amp;p.b-(unsigned int)(void*)&amp;p)	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"st.c\t%p\n"</span>,(unsigned int)(void*)&amp;p.st.c-(unsigned int)(void*)&amp;p);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"st.a\t%p\n"</span>,(unsigned int)(void*)&amp;p.st.a-(unsigned int)(void*)&amp;p);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"st.b\t%p\n"</span>,(unsigned int)(void*)&amp;p.st.b-(unsigned int)(void*)&amp;p);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c\t%p\n"</span>,(unsigned int)(void*)&amp;p.c-(unsigned int)(void*)&amp;p);				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/16/9a911075cae0bca64437a4b617fa19c54e2b80ebe5f79fa5.png" alt="" title="" class="">
                <p></p>
            </figure>
<blockquote>
<p>如果用<em>表示空闲空间，1表示使用内存,则<br>tmp的内存布局：1</em>11 1111 11** 1***</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 语言类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字节对齐 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[rss阅读器]]></title>
      <url>/zhoujiabo.github.io/2020/03/16/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0rss%E8%AE%A2%E9%98%85/</url>
      <content type="html"><![CDATA[<p>RSS(Really Simple Syndication)，简易信息聚合，是一种描述和同步网站内容的格式，是使用最广泛的XML应用</p>
<p>特点：<br>①来源多样的个性化“聚合”特性。<br>②信息发布的时效、低成本特性。<br>③无“垃圾”信息、便利的本地内容管理特性。</p>
<p>我的阅读器(仅供参考)：<br>安卓端：FeedMe<br>PC端：irreader</p>
<p><a href="https://www.jianshu.com/p/a79422ab2013" target="_blank" rel="noopener">给博客添加rss订阅</a></p>
]]></content>
      
        <categories>
            
            <category> 折腾类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> rss </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[黑马qt笔记_day01]]></title>
      <url>/zhoujiabo.github.io/2020/03/15/%E9%BB%91%E9%A9%ACqt%E7%AC%94%E8%AE%B0-day01/</url>
      <content type="html"><![CDATA[<p><strong>Introduction:</strong></p>
<p><big><font color='blue'>Qt是一个跨平台的C++图形用户界面(gui)应用程序框架。</font></big></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/15/4f2496157937374f61ed831d67e0c0d5a7a418eebf9d480d.png" alt="" title="" class="">
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/15/6c9e9f365b534dbc9dfbf9a9f530f00a57733aa671f888b3.png" alt="" title="" class="">
                <p></p>
            </figure>

<p><strong>Notes:</strong><br>1、如果窗口控件默认不显示，要加上b.show()去人为显示。<br>2、如果不指定父对象，窗口和窗口之间没有（嵌入）关系，相互独立。a指定b为它的父对象，a嵌入到b中。指定父对象有两种方式：<br>&emsp;①b.setParent(&amp;w);<br>&emsp;②通过构造函数传参，QPushButton b(&amp;w);<br>指定父对象，只需父对象显示，上面的对对象自动显示。</p>
<p>信号与槽：Qt对象 之间通信的接口。</p>
<pre><code>//QT4槽函数在头文件中必须要用public slots关键字修饰，
//而且SIGNAL和SLOT是宏，将函数名字-&gt;字符串 **不进行错误检查**。
//connect( &amp;w, SIGNAL(mysignal()),
 this, SLOT(dealsub()) );
//connect( &amp;w, SIGNAL(mysignal(int,Qstring)), 
this, SLOT(dealsub2(int,Qstring)) );</code></pre><p>尽量用QT5，QT4编辑时不对connect进行错误检查。<br>//QT5，如果发送多个信号，进行了函数重载，则要用函数指针，指明发送的是哪个信号。<br>void (subwidget::*func)() = &amp;subwidget::mysignal;<br>connect(&amp;w, func, this, &amp;mainwidget::dealsub);</p>
<pre><code>1         Lambda表达式，匿名函数对象
2         C++增加的新特性，项目文件增加：CONFIG += C++11
3         Qt配合信号一起使用，非常方便，可以不定义槽函数
4         从“[]”传入参数，=表示把外部所有局部变量、类中所有成员以值传递。
5         或“[]”中为&quot;=&quot;，则参数为只读的。解决：用mutable修饰



1         QPushButton *e = new QPushButton(this);
2         e-&gt;setText(&quot;Lambda表达式&quot;);
3         e-&gt;move(150,150);
4         int a = 10, b = 100;
5         connect(e,&amp;QPushButton::pressed,
6                         [=]() mutable
7                         {
8                         //[]中除了=，还可以是this或&amp;，不过最好用=，不易出错。
9                                 e-&gt;setText(&quot;123&quot;);</code></pre><p>   10                                 qDebug() &lt;&lt; “print”;<br>   11                                 a = 11;<br>   12                                 qDebug() &lt;&lt; a &lt;&lt; b;<br>   13                         }<br>   14                         );</p>
<p>按钮触发 子窗口调用槽函数发送信号（信号属于子窗口，而不是按钮）</p>
<p>直接或间接继承于Qobject的类的对象，动态分配空间后不用手动释放。</p>
<p>模态对话框：对话框运行时，不能操作窗口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    1 QAction *p1 = m_item-&gt;addAction(<span class="string">"模态对话框"</span>);</span><br><span class="line">    2 connect(p1, &amp;QAction::triggered,</span><br><span class="line">    3                 [=]()</span><br><span class="line">    4                 &#123;</span><br><span class="line">    5                         QDialog dlg;</span><br><span class="line">    6                         dlg.exec();</span><br><span class="line">    7                         qDebug() &lt;&lt; <span class="string">"print after closed"</span>;</span><br><span class="line">    8                 &#125;</span><br><span class="line">    9                 );</span><br></pre></td></tr></table></figure>

<p>非模态对话框：用dlg.show();  在对话框运行时，仍然能够操作窗口。<br>问题：但对话框只是一闪而逝，对话框直接被释放。<br>解决方式：<br>①QDialog dlg; 声明放到头文件中，作为全局变量，有点麻烦。<br>②动态分配空间（每次弹出对话框都要重新分配空间，关闭对话框后不会自动释放），导致空间越用越少<br>③类似②，但不指定父对象，而且添加属性pdialog-&gt;setAttribute(Qt::WA_DeleteOnClose); <strong>使得关闭对话框后自动释放空间</strong></p>
]]></content>
      
        <categories>
            
            <category> qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[qt5 webview报错SSLv23_client_method]]></title>
      <url>/zhoujiabo.github.io/2020/03/15/qt5-webview%E6%8A%A5%E9%94%99SSLv23-client-method/</url>
      <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QSslSocket: cannot call unresolved <span class="keyword">function</span> SSLv23_client_method</span><br><span class="line">QSslSocket: cannot call unresolved <span class="keyword">function</span> SSL_CTX_new</span><br><span class="line">QSslSocket: cannot call unresolved <span class="keyword">function</span> SSL_library_init</span><br><span class="line">QSslSocket: cannot call unresolved <span class="keyword">function</span> ERR_get_error</span><br><span class="line">QSslSocket: cannot call unresolved <span class="keyword">function</span> ERR_get_error</span><br></pre></td></tr></table></figure>
<p>问题：如上，而且网上的一些解决方法不适用</p>
<p>解决：将Tools/Qtcreator/bin下的libeay32.dll和ssleay32.dll，复制一份到Tools/mingw482_32/bin中。</p>
]]></content>
      
        <categories>
            
            <category> qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> qt </tag>
            
            <tag> problem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt无法定位程序输入点和权限问题]]></title>
      <url>/zhoujiabo.github.io/2020/03/15/Qt%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E7%82%B9/</url>
      <content type="html"><![CDATA[<p><strong>Qt无法定位程序输入</strong> 问题：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/15/8f97b0f707539fff64bef3294c787eae709f6a1dbed8a496.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>解决：将D:\BaiduNetdiskDownload\Qt5.3\5.3\mingw482_32\bin添加到系统环境变量</p>
<p>Windows添加环境变量：  <a href="https://jingyan.baidu.com/article/e4d08ffde495b64fd2f60d8f.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/e4d08ffde495b64fd2f60d8f.html</a></p>
<p><strong>Permission denied</strong>问题：<br>ctrl+打开任务管理器，结束qt进程下的对应子进程，就可以重新运行了。</p>
]]></content>
      
        <categories>
            
            <category> qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> qt </tag>
            
            <tag> problem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【MIT6.828】实模式的一点补充]]></title>
      <url>/zhoujiabo.github.io/2020/03/02/%E3%80%90MIT6-828%E3%80%91%E5%AE%9E%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E7%82%B9%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<p>&emsp;x86实模式寻址方式是”CS:IP”（16位CS代码段寄存器左移4位再与IP偏移寄存器相加得到20位的内存地址），这里计算地址时是有个问题，就是<u>计算出来的结果有可能超过20位</u>。例如0xffff&lt;&lt;4+0xffff会得到0x10ffef，会发生内存地址溢出，怎么办？这里CPU被设计出一个“卷绕”机制：地址高于1MB的为0。</p>
<p>向下兼容的现代x86计算机：<br>&emsp;16位8086的时代已经远去，现在x86-64成为主流。但无论位数如何增加，寻址能力如何增强，x86一直保持着向下兼容的良好传统。即使是当初为8086或80386机器写的软件或操作系统仍然能够在现在的x86计算机上顺利运行。</p>
<p>那么这种良好的向下兼容性是如何实现的呢？<br>&emsp;答案是：“开关”（A20 gate）。现在的x86计算机，无论是32位的64位的，在开机的那一刻CPU都是模拟16位模式运行的，地址卷绕机制也是有效的，所以无论你的电脑内存有多大，开机时CPU的寻址能力只能1MB，就好像回到8086时代一样。要突破1MB的寻址限制，需要打开A20 gate，（这时“卷绕”机制失效）。</p>
<p>一个操作系统在计算机启动后到底应该做些什么？<br>&emsp;• 计算机开机，运行环境为1MB寻址限制带“卷绕”机制<br>&emsp;• 打开A20 gate让计算机突破1MB寻址限制<br>&emsp;• 在内存中建立GDT全局描述符表，并将建立好的GDT表的位置和大小告诉CPU<br>&emsp;• 设置控制寄存器，进入保护模式。<br>&emsp;• 按照保护模式的内存寻址方式继续执行</p>
<p>控制A20 gate的方法有三种：<br>&emsp;1. 804x键盘控制器法<br>&emsp;2. Fast A20法<br>&emsp;3. BIOS中断法<br>xv6用了第一种804x键盘控制器法，这也是最古老效率最慢的一种。<br>IBM PC中只有两个8042 I/O端口，0x64叫命令端口，0x60叫数据端口。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/02/8ebd0c301628d6cbe613368c8f143dad9044a31a1e456697.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>0x64状态寄存器(重点是bit 1)：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/02/b449b99291bf166ac9d8154ab1fb5dddf04c26c7275ff541.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>bootasm.S中：<br>inb $0x64,%al : 表示从0x64端口读取一个字节到寄存器al中<br>testb $0x2,%al : 用来测试状态寄存器的bit 1是否为1,<br>jnz seta20.1 如果是1 （缓冲区不为空）则重新跳转到seta20.1处，如果是0，则代表缓冲区为空，继续向下执行</p>
<blockquote>
<p>test对两个参数(目标，源)执行AND逻辑操作,并根据结果设置标志寄存器,结果本身不会保存。test的结果会影响ZF(零标志)，当and运算结果为0时，ZF置位。jnz跳转的条件是ZF=0（与运算结果不为0,ZF不被置位）。 </p>
</blockquote>
<p>激活流程：发送0xd1命令到0x64端口 –&gt; 发送0xdf到0x60</p>
<blockquote>
<p>0xd1 means: write data to 8042’s P2 port<br>0xdf = 11011111, means set P2’s A20 bit(the 1 bit) to 1</p>
</blockquote>
<p>&emsp;x86一共有4个控制寄存器，分别是cr0~cr3，其中控制进入保护模式的开关在cr0上。cr0上和保护模式有关的位是PE(标识是否开启保护模式)和PG(标识是否启用分页)。</p>
]]></content>
      
        <categories>
            
            <category> MIT6.828 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实模式 </tag>
            
            <tag> 8042 </tag>
            
            <tag> test, jnz </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【MIT6.828】L1_e2,e3]]></title>
      <url>/zhoujiabo.github.io/2020/03/01/%E3%80%90MIT6-828%E3%80%91L1-e2-e3/</url>
      <content type="html"><![CDATA[<p><big><strong>仿真x86</strong></big><br>&emsp;替代在真正的、物理的PC上开发操作系统，我们使用一个程序仿真一个完整的PC（你为仿真器写的代码也能在真实机上启动）使用一个仿真器简化调试，例如，你可以设置在仿真x86上设置断点，而这在真实机上很难做到。</p>
<p>&emsp;在6.828上我们将使用QEMU仿真器，一个现代的和相对快速的仿真器。QEMU内置的监视器只提供有限的调试支持，qemu能作为GNU gdb的远程调试目标，我们将使用它逐步完成早期的引导程序。</p>
<p>首先，将lab 1文件解压缩到你自己的目录，然后在lab目录下输入make构建最小的启动加载器和内核。（将我们在这里运行的代码称为内核有点慷慨，但我们将在整个学期中充实它）</p>
<p>（如果你在编译过程中遇到了“undefined reference to ‘__udivdi3’”的错误，你可能没有32-bit gcc multilib，请尝试安装gcc-multilib包）<br>现在你可以运行qemu了，提供/obj/kern/kernel.img文件。上面创建的img文件作为仿真PC的虚拟硬盘的内容。这个硬盘映像包括我们的启动加载器和内核。</p>
<p>make qemu执行qemu，其中包括设置硬盘和串口端口直接输出到终端。</p>
<p>‘Booting from Hard Disk…’ 之后的所有东西被我们的JOS内核框架打印，’&gt;K’是内核包含的小监视器或交互控制程序打印的提示符。这些被内核打印的行会在运行QEMU的常规shell窗口中出现。我们设置JOS内核不仅写控制台到虚拟VGA显示，还到仿真PC的虚拟串口端口（QEMU依次输出到它自己的标准输出），是为了测试和lab分级。类似的，JOS内核将从键盘和串口得到输入，从而要么在VGA显示窗口要么在运行qemu的终端，获取它的命令。或者你可以通过运行make qemu-nox，只使用串口控制台（不用虚拟VGA）。这可能很方便，如果你是ssh连接到服务器的。Ctrl+a x停止qemu。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/01/beb2c54d91fcc25024d141f0f6b48bddb730659348867a18.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>这里只有两条能传递给内核监视器的命令，help和kerninfo。<br>help命令不言而喻，我们将简要讨论kerninfo打印内容的信息。尽管简单，需要注意的是内核监视器“直接”运行在仿真PC的“虚拟硬件”。这意味着你应该将img拷贝到真实硬盘的头几个扇区。插入那个硬盘到一个真实的PC，启动它，在真实PC屏幕上看到的内容和前面在QEMU窗口看到的完全相同。（我们不推荐你在 硬盘上有有用信息的 真实机器上这样做，因为拷贝img映像到它的硬盘会丢失 主加载记录和第一个分区的头，导致硬盘上以前的所有东西丢失。）</p>
<blockquote>
<p>遇到的问题：GNUmakefile:305: recipe for target ‘warn’ faild<br>解决：将warn:后面的echo注释掉，重新make即可。</p>
</blockquote>
<p><font color='blue'><big><strong>PC物理地址空间</strong></big></font></p>
<p>现在我们将更深入钻研PC如何启动的细节。PC的物理地址是硬连接的，有如下布局：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/01/000618b0822c1c98f74f377f9c643b4b0ade0efc95bbdd17.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>&emsp;第一代基于16位Intel 8088处理器的PC，只有1MB寻址的物理内存容量。早期PC的物理地址空间将因此在0x00000000开始，但结束在0x000FFFFF而不是0xFFFFFFFF。640KB名为Low Memory的区域是早期PC能使用的RAM，实际上更早的PC只能配置16kb,32kb,或64kb的RAM。</p>
<p>&emsp;从0x000A0000到0x000FFFFF的384kb的区域被硬件保留为特殊用处，例如视频显示缓冲和固件保存在非易失性内存中。这个保留区域中最重要的部分是BIOS(Basic Input/Output System)，它占用64KB（范围从0x000F0000到0X000FFFFF）。早期PC的BISO保存在ROM中，<u>但现在的PC存储BIOS在可更新缓存中。BIOS负责执行基本的系统初始化，例如激活显示和检查已安装的内存容量。执行这些初始化后，BIOS从适当的位置加载操作系统，如软盘，硬盘，光驱或网络，并递交机器控制权给操作系统。</u></p>
<p>&emsp;当Intel用分别支持16MB和4GB物理地址空间的80286和80386处理器打破“1MB限制”时，PC架构仍保留物理空间低1MB的原始布局，为了确保与现有的软件的向后兼容性。现代PC因此有一个从0x000a0000到0x00100000的洞，将RAM划分成“low”,”常规内存”（前640kb）和”扩展内存”（其它所有内存）。还有，在PC的32位空间的最顶层的部分空间，由BIOS保留，供32位PCI设备使用。</p>
<p>&emsp;现在x86处理器能运行超过4gb的物理RAM，所以RAM可以进一步扩展到0xFFFFFFFF之上。这样BIOS必须安排在系统RAM的32位寻址地区的顶部留下第二个洞，为这些被映射的32位设备留下空间。因此设计的限制，JOS只使用PC物理内存的前256MB，所以我们将假设所有PC都只有一个32位物理地址空间。但处理复杂的物理地址空间和经过许多年发展的硬件组织的其它方面是OS开发的其中一个重要挑战。<br></p>
<p><big><strong>ROM BIOS</strong></big></p>
<p>在lab的这部分，你将使用QEMU的调试工具来调查一个IA-32兼容的计算机如何启动。</p>
<p>&emsp;打开两个终端，在第一个终端，make qemu-gdb(或make qemu-nox-gdb)启动QEMU，但QEMU在处理器执行第一条指令之前停止，并等待GDB的调试连接。在第二个终端，从相同目录运行make，运行make gdb。</p>
<p>&emsp;我们提供一个.gdbinit文件，用于设置GDB来调试加载引导程序早期使用的16位代码，并将其定向到正在监听QEMU。（如果它不起作用，你可能需要添加“ add-auto-load-safe-path ”到你用户目录下的.gdbinit文件，说服gdb处理我们提供的.gdbinit。如果你需要这样做，gdb会告诉你）</p>
<blockquote>
<p>[f000:fff0] 0xffff0:    ljmp $0xf000,$0xe05b</p>
</blockquote>
<p>是GDB要执行的第一条指令的反汇编。从这条输出你可以总结一些东西：<br>&emsp;a. IBM PC在0x000ffff0开始执行，它在为ROM BIOS保留的64KB区域的顶部。<br>&emsp;b. PC从CS = 0XF000和IP = 0XFFFF0开始执行<br>&emsp;c. 第一条被执行的指令是jmp, 它会跳转到段地址CS = 0xf000 和 IP = 0xe05b</p>
<blockquote>
<p>什么是CS和IP？<br>CS (code segment)是代码段寄存器，IP (instruction pointer)是指令指针寄存器<br>CS:IP暗示CPU当前将要读取的指令的地址，需要重定位（CS*16 + IP）</p>
</blockquote>
<blockquote>
<p>8086处理器的简要工作过程：<br>①从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器<br>②IP = IP + 所读取指令的长度，从而指向下一条指令<br>③执行指令，转到步骤①，重复这个过程。</p>
</blockquote>
<blockquote>
<p>指令和数据：<br>在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。<br>那CPU根据什么将内存中的信息看做指令？<br>    a. CPU将CS:IP指向的内存单元的内容看做指令<br>    b. 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元 必然被CS:IP指向过。<br>jmp指令：CPU从何处执行指令由CS、IP中的内容决定的，我们可以通过改变CS、IP的内容来控制CPU执行目标指令。8086中不能用mov设置CS、IP的值，而提供了另外的指令来修改CS、IP的值，这些指令统称为转移指令，其中最简单的是jmp指令。用jmp指令可修改IP的值，如jmp 0x0100或 先mov ax 0x0100再jmp ax。</p>
</blockquote>
<p>&emsp;为什么QEMU像这样开始？这就是Intel设置的8088处理器的方式，IBM在最初的PC上使用它。因为PC上的BIOS是硬连接到物理地址范围0x000f0000-0x000fffff，这个设计确保了BIOS在上电或重启后总是第一个获得硬件控制权的，这是至关重要的，因为上电时在RAM上没有其它的软件可供处理器执行。qemu仿真器自带有BIOS，它将其放置在处理器的模拟地址空间的这个位置。在处理器复位时，模拟处理器进入实模式并设置CS为0XF000，IP为0XFFF0，从而执行就从那个（CS:IP）段开始。段地址是如何变成物理地址的？<br>&emsp;要回答这个问题我们需要知道一些关于实模式寻址的知识。</p>
<blockquote>
<p><a href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/02/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">实模式与保护模式介绍</a></p>
</blockquote>
<br>
在实模式（PC启动的模式），地址转换根据公式：“物理地址 = 段地址*16 + 偏移”进行。所以当PC设置CS为0XF000和IP为0XFFF0时，物理地址参考：16* F000 + FFF0 = 0xffff0。//16进制中乘16就是追加一个0。

<p>0xfffff0是BIOS结束之前的16字节。因此我们不必惊讶于BIOS做的第一件事是向后返回到一个更早的位置，毕竟它能在16字节完成多少工作？<br>    &gt;练习二：使用GDB的si命令跟踪ROM BIOS以获得更多指令，并尝试猜测它可能会做什么。你可能想查看[Phil Storrs I/O Ports Description]（打不开网页）和6.828参考材料页面的其它材料。不需要计较所有细节，大概了解BIOS首先做了什么事情。</p>
<p>当BIOS运行时，它设置一个中断描述符表并初始化多种设备，如VGA显示 。这就是你在QEMU窗口所看到的”Starting SeaBIOS”信息的来源。</p>
<p>初始化PCI总线和BIOS所知的所有重要设备后，它查找一个可启动的设备，如软盘，硬盘或光驱。最终，当它找到一个引导磁盘时，BIOS从盘中读取引导加载程序并递交控制给它。</p>
<p><big><strong>引导加载程序</strong></big><br>&emsp;PC的软硬盘被分割成512字节的区域叫做扇区。一个扇区是磁盘的最小传输颗粒：第次读、写操作的大小必须是一个或多个扇区，并在扇区边界上对齐。如果磁盘是可启动的，第一个扇区被叫做启动扇区，因为这是引导加载程序代码所在的位置。当BIOS发现可启动的软盘或硬盘，它加载这个512字节的扇区到物理地址0x7c00-0x7dff的内存，然后使用一个jmp指令来设置CS:IP（段：偏移）为0000:7c00，递交控制权给引导加载程序。与BIOS加载地址一样，这些地址是相当随意的，但它们是固定并对于PC是标准的。</p>
<p>&emsp;在PC发展过程中从光驱启动的能力出现的相当晚，因此PC架构师抓住机会重新思考了一下引导加载过程。结果，现代BIOS从光驱启动的方式有些复杂（也更强大）。光驱使用一个2048字节大小的扇区替代512字节 ，并且BIOS可以在递交控制权前，从磁盘加载许多更大的启动映像到内存（不止一个扇区）。想知道更多信息，请查看<a href="https://pdos.csail.mit.edu/6.828/2016/readings/boot-cdrom.pdf" target="_blank" rel="noopener">“E1 Torito”可启动光驱格式规范</a></p>
<p>&emsp;然而对于6.828，我们将使用传统的磁盘引导机制，这意味着我们的引导加载程序必须填充到极少的512字节中。引导加载程序由一个汇编源文件boot/boot.S和一个C源文件boot/man.c组成。详细地查看这些源因为有人并确保你明白发生了什么。引导加载程序必须起两个主要功能：<br>&emsp;a. 引导加载程序切换处理器从实模式到32位保护模式，因为只有在这个模式下，软件才能访问处理器所有1MB之上的物理地址空间。保护模式在【PC Assembly Language】的1.2.7和1.2.8中有简要的描述，和Intel架构手册上有详细介绍。这点你只需要了解段地址(segment:offset)转换成物理地址在保护模式发生的不同，而且在转移偏移量之后是32位而不是16位。<br>&emsp;b. 引导加载程序通过x86特殊的I/O指令，从硬盘直接访问IDE磁盘设备寄存器读取内核。如果你想更加了解这里的所指的I/O指令的意思，请在6.828参考页面中查找“IDE hard drive controller”章节。在这节课中，你不需要学习很多关于特殊设备的编程：写设备驱动在OS开发中占重要地位，但从概念和架构的视角它也是最无趣的。</p>
<p>&emsp;在你了解引导加载程序之后，查看obj/boot/boot.asm文件，这个文件是一个引导加载程序的反汇编，GNUmakefile在编译boot loader之后产生的。这个反汇编文件使我们容易地查看所有代码在物理内存中的位置，并使得当gdb中单步执行时容易跟踪发生的情况。同样的obj/kernel.asm包含了JOS内核的反汇编，它对调试非常有用。</p>
<p>&emsp;你在gdb中可以用b命令设置地址断点。例如 b *0x7c00在0x7c00地址处设置一个断点。在一个断点处，你可以用c和si命令继续执行：c使qemu连续运行直到下一个断点（或直到你在gdb中按ctrl-c），si N一次执行n个执行。 </p>
<p>&emsp;要检查内存中的指令（除了下一个要执行的指令外），可以使用x/i命令。这个命令有语法 x/Ni ADDR, N是要反汇编的连续指令的数量，ADDR是开始反汇编的内存地址。</p>
<blockquote>
<p>   练习三：查看[lab tools guide]，特别是GDB命令的章节。即使你熟悉GDB，这也包括一些对OS工作有用的深奥的GDB命令。<br>    在启动扇区被加载的地址0x7c00设置一个断点，连续执行直到这个断点。跟踪boot/boot.S的代码，使用源代码和反汇编文件obj/boot/boot.asm来跟踪你的位置。也在gdb中使用使用x/i命令反汇编boot loader中的指令序列，在obj/boot/boot.asm和GDB中比较boot loader原始源代码和反汇编 。<br>    跟踪到boot/main里bootmain()，然后进入readsect()。识别与readsect()中每个语句对应的确切的汇编指令。跟踪readsect()的剩余部分，并返回到bootmain()，确定用于从磁盘中读取内核其余扇区的for循环的开始和结束。找到循环结束时将要运行的代码是什么，在那里设置一个断点，并连续运行到断点。然后逐步完成boot loader的其余部分。</p>
</blockquote>
<p><font color='blue'><strong>能够回答以下问题：</strong></font><br>    • 处理器在什么位置开始执行32位代码？究竟是什么导致了从16位模式到32位模式的转换？<br>    <font color='purple'>答：在0x7c2d位置进入保护模式，cr0寄存器（属于CPU控制寄存器）的第0位（PE位）置1，启动保护模式</font><br>    <figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/01/256b7515a20e985676e45e011d1519d43b04f3577f8ff795.png" alt="" title="" class="">
                <p></p>
            </figure><br>    • boot loader执行的最后一条指令的什么，而且它刚刚加载的内核的第一条指令是什么？<br>    <font color='purple'>bootmain()：先读取磁盘的第一页，然后判断image映像是否有效，循环读取各个程序段，最后跳转到内核入口entry()。<br>    则boot loader执行的最后一条指令是call *0x10018</font><br>    <figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/01/12a5e5ae9135da3dd21d099cc95230dadfc38793cecd9d5d.png" alt="" title="" class="">
                <p></p>
            </figure><br>    <font color='purple'>刚加载内核的第一条指令是movw   $0x1234,0x472</font><br>  <img src="https://file.moetu.org/images/2020/03/01/12c4c91b2d976b2781384991b2d7860f34b3a5b5a886f0e2.png" alt=""><br>    • 内核的第一条指令在哪里？<br>    <font color='purple'>显然是0x0010000c，不过也可以用图中的方式，反汇编内核二进制文件并显示整个文件头的内容。</font><br>    <figure class="image-box">
                <img src="https://file.moetu.org/images/2020/03/01/893c4420fddd4dcbee1eff525265a071826b383cf000bcf8.png" alt="" title="" class="">
                <p></p>
            </figure><br>    • 引导加载程序如何决定它为了从磁盘中取出整个内核，必须读多少个扇区？它从哪里找到这个信息的？<br>    <font color='purple'>根据ELF文件头中含有的段记录（程序段偏移，段数目）</font></p>
<blockquote>
<p>readseg(uint32_t pa, uint32_t count, uint32_t offset)<br>    @function: 向pa所指向的地址读入count个bytes的、在磁盘上偏移量为offset的数据。实际借助了readsect(void *dst, uint32_t offset)（通过offset计算数据所在磁盘扇区，然后再将整个扇区读入），以扇区为单元对数据进行读取。<br>    <u>通过Elf结构体中记录的程序头表在文件中的偏移量e_phoff，计算出程序头表的表头ph；通过它记录的程序头表的条目数量e_phnum，计算出程序头表的表尾（项）eph。</u> Proghdr结构体描述了各个程序段（即程序头表中的条目）的属性。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">汇编指令：</span><br><span class="line">cli ：清中断允许位</span><br><span class="line">xor：异或</span><br><span class="line">movw：字传送</span><br><span class="line">gdb命令：</span><br><span class="line">x/N：查看从当前地址开始的连续N条指令的反汇编</span><br><span class="line">si N：连续执行N条指令</span><br><span class="line">delete breakpoints n：删除n号断点</span><br><span class="line">info breakpoints：查看当前设置了哪些断点</span><br><span class="line">display/undisplay 变量：跟踪查看某个变量，每次执行完成都会显示它的值</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> MIT6.828 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> exercise 3 </tag>
            
            <tag> CS:IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之实模式和保护模式]]></title>
      <url>/zhoujiabo.github.io/2020/02/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><big><strong>实模式:</strong></big><br>&emsp;实模式存在的时间非常短，CPU复位或上电时就是以实模式启动，实模式下，不能实现权限分级，也不能访问20位以上的地址线，也就是只能访问1M内存。</p>
<p>&emsp;处理器8086有20根地址线，可寻址1MB内存；但是它内部的段寄存器和IP寄存器都是16位的，如果用原来的地址转换方式（段值+偏移地址=物理地址），只能访问16位的地址（64KB），难以访问所有内存(1MB)。如何解决这个问题？<br>8086采用的地址转换处理方法：先将段寄存器值左移4位形成20位段地址，再和16位的偏移地址相加得到20位的物理地址，即<strong>物理地址 = 段地址*16 + 偏移</strong>。<br></p>
<p>8086处理器开创性地提出了地址分段的概念，改变了在它之前的CPU只能“硬编码”，程序无法重定位的缺点。但是实模式有很多缺陷，其中最要命的是安全隐患。在实模式下，用户程序和操作系统拥有同行权利，程序可以随意修改自己的段基地址，而实模式下对地址的访问就是实实在在的物理地址，因此程序可以随意修改任意物理地址，甚至包括操作系统所有的内存，这给操作系统带来了极大的安全问题。</p>
<blockquote>
<p>什么是硬编码？硬编码一般指在代码中写死的，与它相对的是配置项，可以在程序发布后进行修改。<br>什么是重定位？重定位就是操作系统将逻辑地址转变为物理地址的过程，也就是对目标程序中的指令和数据进行修改的过程。</p>
</blockquote>
<br>

<p><big><strong>保护模式:</strong></big><br>保护模式第一次在Intel 80826手册中被提出，但它只是一个指引，加上80826只是一个“过渡”产品，保护模式最终实现是在32位的80386上。（80386的地址总线和寄存器都是32位，因此其单寄存器的寻址空间扩大到了4GB，仅通过段内偏移地址就足以访问内存的任意角落。）</p>
<blockquote>
<p>保护模式具有许多优秀的设计如内存保护，分布机制和硬件虚拟存储支持，提高了系统的安全性和稳定性（电脑不再动不动就蓝屏），实现了多任务。</p>
</blockquote>
<p>&emsp;在保护模式中，内存的管理模式分为两种——段模式和页模式，其中页模式也是基于段模式的，也就是说，事实上是：纯段模式和段页模式。<br></p>
<p>&emsp;为了改进实模式下内存访问的不安全性，保护模式给内存段添加了段属性来限制用户程序对内存的操作权限。引入了全局描述符表GDT，它的表项是段描述符，每个段描述符（占8字节）都描述了一个内存段的基本属性，如段基地址，段界限，类型，描述符特权等级。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/28/5e478f4dfaf106af2011962254da91479a781f7b58e22368.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>&emsp;正是由于以上概念的提出，使得“段：偏移”的访问策略从实模式下的对物理地址的直接映射变成了保护模式下对GDT或LDT的间接映射。进程在访问内存段（无论是数据段不是代码段）前者需要通过特权行权检查，段属性的加入让用户程序对内存的访问不再“为所欲为”。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/28/079a69b06bd098a0b5af4e9572ee8fd97dbb485d06e82d59.png" alt="" title="" class="">
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实模式和保护模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【MIT6.828】HW: shell]]></title>
      <url>/zhoujiabo.github.io/2020/02/28/%E3%80%90MIT6-828%E3%80%91HW-shell/</url>
      <content type="html"><![CDATA[<p>HW：shell</p>
<p>下载shell文件（<a href="https://pdos.csail.mit.edu/6.828/2016/homework/sh.c" target="_blank" rel="noopener">sh.c</a>），并反复阅读它。shell文件包括两个主要部分：解析shell命令并实现它们。解析器只能辨识以下简单的shell命令：<br>    1     ls &gt; y<br>    2     cat &lt; y | sort | uniq | wc &gt; y1<br>    3     cat y1<br>    4     rm y1<br>    5     ls |  sort | uniq | wc<br>    6     rm y<br>剪切并粘贴这些命令到一个文件t.sh。<br>编译shell框架：gcc sh.c，（注意所有操作都在虚拟机上执行）<br>得到一个a.out文件，你可以运行“./a.out  &lt; t.sh”。<br>本次执行会打印错误信息，因为你没有实现几个功能。在这个作业的余下部分你将实现那些功能。</p>
<p><font color='blue'><big>执行简单命令：</big></font><br>实现简单命令，如ls。解析器已经为您构建了一个execcmd，所以你需要写的代码只是在runcmd中的’ ‘情况。你可能发现查看exec的手册页面有帮助，输入”man 3 exec”（注意不是运行./a.out后生成的命令行）并阅读有关execv。当执行失败时打印一个错误信息。</p>
<blockquote>
<p>int execv(const char <em>path, char <em>const argv[]);<br>execv()函数提供一个指针数据，指向以空字符结尾的字符串，这些字符串代表新程序可用的参数列表。</em></em>第一个参数按照惯例应该指向正在执行的文件相关的文件名。指针数据必须以空指针结尾**。<br>我的修改：在runcmd()中的case’ ‘:中添加执行函数execv(ecmd-&gt;argv[0], ecmd-&gt;argv);</p>
</blockquote>
<p>测试你的程序，编译并运行a.out，它会打印一个“6.828$”的提示符并等待你的输入，这样你就不会和你电脑的shell混淆了，现在输入ls。你的命令解释器会打印一个错误信息（除非有一个名为ls的程序在你的工作目录，或者你使用查找路径的exec版本）。<br>现在输入”/bin/ls”到你的shell。这会执行/bin/ls程序，它会打印输出你工作目录中的文件名。你可以输入”ctrl-d”来停止6.828的shell，它会让你返回到你电脑的shell。</p>
<p>如果程序在当前工作目录中不存在，你可能希望修改6.828shell为总是尝试/bin。因此你不必每次都输入”/bin”。如果你有信心你可以实现一个PATH变量的支持。</p>
<blockquote>
<p>使用spintf(path,”%s%s”,path,ecmd-&gt;argv[0]); 或strcat(path,ecmd-&gt;argv[0]);实现字符串拼接</p>
</blockquote>
<p>运行./a.out时程序崩溃，显示段错误（核心已转储）。如何解决？<br>查找段错误的方法： <a href="https://blog.csdn.net/guaiguaihenguai/article/details/78701008" target="_blank" rel="noopener">https://blog.csdn.net/guaiguaihenguai/article/details/78701008</a></p>
<p><strong>我的修改：定义char path[] = “/bin/“; 再使用字符串拼接</strong></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/28/43bc8c17d558b2e0f53d47536415732ff2c8b92254cf2455.png" alt="" title="" class="">
                <p></p>
            </figure>

<p><strong>别人的修改（更完善）</strong>：<br>借助一个检查函数：int access(const char *pathname, int mode)<br>参数mode的选择：<br>    R_OK，W_OK, X_OK : 测试（读、写、执行）的许可权限; 以及F_OK : 测试文件是否存在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    1 <span class="keyword">if</span>(access(ecmd-&gt;argv[0],F_OK) == 0)</span><br><span class="line">    2 &#123;</span><br><span class="line">    3     execv(ecmd-&gt;argv[0],ecmd-&gt;argv);</span><br><span class="line">    4 &#125;</span><br><span class="line">    5 <span class="keyword">else</span></span><br><span class="line">    6 &#123;</span><br><span class="line">    7     char binpath[] = <span class="string">"/bin"</span>;</span><br><span class="line">    8     strcat(binpath,ecmd-&gt;argv[0]);</span><br><span class="line">    9     <span class="keyword">if</span>(access(binpath,F_OK) == 0)</span><br><span class="line">   10         execv(binpath,ecmd-&gt;argv);</span><br><span class="line">   11     <span class="keyword">else</span></span><br><span class="line">   12         fprintf(stderr,<span class="string">"%s: Command not found\n"</span>,ecmd-&gt;argv[0]);</span><br><span class="line">   13 &#125;</span><br></pre></td></tr></table></figure>
<br>

<p><font color='blue'><big>I/O重定向：</big></font><br>实现I/O重定向命令，从而你可以运行 echo  “6.828 is cool” &gt; x.txt，cat &lt; x.txt<br>解析器已经识别”&gt;”和”&lt;”，并为你创建了一个redircmd，所以你的工作只是为这些符号补充runcmd中缺失的代码。你可能发现用于打开和关闭的手册页非常有用。<br>注意redircmd中的模式字段包括访问方式（e.g O_RDONLY），你应该传递它到flags参数给open，有关shell使用的模式值和open的flags参数的手册，参见parseredirs。</p>
<p>如果你正在使用的其中的一个系统调用失败，请确保打印一个错误信息。</p>
<p>确保用上面的测试输入能正确运行你的实现。常见的错误是忘了指定文件必须被创建的权限。（即，开启第三个论证）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">open函数：</span><br><span class="line">man 2 open    查看open()系统调用</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">@<span class="built_in">return</span>:</span><br><span class="line">	如果打开成功则返回文件描述符，否则返回-1.</span><br><span class="line">@args:</span><br><span class="line">    pathname：当前路径的文件名，或文件的绝对路径</span><br><span class="line">    flags: 三个必选常量（O_RDONLY,O_WRONLY,O_RDWR）中的一个（表示读写模式）还有一些常量可以选用，和前面的必选项 按位或起来作为flags参数，如表示 如果指定文件不存在则创建这个文件的O_CREAT，表示追加的O_APPEND等。</span><br><span class="line">    mode:设置文件访问权限的初始值，和用户掩码有关，如0644表示-rw-r--r--。也可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    ①文件权限由open的mode参数和当前进程的<span class="built_in">umask</span>掩码共同决定。</span><br><span class="line">    ②第三个参数是在第二个参数中有O_CREAT时才作用，如果没有，则第三个参数可以忽略</span><br></pre></td></tr></table></figure>


<p><strong>要看redircmd结构体代码</strong>：</p>
<blockquote>
<p>struct cmd*<br>redircmd(struct cmd <em>subcmd, char <em>file, int type)<br>{<br>  struct redircmd *cmd;<br>  cmd = malloc(sizeof(</em>cmd));<br>  memset(cmd, 0, sizeof(*cmd));<br>  cmd-&gt;type = type;<br>  cmd-&gt;cmd = subcmd;<br>  cmd-&gt;file = file;<br>  cmd-&gt;mode = (type == ‘&lt;’) ?  O_RDONLY : O_WRONLY|O_CREAT|O_TRUNC;<br>  cmd-&gt;fd = (type == ‘&lt;’) ? 0 : 1;<br>  return (struct cmd</em>)cmd;<br>}</p>
</blockquote>
<p><strong>注意 cmd-&gt;mode，应该作为open函数的flags参数</strong></p>
<p>添加如下修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">close(rcmd-&gt;fd);	</span><br><span class="line"><span class="keyword">if</span>(open(rcmd-&gt;file,rcmd-&gt;mode,0644) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"open %s fail"</span>,rcmd-&gt;file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/28/5c52d8b16d3a63e277e8ae848ce2083989bdea0c8f4a09da.png" alt="" title="" class="">
                <p></p>
            </figure>

<br>
<font color='blue'><big>管道符：</big></font>

<p>实现管道符从而你能运行如下管道命令：ls | sort | uniq | wc</p>
<p>解析器已经识别“|”并创建pipecmd，所以你只需在runcmd中写case “|”的代码。你可能发现pipe,fork,close和dup的手册有帮助。</p>
<p>测试你能否运行上面的管道命令。sort程序可能在/usr/bin目录，假如那样你可以输入绝对路径/usr/bin/sort来运行sort。（你可以输入which sort在shell查找路径查找哪个目录有名为”sort”的可执行文件）</p>
<p>现在你应该可以正确运行下面命令：a.out &lt; t.sh，确保在这个程序中你使用了正确的绝对路径。</p>
<blockquote>
<p>int pipe(int pipefd[2]);<br>pipe()创建一个管道，一个单向的数据通道，它可以用于进程之间的通信。pipefd数据是用来返回两个引用管道末端的文件描述符。pipefd[0]引用管道的读末端，pipefd[1]引用管道的写末端。被写到管道写末端的数据被内核缓冲，直到它从读末端被读出。<br><a href="https://blog.csdn.net/oguro/article/details/53841949" target="_blank" rel="noopener">管道pipe详解</a></p>
</blockquote>
<blockquote>
<p>int dup(int oldfd);<br>dup()系统调用创建一个oldfd文件描述符的拷贝，为新描述符使用最小号码的未使用的文件描述符。</p>
</blockquote>
<p><strong>要兼容/usr/bin，所以用了字符串指针数组，<br>char *path[] = {“/bin/“,”/usr/bin/“};<br>但遇到的一个问题：在strcat上引发了段错误:</strong><br>函数原型：char *strcat(char *dest, char *src)<br>函数功能：把src所指字符串添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’。这就要求<u>dest必须有足够的空间来容纳src的字符串</u>，否则就很可能导致段错误。<br>解决：起初我们想用malloc给dest申请一段足够大的空间来解决这个问题的，但试了好几次都没成功。<br>最后直接用了二维数组：。</p>
<blockquote>
<p>char path[][20] = {“/bin/“,”/usr/bin/“}; //不一定是20，保证有足够空间存储路径字符串即可。</p>
</blockquote>
<p><strong>兼容/usr/bin：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int found = 0;</span><br><span class="line"><span class="keyword">for</span>(int i=0;i&lt;2&amp;&amp;(found==0);i++)</span><br><span class="line">&#123;</span><br><span class="line">  strcat(PATH[i],ecmd-&gt;argv[0]);</span><br><span class="line">  <span class="keyword">if</span>(access(PATH[i], F_OK) == 0)		//若/bin或/usr/bin下有这个命令</span><br><span class="line">  &#123;</span><br><span class="line">    execv(PATH[i],ecmd-&gt;argv);		//my modify</span><br><span class="line">    found = 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(found == 0)</span><br><span class="line">&#123;</span><br><span class="line">  fprintf(stderr,<span class="string">"%s: Command not found\n"</span>,ecmd-&gt;argv[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管道符实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">    pcmd = (struct pipecmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(pipe(p) &lt; 0)//创建管道p,p[0]是读末端，p[1]是写末端</span><br><span class="line">    &#123;</span><br><span class="line">      fprintf(stderr,<span class="string">"pipe fail\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1()==0)//创建一个写进程left</span><br><span class="line">    &#123;</span><br><span class="line">      close(1);</span><br><span class="line">      dup(p[1]);//为写管道生成文件描述符</span><br><span class="line"></span><br><span class="line">      close(p[0]);</span><br><span class="line">      close(p[1]);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1()==0)//创建一个读进程right</span><br><span class="line">    &#123;</span><br><span class="line">      close(0);</span><br><span class="line">      dup(p[0]);//为读管道生成文件描述符</span><br><span class="line"></span><br><span class="line">      close(p[0]);</span><br><span class="line">      close(p[1]);</span><br><span class="line">      runcmd(pcmd-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[0]);</span><br><span class="line">    close(p[1]);</span><br><span class="line">    <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">    <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">    <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/28/612c6f8c6793c7fd295f120a18b112da102581e60ee93914.png" alt="" title="" class="">
                <p></p>
            </figure>

<br>
<font color='blue'>挑战练习：</font>
你可以将自己选择的任何功能添加到shell，但你可以考虑如下的内容作为开始：<br>
&emsp;a. 实现一系列命令，用";"分隔<br>
&emsp;b. 实现子shell通过实现"("和")"<br>
&emsp;c. 通过支持"&"和"wait"实现在后台运行。<br>
所有的这些需要解析器和runcmd函数的变化。
]]></content>
      
        <categories>
            
            <category> MIT6.828 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【MIT6.828】HW1:boot xv6]]></title>
      <url>/zhoujiabo.github.io/2020/02/26/%E3%80%90MIT6-828%E3%80%91HW1-boot-xv6/</url>
      <content type="html"><![CDATA[<p>HW1：boot xv6<br>遇到的<strong>问题1，在用户目录中没有.gdbinit文件</strong>，解决：根据提示的信息创建这个文件并添加一些配置就可以了。</p>
<p>查找地址： nm kernel | grep _start<br>设置断点：br  * 0x0010000c<br>运行到下一个断点：c(continue)</p>
<p>遇到的<strong>第二个问题：no bootable device（gdb窗口）</strong><br>解决：sudo chmod 777 xv6-public后make clean，再重新make一遍</p>
<p>exercise：what is on the stack？<br>在上面的断点_start（0x0010000c）处，查看寄存器和堆栈内容。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/26/570a69a2f28add0e7f2bccb396cdfd970aaf801d15140e0c.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>在每个堆栈的非零值的旁边写一些注释来解释它是什么。哪些堆栈打印才是真正的堆栈（暗示，不是全部）</p>
<p>你可能发现查找引导文件（bootasm.S, boomain.S, bootblock.asm）很方便，这些文件包括了编译/汇编器的输出。如果你想知道某个指令的语义，参考页面有指向x86汇编文档的指针（即链接）。你的目标是理解和解释你上面所看到的进入到xv6内核之后的堆栈的内容。达到这个目标的一种方法是观察堆栈在早期引导加载时是怎么和在哪里开始的（设置方式和位置），然后跟踪堆栈的变化直到你感兴趣为止。这里有一些问题来帮助你前进：<br><br>    a. 从重启qemu和gdb开始，在引导块（bootasm.S）的起点0x7c00设置一个断点。通过指令单步执行（在gdb提示符(prompt)下输入si）。在bootasm.S的哪个位置堆栈指针被初始化？（单步执行直到你看到一个moves a value into %esp的指示，这个寄存器是堆栈指针）<br><br>    <font color='blue'>在0x7c43位置，esp（堆栈指针）被初始化，值为0x7c00（引导块的起点）。</font><br>    <img src="https://file.moetu.org/images/2020/02/26/d6e1e156d4623a244ce59e6675525b36ed16636dac4cbaba.png" alt=""></p>
 <br>   
    b. 单步调试调用bootmain，现在堆栈上是什么。<br>
    <font color='blue'>bootmain的入口地址为0x7d3b，eip为0x7c48</font>

<p>   <img src="https://file.moetu.org/images/2020/02/26/9a6d38b031de01b2eb667afcf556b2757f5b51816aa23c2a.png" alt=""></p>
<br>
    c. 什么执行了bootmain的第一条汇编指令到堆栈？在bootblock.asm里查找bootmain<br>
    <font color='blue'>将当前函数的ebp值压栈</font>
    <figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/26/100714e4b09672303711e4510921ec204e2628c3286823ee.png" alt="" title="" class="">
                <p></p>
            </figure>

<br>
    d. 通过gdb继续跟踪（必要时使用断点，看下面的暗示），查看修改eip为0x10000c的调用。这个调用对堆栈做了什么？（暗示：思考这个调用在引导过程中尝试完成什么，尝试在bootmain.c中识别这一点，以及bootmain代码在bootblock.asm中的相应指令。这可能有助于你设置合适的断点来提高速度）<br>
    <font color='blue'>查看bootblock.asm文件，entry之后进入内核。</font>
    <figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/26/79b969e3e0d30a64a283988cfd91b3c0b69e90ba6682174b.png" alt="" title="" class="">
                <p></p>
            </figure>

<blockquote>
<p>注意：GNU汇编器使用 AT&amp;T 样式的语法，所以其中的源和目的操作数和 Intel 文档中给出的顺序是相反的。如mov指令在AT&amp;T语法中为mov source destination。movl     %eax,     %ebx      #把32位的EAX寄存器值传送给32为的EBX寄存器值。</p>
</blockquote>
<p>寄存器<br>eip：寄存器存放下一个CPU指令存放的内存地址<br>ebp：”基址指针”(BASE POINTER), 它最经常被用作高级语言函数调用的”框架指针”(frame pointer)<br>esp：栈顶指针寄存器</p>
<p>如何查看汇编文件：<br>gcc -s -o main.s main.c生成汇编文件<br>objdump -s -d main.o/main &gt; main.txt 将目标文件或可执行文件反汇编</p>
<p>反汇编工具objdump：<br>-f：显示文件头信息<br>-d：反汇编需要执行指令的那些section<br>-D：与-d类似，但反汇编所有section<br>-h：显示section header信息<br>-x：显示全部header信息<br>-s：将所有段的内容以十六进制打印</p>
<p>（实际上不用我们去额外去反汇编，直接查看.asm文件就可以了）</p>
]]></content>
      
        <categories>
            
            <category> MIT6.828 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HomeWork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【MIT6.828】intro L1_e1]]></title>
      <url>/zhoujiabo.github.io/2020/02/24/%E3%80%90MIT6-828%E3%80%91intro-L1-e1/</url>
      <content type="html"><![CDATA[<p><strong>Lab1</strong>:<br>介绍：这个实现被划分成三个部分。第一部分关注于熟悉x86汇编语言，qemu（x86仿真器）和PC的上电启动过程。第二部分研究6.828内核的引导加载程序，它位于lab树的boot目录中。第三部分钻研6.828本身的初始模板，它叫JOS，位于kernel目录。</p>
<p>软件安装：<br>本节课的和后继的实验作业所需的文件均使用git（版本控制系统）分发。有关更多git的学习，请查看git用户手册，或者如果你已经熟悉其它版本控制系统，你会发现git的这个面向cs的概述特别有用。</p>
<p>本课程的Git仓库地址为 <a href="https://pdos.csail.mit.edu/6.828/2016/jos.git。" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2016/jos.git。</a> 为了安装这个文件到你的PC，你需要用下面的命令克隆这个仓库。你必须使用x86机器，也就是说uname -a应该提到i386 GNU/Linux 或 i686 GNU/Linux 或 x86_64 GNU/Linux。</p>
<p>git允许你跟踪对代码的修改。例如，如果你完成其中一个练习，并想要查看你的进度，你可以“提交你的更改”，通过” git commit -am “my solutioin for lab exercise 9” “</p>
<p>你可以用git diff命令跟踪你的修改。运行git diff会显示自上次提交以来对代码的修改，面git diff origin/lab1会显示与这个lab初次提交的代码的相关变化。这里origin/lab1是git分支名，包括你从我们的服务器下载来的初始代码。</p>
<p>我们已经为你在Athena服务器上设置了合适的编译器和仿真器。运行add -f 6.828来使用它们。你每次登录都必须运行这个命令（来添加它到你的~/.environment文件）。如果你在编译或运行qemu时遇到了模糊错误，请再次检查是否添加了课程锁。</p>
<p>如果你不是工作在Athena服务器上，你需要按照tool页面的指导安装qemu和gcc。我们已经对qemu做了几个有用的调试改变，后面一些的实验也依赖于这些补丁（patches），所以你必须建立你的补丁。如果你的机器使用本地的ELF工具链，你可以从你的包管理器简单地安装gcc。否则，遵循工具页的指导。</p>
<p>提交过程<br>你将用submission website来提交你的作业，在你提交任何作业或实验前，你需要从这个网站申请一个API密钥。（我们不能访问那个提交作业的网站，直接略过。。。）</p>
<p>第一部分：PC引导程序<br>第一个练习的目的是向你介绍x86汇编语言和PC引导过程，让你开始用QEMU和QEMU/GDB调试。实验的第一部分你不必写任何代码，但为了你自己理解你要诵读一遍，并准备回答下面提出的问题。</p>
<p>开始使用x86汇编<br>如果你不熟悉x86汇编语言，在这个课程中你会很快熟悉它。<a href="https://github.com/cral-freedom/6.828-tools-and-resources" target="_blank" rel="noopener">PC Assembly Language Book</a>是一个非常不错的起点。希望对你来说，这本书包含了新旧材料的融合。<br>提醒：不幸的是书中的例子是为NASM汇编器写的，然而我们将使用的是GNU汇编器。NASM使用所谓的Intel语法而GNU使用AT&amp;T语法。虽然语义相当，但使用的语法不同，一个汇编文件会有很大不同，至少表面上是这样的。幸运的是两者的转换十分简单，并且在Brennan’s Guide to Inline Assembly上有介绍。</p>
<blockquote>
<p>练习1：熟悉用6.829参考页面上的汇编语言材料。你不必现在阅读它们，但你在读写x86汇编时，肯定会参考其中的一些材料。我们推荐阅读<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">Brennan的内联汇编指南</a>中的语法部分。它对我们将在JOS使用的GND汇编器的AT&amp;T汇编语法进行了很好的描述。</p>
</blockquote>
<p>当然，X86汇编语言编程的权威参考是Intel的指令集架构参考。你可以在6.828参考页面上找到两个版本（flavors）：老的<a href="https://pdos.csail.mit.edu/6.828/2016/readings/i386/toc.htm" target="_blank" rel="noopener">80386程序员参考手册</a>的HTML版本，它比最近的手册更短更容易操作但描述了我们在6.828中使用的所有x86处理器特点。和最新的最全的<a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank" rel="noopener">IA-32 Intel架构软件开发者手册</a>，概述了最新处理器的所有特性，我们在课程中不需要但你可能有兴趣了解它们。ADM也提供了类似的（更友好的）手册。保存Intel/AMD架构手册以备以后使用，或当你想查看特定的处理特性或指令的权威解释时使用它们。</p>
<p>（如果只是为了兴趣而实现一个系统，可以不用完整地去阅读英文版的权威指南，而只学习一些常用的课程需要的指令。）</p>
]]></content>
      
        <categories>
            
            <category> MIT6.828 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Lab exercise </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【MIT6.828】Lab tool guide]]></title>
      <url>/zhoujiabo.github.io/2020/02/23/%E3%80%90MIT6-828%E3%80%91Lab-tool-guide/</url>
      <content type="html"><![CDATA[<p>&emsp;对环境的熟悉对系统开发和调试很关键。本页对JOS环境和有用的DGB和QEMU命令作一个简要的综述。不过不要相信我们的话，要去读GDB和QEMU的手册。这些都是值得我们去了解如何使用的强大工具。<br></p>
<p><big><strong>调试技巧</strong></big>：<br>1、内核：GDB是你的朋友。用qemu-gdb目标（或qemu-gdb-nox变体）使QEMU等待GDB连接。有关调试内核时有用的命令，请查看上面的GDB参考资料。<br>&emsp;a. 如果你遇到了意料之外的中断，异常，三重错误，你可以要求QEMU使用-d参数生成一份详细的中断日志。<br>&emsp;b. 调试虚拟内存问题，尝试QEMU监控器命令，info mem（用于高级别概述）或info pg（用于大量细节）。注意这些命令只显示当前页表。<br>&emsp;c. （lab 4+）调试多个CPU，使用GDB的线程有关的命令，如thread和info threads。<br></p>
<p>2、用户环境（lab 3+）：GDB也允许调试用户环境，但有一些事情你需要小心，因为GDB不知道多个用户环境之间，用户与内核之间的区别。<br>&emsp;a. 你可以使用make run-name（或直接编辑kern/init.c）在特定的用户环境中启动JOS。用run-name-gdb变体使QEMU等待GDB连接。<br>&emsp;b. 你可以象征性调试用户代码，就像你调试内核一样，但你必须使用symbol-file命令告诉GDB使用哪个符表，因为它一次只能用一个符表。提供.gdbinit加载内核符号表，obj/kern/kernel。用户环境的符号表在其ELF二进制文件，所以你可以用”symbol-file obj/user/naem”加载它。不要从任何.o文件加载符号，因为它们没有被链接器重定位（库被静态地链接进JOS用户二进制文件，所以那些符号已经被包括在各自的用户二进制文件中了）。确保你得到了正确的用户二进制文件，在不同二进制文件中，库函数会被链接到不同的EIP上，并且GDB不知道更多。</p>
<p>（lab 4+）因为GDB作为一个整体被连接到虚拟机，它将时钟中断看作另一个控制传输。这使得它基本<strong>不可能单步（step through）执行用户代码，因为你让VM再次运行时 时钟中断实际上是确定的</strong>。stepi命令可以工作是因为它抑制中断（suppress interrupt），但它只执行一条机器汇编指令。断点通常是有效的，但要小心因为你在不同的环境可以访问（hit）到相同eip（实际上，完全是不同的二进制【指环境】）。<br></p>
<p><big><strong>参考</strong></big>：<br><strong>JOS makefile</strong><br>&emsp;JOS GNUmakefile包括一些虚假目标（phony targets）为了用多种方式运行JOS。所有都将QEMU配置为监听gdb连接。在QEMU运行后启动，从你的目录运行gdb。我们提供一个自动把GDB指向QEMU的.gdbinit文件，加载内核符号表，并且在16位和32位模式之间切换。退出gdb会关闭qemu。</p>
<p>make qemu:<br>&emsp;创建所有东西然后使用新的窗口的VGA控制台和终端的串行控制台启动QEMU。要退出，要么在关闭VGA窗口，要么在终端下按ctrl+c/a。</p>
<p>make qemu-not<br>&emsp;类似make qemu，但只在串行控制台中运行。要退出，按ctrl-a x. 这在通过SSH连接到服务器时特别有用，因为VGA窗口花费很多带宽。</p>
<p>make qemu-gdb<br>&emsp;类似make qemu，但相比时刻被动地（passively）接受gdb连接，这停止在第一个机器指令并且等待一个gdb连接。</p>
<p>make qemu-nox-gdb<br>&emsp;qemu-nox和qemu-gdb目标的结合</p>
<p>make run-name<br>&emsp;（实验3以上才会用到）运行用户程序名，例如，make run-hello，运行user/hello.c</p>
<p>make run-name-nox, run-name-gdb, run-name-gdb-nox<br>&emsp;多种组合命令。</p>
<p>Makefile还接受其它一些有用的变量，如<br>make V=1     啰嗦（verbose）模式，打印正在执行的每条命令，包括参数。</p>
<p>make V=1 grade    在任何失败的等级测试之后停止，并将qemu输出放到jos.out，用来检查。</p>
<p>make QEMUEXTRA=’args’    指定要传给qemu的其它（additional）参数<br></p>
<p><strong>JOS obj/</strong><br>&emsp;a. 当创建JOS时，makefile还会生成一些其它可以在调试时证明有用的输出文件。<br>&emsp;b. obj/boot/boot.asm, obj/kern/kernel.asm, obj/user/hello.asm, etc（引导加载程序，内核，用户的汇编代码的清单）<br>&emsp;c. obj/kern/kernel.sym, obj/user/hello.sym, etc（内核和用户程序的符号表）<br>&emsp;d. obj/boot/boot.out, obj/kern/kernel, obj/user/hello, etc（链接内核和用户程序的ELF映像，这些包括可以被GDB使用的符号信息）<br></p>
<p><strong>GDB</strong><br>&emsp;有关GDB命令的完全指南，请查看GDB手册。这里有一些对6.828特别有用的命令，其中一些通常不会出现于OS开发之外。</p>
<p>ctrl -c：停止机器，并按当前指令进入GDB。</p>
<p>c（或contiune）：继续执行直到下一个断点或ctrl-c</p>
<p>si (或stepi)：执行一条机器指令</p>
<p>b function 或 b file:line 或 breakpoint：在给定的函数或行上设置一个断点</p>
<p>b *addr（或breakpoint）：在EIP地址上设置一个断点</p>
<p>set print pretty：使能数组和结构的打印</p>
<p>info registers：打印通用寄存器,eip,eflags和段选择器。更详细的机器寄存器状态的转储，请查看QEMU自己的info register的命令</p>
<p>x/Nx addr：显示从addr地址开始的N个字。如果N被省略了，它默认值为1，addr可以是任意表述。</p>
<p>x/Ni addr：显示addr之后的N个汇编指令，使用$eip作为地址将在当前指令指针片显示指令。</p>
<p>symbol-file file：（lab 3+）切换到符号文件”file”。当GDB连接到QEMU，它在虚拟机上没有进程边界的概念，所以我们不得不告诉它用哪个符号。一般地，我们配置GDB来使用内核符号表obj/kern/kernel。如果机器正在运行用户代码hello.c，你可以用symbol-fil obj/user/hello切换到hello的符号表。</p>
<p>QEMU将每个虚拟CPU个表示为GDB中的一个线程。所以你可以用所有GDB的线程相关的命令来查看或操作QEMU的虚拟CPU。</p>
<p>thread n：GDB一次只关注一个线程（即cpu）。这条命令切换到线程n（线程号从0开始）。<br>info threads：列出所有线程，包括它们的状态（活动或停止）和它们有什么功能</p>
<p><strong>QEMU</strong>：<br>&emsp;QEMU包括一个内置的监控，它能有效地检测和修改机器状态。要进入监视器，在终端输入Ctrl-a c运行QEMU。再按一次ctrl-a c会切换加串行控制台<br>有关监控命令的完全指南，请查看QEMU手册。这里有一些特别有用的命令：</p>
<p>xp/Nx paddr：显示物理地址paddr后的N的个字。如果N被忽略，它的默认值为1。这里是GDB的x命令的物理内存模拟。</p>
<p>info registers：显示一大堆机器的内部寄存器状态。特别的，这包括用于段选择器，本地，全局和中断描述符表的机器的隐藏段状态，以及任务寄存器。当段选择器被加载时，这个隐藏状态是虚拟CPU从GDT/LDT中读取的信息。这是在lab1中JOS内核运行的CS和每个字段的含义：</p>
<blockquote>
<p>CS =0008 10000000 ffffffff 10cf9a00 DPL=0 CS32 [-R-]<br>0008：代码选择器的可见部分。我们用0x8段，这还告诉我们我们正在引用全局描述符表（0x8&amp;4=0），而我们的CPL（当前特权等级）是0x8&amp;3=0。<br>10000000：这段的基础。线性地址 = 逻辑地址+这个段基<br>ffffffff：这段的界限，线性地址超过0xffffffff会导致段冲突。<br>10cf9a00：这段的原始（raw）标志，QEMU将在接下来的几个字段中对其进行解码。<br>DPL=0：这个段的特权等级，只有特权级别为0的代码才能加载这个段。<br>CS32：这是一个32位的代码段，其它值包括用于数据段的DS（不要和DS寄存器混淆），和用于本地描述符表的LDT。<br>[-R-]：这段（读写权限）是只读的。</p>
</blockquote>
<p>info mem：(lab 2+)显示映射的虚拟内存和权限，例如：</p>
<blockquote>
<p>ef7c0000-ef800000 00040000 urw<br>efbf8000-efc00000 00008000 -rw<br>从ef7c0000到ef800000的0x00040000个字节的内存被映射为可读写和用户可访问，而从efbf8000到efc00000的内存被映射为读/写，但只能内核能访问。</p>
</blockquote>
<p>info pg：（lab 2+）显示当前页表结构。输出和info mem类似，但区别页表目录项和页表项，并分别（separately）给出它们的权限。重复的PTE和整个页表折叠成一行。例如</p>
<blockquote>
<p>VPN range     Entry         Flags        Physical page<br>[00000-003ff]  PDE[000]     ——-UWP<br>[00200-00233]  PTE[200-233] ——-U-P 00380 0037e 0037d 0037c 0037b 0037a ..<br>[00800-00bff]  PDE[002]     —-A–UWP<br>[00800-00801]  PTE[000-001] —-A–U-P 0034b 00349<br>[00802-00802]  PTE[002]     ——-U-P 00348<br>这展示两个页目录项，分别横跨虚拟地址 0x00000000 - 0x003fffff 和 0x00800000 - 0x00bfffff。两个PDT都是存在的，可写的，用户的并且第二个PDT是被访问的。第二个页表映射三个页面，横跨虚拟地址0x00800000 - 0x00802FFF，其中前两个页表是存在的，用户的并且已经被访问，第三个仅是存在和用户的。这些PTE中的第一个PTE映射到物理页帧0x34b。</p>
</blockquote>
<p>QEMU还接受一些有用的命令行参数，可以用QEMUEXTRA变量将这些参数传给JOS makefile。<br>make QEMUEXTRA=’-d int’ …<br>将所有中断和寄存器转储记录到qemu.log。你可以忽略开头的两个记录项”SMM:enter”和”SMM:after RMS”，因为它们是在进入bootloader前生成的。在这之后，日志条目为：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/23/d4565dc5f2f619da9263aa95243a6e7f6d374cc7c9819176.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>第一行描述中断，”4”是日志记录计数器，”v”表示16进制的矢量数，e给出错误码。”i=1”表示这是通过int指令生成的（与硬件中断相比）。这行的剩余部分应该不需要加以说明。有关接下来的寄存器转储描述，请查看info registers。<br>注意：如果你运行的是0.15版本的QEMU，日志会被写到/tmp而不是现在的目录。</p>
]]></content>
      
        <categories>
            
            <category> MIT6.828 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> qemu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【MIT6.828】正式开工]]></title>
      <url>/zhoujiabo.github.io/2020/02/22/%E3%80%90MIT6-828%E3%80%91%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%B7%A5/</url>
      <content type="html"><![CDATA[<p>一、<big><strong>xv6了解与环境配置</strong></big>：<br><br>README<br>&emsp;xv6是对UNIX version 6(v6)的重新实现。它松散地遵循v6的结构和风格，它在现代基于x86的多处理器上用ANSI C标准实现的。<strong>xv6是以ELF二进制格式编译生成的给32位x86架构用的系统</strong>。<br></p>
<p>Tools used in 6.828<br>&emsp;两套工具：一个x86 仿真器-QEMU（为了跑内核），还有一套编译工具链，包括汇编器，链接器，C编译器和调试器(为了编译和测试内核)。有一些信息你需要下载和安装你的副本。（注意，你<strong>需要一定的UNIX命令基础</strong>）<br></p>
<p>我们强烈建议使用Debathena机器，如athena.dial .mit.edu，在实验室中工作。如果您使用的是运行Linux的MIT Athena机器（MIT的服务器），那么本课程所需的所有软件工具都在6.828的柜子中，只需输入’add -f 6.828’即可访问它们。<br></p>
<p>如果您无法访问Debathena机器，我们建议您使用一个带Linux系统的虚拟机。<br>（后面讲一些关于在实体机，如window, MacOS下配置环境的说明，没什么用。个人建议，在虚拟机上装Ubuntu 16）<br></p>
<p>测试工具链：<br>&emsp;objdump -i  —— 测试编译规则，输出应是elf32-i386（不是怎么办，直接在Makefile里设置gcc编译规则也可以）<br>&emsp;gcc -m32 -print-libgcc-file-name ——测试是否安装了gcc，输出应是一个路径<br>如果gcc命令失败，<br>&emsp;sudo apt-get install -y build-essential gdb<br>在64位机上，你可能需要安装一个32位支持包：<br>&emsp;sudo apt-get install gcc-multilib<br>    <br><br>构建自己的编译工具链：（不知道什么用，跳过了好像也没问题，只要安装了GCC和32位的支持包就够了）<br>&emsp;编译这些工具需要大量的磁盘空间（大概1GB）。</p>
<br>
QEMU仿真器：可惜的是，qemu的调试设备还不成熟。所以我们强烈推荐你使用我们补丁过的qemu来替代发行版本。（**要用mit打过补丁的qemu**）<br>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装补丁的qemu版本：</span><br><span class="line">a. 下载安装，github地址：https://github.com/mit-pdos/6.828-qemu</span><br><span class="line">b. 其它需要的安装包：libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, and libpixman-1-dev</span><br><span class="line">c. 配置源代码：</span><br><span class="line">./configure --<span class="built_in">disable</span>-kvm [--prefix=PFX] [--target-list=<span class="string">"i386-softmmu x86_64-softmmu"</span>]（方括号内i386-softmmu和x86_64-softmmu二选一，选择一个路径替代<span class="string">"PFX"</span>）</span><br><span class="line">d. 运行make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>二、<strong>xv6“试”行</strong><br><br>    我们先下载源码到虚拟机，make编译，并用qemu仿真器试着运行一遍。<br>好处：<br>    a. 完善一下环境（试水），如哪些东西是缺的，不然到时你都不知道是自己写的代码有问题还是配置环境不对。<br>    b. 先了解一下系统的结构，工作机制。有实物参考，我们再写代码实现会更容易一些。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/22/8c66089d2dbc26fbc4aebdd26de49df9b19b778eeb9d9832.th.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>cat、echo、grep、kill、ln、ls、mkdir、rm和wc等命令</p>
<p><strong>一切皆文件</strong>，“console  3  18  0“，console也是一个文件，它的文件类型为3，表示设备文件；节点号为18，它占用的硬盘空间是0字节。文件console是控制台，对应的物理实体是键盘和显示器，对console文件的读操作，相当于读取从键盘输入的字符，对console文件的写操作，则是在屏幕上显示字符。</p>
]]></content>
      
        <categories>
            
            <category> MIT6.828 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之磁盘与I/O子系统]]></title>
      <url>/zhoujiabo.github.io/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A3%81%E7%9B%98%E4%B8%8EI-O%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>内容概述：<br>&emsp;1. 大容量存储器结构：磁盘结构，传输时间，寻道时间，延迟时间，主机附属存储，网络附属存储NAS，存储区域网络SAN<br>&emsp;2. 磁盘调度：调度时机，FCFS算法，SSTF算法，SCAN算法，C-SCAN算法，LOOK算法，C-LOOK算法<br>&emsp;3. 磁盘管理：磁盘格式化，主引导块MBR<br>&emsp;4. 交换空间管理<br>&emsp;5. RAID结构<br><br>[简单理解磁盘结构（强力推荐，博主介绍得非常清晰）] (<a href="https://blog.csdn.net/heuguangxu/article/details/80072024" target="_blank" rel="noopener">https://blog.csdn.net/heuguangxu/article/details/80072024</a>)<br></p>
<p>Disk Management<br>启动块boot blcok - 启动块初始化系统<br>    &emsp;1. 引导程序存储在ROM中<br>    &emsp;2. 引导程序装载程序</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/21/b5370477781a36ffce9458185f1fa26cb8aa9d8bb315d77c.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>
交换空间
概念 ：虚拟内存使用磁盘空间作为主存的扩展
使用：
    &emsp;swap保存整个进程的映像，包括代码段和数据段
    &emsp;switch存储换出内存的页（交换空间太小容易导致死机现象）
位置：
    &emsp;1. 交换空间在普通文件系统上加以创建，通常是文件系统内的一个简单大文件（windows: pagefile.sys文件）这种方式实现简单但效率较低（外部碎片）
    &emsp;2. 交换空间创建在独立磁盘分区上（如linux）（内部碎片）
管理：内核使用交换映射来跟踪交换空间的使用<br>

<p><strong><big>I/O子系统</big></strong></p>
<p>I/O方式：轮询、中断、DMA、通道</p>
<blockquote>
<p>DMA（direct memory access）</p>
<ol>
<li>用来避免处理大量数据移动时按字节来向控制器送入数据的问题</li>
<li>需要DMA控制器</li>
<li>绕过CPU直接在内存与io设备之间进行数据传输<br></li>
</ol>
</blockquote>
<p>Devices vary in many dimensions：<br>    &emsp;1. character-stream or block（字符流或块设备）<br>    &emsp;2. sequential or random-access（顺序或随机访问）<br>    &emsp;3. synchronous or a synchronous（同步或异步）<br>    &emsp;4. sharable or dedicated（共享或独占）<br>    &emsp;5. speed of operation<br>    &emsp;6. read-write, read only, or write only<br></p>
<p>字符设备：（键盘、鼠标、串行口）<br>    &emsp;应用程序可以get或put字符，在此基础上，可以构造库以提供具有缓冲和编辑功能的按行访问<br>块设备：（磁盘驱动器）<br>    &emsp;以数据块为单元访问<br></p>
<p>阻塞 - 进程悬挂直到I/O完成为止<br>非阻塞 - io调用立刻返回<br>    &emsp;1. 用户接口，数据复制（缓冲IO）<br>    &emsp;2. 调用多线程实现<br>    &emsp;3. 立刻返回读或写的字节数<br>异步 - 进程与IO同时运行<br>    &emsp;1. 难以使用<br>    &emsp;2. 当io完成时，io系统发送信号通知进程</p>
<p><strong>非阻塞与异步系统调用的区别</strong>：</p>
<blockquote>
<p>非阻塞read调用会马上返回，其所读取的数据可以等于或少于所要求的，或为0。异步read调用所要求的传输应完整地执行，其具体执行可以是将来某个特定时间。</p>
</blockquote>
<p>io调度：<br>    &emsp;1. 确定一个好的顺序来执行这些io请求，来发送系统整体性能，进程之间公平地共享设备访问，减少io完成所需要的平均时间<br>    &emsp;2. 为每个设备维护一个请求队列来实现调度，当一个应用程序执行阻塞io系统调用时，请求加到相应设备的队列上。io调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间<br>    &emsp;3. 磁盘调度算法其实就是io调度的一种。<br>    &emsp;4. 其它实现方法：缓冲、高速缓冲、假脱机</p>
<p>内核io子系统负责：<br>    &emsp;a. 文件和设备命名空间的管理<br>    &emsp;b. 文件和设备访问控制<br>    &emsp;c. 操作控制<br>    &emsp;d. 文件系统空间的分配<br>    &emsp;e. 设备分配<br>    &emsp;f. 缓冲、高速缓冲、假脱机<br>    &emsp;g. io调度<br>    &emsp;h. 设备状态监控、错误处理、失败恢复<br>    &emsp;i. 设备驱动程序的配置和初始化</p>
<p>缓冲buffer<br>    &emsp;1. 缓冲buffering - 用来保存在两设备之间或在设备和应用程序之间所传输数据的内存区域。<br>    &emsp;2. 缓冲区管理：为了解决cpu和io之间速度不匹配的矛盾，在它们之间配置了缓冲区。这样设备管理程序又要负责缓冲区的建立、分配和释放<br>    &emsp;3. 缓冲作用：<br>        &emsp;&emsp;a. 解决设备速度不匹配<br>        &emsp;&emsp;b. 解决设备传输块的大小不匹配<br>        &emsp;&emsp;c. 减少CPU的中断频率，放宽对cpu中断响应时间的限制<br>        &emsp;&emsp;d. <strong>提高cpu和io设备之间的并行性</strong><br></p>
<p><strong>缓冲与高速缓存</strong></p>
<blockquote>
<p>相同点：都介于高速设备和低速设备之间<br>区别：cache存放的是低速设备上的某些数据的拷贝，也就是cache上有的低速设备上仍然有。而buffer是数据中转站，buffer中存放的数据在低速设备中不一定有备份。cache中存放的是高速设备经常要访问的数据，如果cache中没有数据，高速设备就会去访问缓冲区。<br></p>
</blockquote>
<p>单缓冲：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/21/94063b8280109b115d0daf2d2dc4f48aacb77afe4fc42a47.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>T和C可以并行执行，所以，系统对一块数据的处理时间为max(C,T)+M。（CPU在传送时间M处于空闲状态）。<br><br><br>双缓冲：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/21/92f646c10c9fdd1d1cdd81788f6d1375283623fbb8c50797.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>系统对一块数据的处理时间为max(C+M,T)，由于cpu读取缓冲区的速度比较快（相对于低速设备装入数据到缓冲区的时间），所以可以近似认为max(C,T)。<br><br><br>双向数据传输：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/21/d29686f7936d9ff8bc493759e24817ae8ec2a3ef274f0842.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>循环缓冲：包含多个缓冲区，可用一个循环队列来管理。</p>
<p><strong>缓冲池</strong>：由多个系统公用的缓冲区组成，缓冲区按其使用状况可形成三个队列：空缓冲队列，装满输入数据的缓冲队列（输入队列），装满输出数据的缓冲队列。<br></p>
<p>假脱机技术<br>&emsp;1. SPOOLING（simultaneous peripheral operation on line），称为假脱机技术。用来保存设备输出的缓冲，这些设备如打印机不能接收交叉的数据流。（操作系统通过截取对打印机的输出来解决这一问题。应用程序的输出先是假脱机到一个独立的磁盘文件上。当应用程序完成打印（输出打印数据到缓冲完成）时，假脱机系统将相应的待送打印机的假脱机文件进行排队）<br>&emsp;2. printing：打印机虽然是独享设备，通过假脱机技术，可以将它改造为一台可供多用户共享的设备。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之Linux文件系统]]></title>
      <url>/zhoujiabo.github.io/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8BLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>Linux文件系统概述<br>&emsp;1. Linux文件系统采用了多级目录的树型层次结构管理文件。树型结构的最上层是根目录，用/表示，在根目录下是各层目录和文件。<br>    &emsp;2. Linux系统中的文件系统，不管是什么类型，都安装到一个目录下，并隐藏掉目录中原有的内容。这个目录叫做安装目录或者安装点。当文件系统制裁掉时，目录中的原有内容将再一次的显示出来。<br>    &emsp;3. Linux通过使用一级通用的API函数，可以在许多种存储设备上支持许多种文件系统。<br>    &emsp;4. Linux缺省的文件系统（ext2, ext3, ext4）继承了UINX，把文件名和文件控制信息分开管理，文件控制信息单独组成一个称为索引节点（inode，一个数据结构）。每个文件对应一个inode，它们有唯一的编号，称为inode号。<br>    &emsp;5. 目录项主要由文件名和inode号组成。<br></p>
<p>文件的类型<br>    &emsp;1. 普通文件<br>        &emsp;&emsp;a. 文件名最长不能超过255个字符<br>        &emsp;&emsp;b. 可以用除保留字符以外的任何字符给文件命名<br>        &emsp;&emsp;c. 强烈建议不要使用非打印字符、空白字符（空格和制表符）和shell命令保留字符。<br>        &emsp;&emsp;d. 扩展名对Linux系统来说没有任何意义<br>        &emsp;&emsp;e. 可以任意给文件名加上你自己或应用程序定义的扩展名<br>    &emsp;2. 目录文件：是文件系统中一个目录所包含的目录项组成的文件。<strong>目录文件只允许系统修改。用户进程可以读取目录文件，但不能对它进行修改。两个特殊的目录项”.”表示目录本身，”..”表示父目录</strong>。<br>    &emsp;3. 字符设备文件和块设备文件。Linux把对设备的I/O作为对文件的读取/写入操作内核提供了对设备处理和对文件处理的统一接口。<br>        &emsp;&emsp;a. fd0(for floppy drive 0)<br>        &emsp;&emsp;b. had(for harddisk a)<br>        &emsp;&emsp;c. lp0(for line printer 0)<br>        &emsp;&emsp;d. tty(for teletype terminal)<br>    &emsp;4. 管道（FIFO）文件：用于在进程间传递数据。Linux对管道的操作与文件操作相同，它把管道作为文件进行处理<br>    &emsp;5. 链接文件：又称符号链接文件，它提供了共享文件的一种方法。<br>    &emsp;6. socket文件<br></p>
<p>文件系统类型<br>    &emsp;1. 三类文件系统：<br>        &emsp;&emsp;a. 基于磁盘的文件系统，如ext2/ext3/ext4，VFAT、NTFS等<br>        &emsp;&emsp;b. 网络文件系统，如NFS等<br>        &emsp;&emsp;c. 特殊文件系统，如proc文件系统、devfs、sysfs等<br>    &emsp;2. 支持多种不同类型的文件系统是Linux操作系统的一大特色。Linux在标准内核中已支持的文件系统超过50种<br>    &emsp;3. Linux的标准文件系统是ext系列，系统把它的磁盘分区作为系统的根文件系统。<br><br><br>VFS虚拟文件系统<br>    &emsp;1. Linux把各种不同的物理文件系统的所有特性进行抽象，建立起一个面向各种物理文件系统的转换机制，通过这个转换机制，把各种不同物理文件系统转换为一个具有统一共性的虚拟文件系统。这种转换机制称为虚拟文件系统转换VFS（Virtual Filesystem Switch）<br>    &emsp;2. VFS并不是一种实际的文件系统。ext2等物理文件系统是存在于外存空间的，而<strong>VFS仅存在于内存</strong>。<br>    &emsp;3. 在VFS上面，是对诸如open, close, read和write之类的函数的一个通过API抽象。在VFS下面是文件系统抽象，它定义了上层函数的实现方式。文件系统的源代码可以在linux/fs中找到。<br></p>
<p>目录项对象dentry object<br>    &emsp;a. 每个文件除了有一个索引节点inode数据结构外，还有一个目录项dentry数据结构<br>    &emsp;b. 每个dentry代表路径中的一个特定部分。/、bin、vi都属于目录 对象<br>    &emsp;c. 目录项也可包括安装点。如：/mnt/cdrom/foo，/、mnt、cdrom、foo都属于目录项对象<br>    &emsp;d. 目录项对象作用是帮助实现文件的快速定位，还起到缓冲作用</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/21/fdfe79ce229bdf4180bbb5b10caf269889b739f3553cca25.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>
文件管理和操作:<br>
&emsp;a. 对于系统中打开的文件，主要从两个方面进行管理，一是由系统通过系统打开文件表进行统一管理，另一是由进程通过私有数据结构进行管理。文件打开后要进行各种操作，VFS提供了面向文件操作的统一接口。
&emsp;b. 系统打开文件表：
&emsp;&emsp;a. Linux系统内核把所有进程打开的文件集中管理，把它们组成“系统打开文件表”
&emsp;&emsp;b. 系统打开文件表是一个双向链表，每个节点是一个file结构。
&emsp;&emsp;c. 进程打开一个文件就建立一个file结构，并把它加入到系统打开文件链表中
&emsp;&emsp;d. 全局变量first_file指向系统打开文件表的表头。

<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/21/1db553458a4a48ad9de18d039350d1a85ae194f988b93688.png" alt="" title="" class="">
                <p></p>
            </figure><br>

<p><strong>ext2文件系统</strong><br>    &emsp;a. ext2的绝大多数的数据结构和系统调用与经典的UNIX一致<br>    &emsp;b. 能够管理少量存储介质，支持多达4TB的数据，即一个分区的容量最大可达4TB<br>    &emsp;c. 允许通过文件属性改变内核的行为；目录下的文件继承目录的属性<br>    &emsp;d. 允许文件系统数据“即时同步”特性，即内存中的数据一旦改变，立即更新上的数据使之一致<br>    &emsp;e. 实现了“符号连接”（symbolic links）的方式，使得连接文件只需要存放inode的空间<br>    &emsp;f. 允许用户定制文件系统的数据单元（block）的大小，可以是1kb, 2kb, 或4kb，使之适应不同环境的要求<br>    &emsp;g. 使用专用文件记录文件系统的状态和错误信息，供下一次系统启动时决定是否需要检查文件系统</p>
<p>ext2在磁盘上的物理布局<br>    &emsp;ext2分区的第一个磁盘块用于引导，其余的部分被分成组。所有的组大小相同并且顺序存放，所以由级的序号可以确定组在磁盘的位置。<br>组的构成：<br>    &emsp;a. 文件系统的超级块 - 描述整个文件系统的信息<br>    &emsp;b. 所有组的描述符 - 记录所有块组的信息，如块组中的空闲块数，空闲节点数等。<br>    &emsp;c. 数据块的位图<br>    &emsp;d. inode位图<br>    &emsp;e. inode表 - 用来存放文件及目录的Inode数据，每个文件用一个Inode表示<br>    &emsp;f. 数据块</p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之文件系统]]></title>
      <url>/zhoujiabo.github.io/2020/02/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>文件”只是个逻辑概念，文件表示一段连接的逻辑地址空间。<br>文件类型<br>&emsp;○ 数据文件，包括数字文件，文本文件，二进制文件<br>&emsp;○ 程序</p>
<p>文件类型——以文件扩展名区分</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/ef3e1ea98041759ccc13fdc74a545aec5fb44c014304a803.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>文件结构<br>    &emsp;○ 无结构文件：一串字节流<br>    &emsp;○ 简单的记录型结构：行文件，固定长度文件，变长度文件<br>    &emsp;○ 复杂结构：格式化文档，重定位可执行文件<br>    &emsp;○ 可以在“无结构”文件中插入控制字符，就模拟了其它有结构类型的文件。</p>
<p>文件属性（attributes）<br>    &emsp;w 文件名——唯一一项以可行性指导文件信息<br>    &emsp;w 文件标识——在文件系统内部，文件的唯一身份标志（数字）<br>    &emsp;w 文件类型——OS用于支持各种类型文件<br>    &emsp;w 位置——文件内存在存储设备的首地址<br>    &emsp;w 长度——当前文件长度<br>    &emsp;w 保护——控制用户的读、写、执行等权限<br>    &emsp;w 时间，日期，用户标识——因为有人的保护、安全、监控操作时用到的数据<br>    &emsp;w <strong>关于文件的属性信息不是文件内容本身，保存在文件存储空间的目录结构中</strong>。<br></p>
<p>文件操作：<br>&emsp;创建文件，写，读，文件内定位（lseek），删除，截取（truncate）<br>&emsp;Open(Fi) - 在目录结构中执行文件Fi，并且将其文件属性复制到内存<br>&emsp;Close(Fi) - 将文件Fi的文件属性，从内存写回到磁盘的目录结构<br><br><br>磁盘I/O中几种访问文件的方式： <a href="https://blog.csdn.net/zhoucheng05_13/article/details/71771690?utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/zhoucheng05_13/article/details/71771690?utm_source=distribute.pc_relevant.none-task</a><br></p>
<blockquote>
<p>读取和写入I/O操作都调用操作系统提供的接口，因为磁盘设备是由操作系统管理的，应用程序要访问物理设备只能通过操作系统调用的方式工作。读和写对应read()和write()两个系统调用。以下是几种访问文件的方式：<br></p>
<ol>
<li>标准访问文件的方式：<br>读操作：当应用调用read()时，操作系统检查在内核的高速缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统中<br>写操作：用户应用程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说写操作就已经完成了，至于什么时候再写到磁盘中由操作系统决定，除非显式地调用sync同步命令。</li>
<li>直接I/O方式：<br>应用程序直接访问磁盘数据，而不经过内核的缓冲区，这样减少了一次从内核缓冲区到用户程序缓存的数据复制。这种访问通常出现于数据库等 对数据的数据管理由应用程序实现的管理系统中。</li>
<li>同步访问文件的方式：<br>数据的读取和写入都是同步操作的，它与标准访问文件方式不同的是，只有当数据被成功写到磁盘时才返回读/写操作成功的标志。这种方式性能较差，只有在一些对数据安全性要求比较高的场景中才会使用。</li>
<li>异步访问文件的方式：<br>当访问数据的线程发出请求后，线程会接着去处理其它事情，而不是阻塞等待（不需要等待操作成功返回标志）。可以提高应用程序的效率，不会改变访问文件的效率。</li>
<li>内存映射的方式<br>内存映射的方式是操作系统中将内存中的某一块区域与磁盘中的文件关联起来，当要访问内存的一段数据时，转换为访问文件的某一段数据。<br></li>
</ol>
</blockquote>
<p>目录结构：<br>&emsp;一堆节点的集合，节点包含了关于文件的信息。目录结构和文件一样，驻留在磁盘。<br>针对目录的操作：<br>    &emsp;a. 搜索文件<br>    &emsp;b. 创建/删除一个文件<br>    &emsp;c. 列表显示目录下的文件和子目录<br>    &emsp;d. 文件改名<br>    &emsp;e. 遍历文件系统</p>
<p>使用目录的好处：<br>    &emsp;a. 效率 - 快速定位文件<br>    &emsp;b. 命名 - 方便用户<br>    &emsp;c. 成组操作 - 将文件属性相同的文件，组合起来</p>
<p> 树型目录结构：（高效搜索）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/808932a9687ebc8a1bba11411b24a84118fa7b125bb8e4c1.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>有向无环图目录结构：（共享子目录）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/014008a282ce02a275be4b6bbedf73d1e209cd1f7c7a454b.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>目录结构存在环怎么办？<br>    &emsp;• 规定links只能指向文件，不能指向子目录<br>    &emsp;• garbage collection算法清理孤立环<br>    &emsp;• 每当创建link，调用环检测算法，确保不存在环</p>
<p>文件系统分区（Partitions）<br>    ® A disk be sliced into multiple partitions<br>    ® A partition span multiple disks - RAID<br>    ® “raw partition/disk” - no file system<br>    ® “cooked partition” - contain a file system<br>    ® Boot information in a separate partition（独立分区）<br>    ® Root partition - contain OS kernel and other system file<br>    ® Mount table in its in-memory contains the information of mounted file systems（挂载表会记录挂载到当前系统的其它硬件设备的文件系统）<br></p>
<p>系统系统安装（mounting）<br>&emsp;文件系统必须先安装好（明确了访问目录），才能被访问；一个文件系统被安装在安装点（mount point）。</p>
<p>多用户系统之文件共享<br>    &emsp;○ User IDs 标识用户身份，可以针对用户设置访问许可、保护级别<br>    &emsp;○ Group IDs 标识一组用户，设置这个组所有用户的访问权限</p>
<p>保护（protection）——文件拥有者/文件创建者有权限决定，谁可以操作文件，可以对文件做什么<br>访问类型——读、写、执行、附加、删除、列表。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/e90ccce07efc19cff3c638f64e7f45701fd469e9d7f3e2c0.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>UNIX目录列表：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/a2a8d2c6ad509f9911b7366b10b1c4b6da16382df6a4b338.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>文件系统管理的一些事实<br>    w 文件的结构<br>        &emsp;a. 基本的逻辑存储单元，称数据块（data blocks）<br>        &emsp;b. 文件管理信息，保存在文件控制块FCB<br>    w 文件系统被设计成层次化的管理体系<br>    w 文件系统通常驻留在辅存（disks）。要求文件系统的管理：高效、方便地访问磁盘上的数据<br>    w 磁盘的设备驱动程序只是控制物理设备，也就是磁盘。</p>
<p>层次化的文件系统管理：<br>&emsp;（从上到下）application programs →logical file system →file-organization module →basic file system →I/O control →devices</p>
<pre><code>® I/O control, the lowest level
    a. Device drivers
    b. Interrupt handlers
® Basic file system - Issue generic commands to read and write
® File-organization module
    ○ File and their logical blocks, physical blocks
    ○ Free space manger
® Logical file system
    ○ Manage metadata information
    ○ Manage directory structure
    ○ Maintain file structure via(通过) file control blocks
    ○ Responsible for protection and security</code></pre><p>Layered File System, apllication<br>    &emsp;○ Unix：Unix file system(UFS)<br>    &emsp;○ Windows NT：FAT, FAT32, NTFS<br>    &emsp;○ Linux：ext, ext2, ext3, msdos, vfat, iso9660, hpfs等多种文件系统</p>
<p>文件系统管理的一些事实<br>    &emsp;1. 引导块（Boot）- 保存特殊的代码和数据，目的是将OS磁盘引导到内存<br>    &emsp;2. 分区控制块保存分区的详细信息<br>    &emsp;3. 目录结构用于组织、管理文件</p>
<p>一个典型的文件控制块：<br>    &emsp;○ file permissions<br>    &emsp;○ file dates(create, access, write)<br>    &emsp;○ file owner, group, ACL<br>    &emsp;○ file size<br>    &emsp;○ file data blocks or pointers to file data blocks</p>
<p>示例：内存中的文件系统结构：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/46ac24f6d39df1ed99812c134e5606c7196012bddb8cd299.md.png" alt="" title="" class="">
                <p></p>
            </figure><br>
<p>虚拟文件系统<br>    &emsp;○ 虚拟文件系统（VFS），借用面向对象思想实现文件系统<br>    &emsp;○ VFS为用户提供统一的系统调用界面，却能够访所有类型的文件系统<br>    &emsp;○ 用户编程时使用的API，只需要接口VFS的界面，不必接口任何类型的文件系统<br></p>
<p>目录实现：<br>    &emsp;1. 关于文件名的线性列表，除了文件名，表项内含指针，指向文件的数据块。实现简单，时间很杂度不好<br>    &emsp;2. 哈希表 - 线性列表，再加上哈希数据结构。减少了目录项查找时间，要处理冲突。<br></p>
<p>&emsp;为了实现用户对文件的按名存取，系统必须首先利用用户提供的文件名，对文件目录进行查询，找出该文件的文件控制块FCB，对UNIX系统即要找出 该文件的索引节点。然后根据找到的FCB中所记录的文件物理地址，并根据文件物理组织方式找出 文件的盘块号，进而换算出文件在磁盘上的物理位置（柱面号、磁头号、扇区号），最后启动磁盘驱动程序，将所需文件读入内存。<br></p>
<p>磁盘空间分配给文件 ——如何将磁盘数据块分配给文件<br>    &emsp;1. 连续分配，Contiguous allocation<br>    &emsp;2. 链接分配，Linked allocation<br>    &emsp;3. 索引分配，indexed allocation<br></p>
<p><strong>连续分配</strong>：<br>    &emsp;1. 每个文件占有磁盘中一串连续的数据块<br>    &emsp;2. 实现简单 - 只需要给出起始位置（块号）和文件长度（数据块总数）<br>    &emsp;3. 支持随机访问<br>    &emsp;4. 问题：碎片浪费（动态存储空间分配问题），不方便文件长度扩展<br><br><strong>链接分配</strong>：<br>    &emsp;1. 文件存储在一个磁盘数据块的链表中<br>    &emsp;2. 数据块可以分散各处。只要有空闲块，都可以利用。<br>    &emsp;3. 实现简单，磁盘数据块充分利用<br>    &emsp;4. 问题：不支持随机访问，太依靠数据块中的指针，要求磁盘设备可靠性好<br></p>
<p>FAT表结构：<br>&emsp;MS-DOS文件系统的文件物理结构采用FAT表结构。该结构为了克服链接文件随机读取任一逻辑块需要花费多次磁盘IO操作的不足，将各盘块中的链接指针集中存放在盘的开始部分，构成一张表，称为FAT表。FAT表每一项存放链接指针（下一个簇号），每个FAT表项占12位或16位，对于硬盘则采用16位FAT表。</p>
<p>&emsp;FAT表原为小硬盘的目录结构而设计，由于簇的数目最多只能用16位表示，，即最多只能有64K个簇，要用FAT表管理在的磁盘分区，只能采取增大每簇所包含的扇区数，一般根据磁盘的类型和容量大小来决定簇的大小。那当然每簇包含扇区数增加，带来内碎片的浪费，这对小文件特别严重。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/74054c975f4d6495b318a3335363d64446ded43771573e80.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;Windows98为了减少内碎片的浪费，可采取每簇的数目用32位表示，减少每簇包含的扇区数，这称为FAT32<br></p>
<p><strong>索引分配方法</strong>：<br>    &emsp;1. 将链表分配方法的数据块指针，全部归置到一个数据块，称作索引块（indexblock）<br>    &emsp;2. 优点：支持随机访问，支持动态伸缩文件长度，没有外部碎片<br>    &emsp;3. 缺点：需要一个索引数据块，访问索引数据块，增加开销</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/b4c1eb3fa0ec60567373d3e9ebb6d9cacf6dfd8be0d0b7f2.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>UNIX/Linux直接间接混合分配方式</strong>：<br>    &emsp;1. <strong>由于80%以上文件是小文件</strong>，为了解决能高速存取小文件和管理大文件的矛盾，UNIX将直接寻址、一级索引、二级索引和三级索引结合起来，形成了混合寻址方式<br>    &emsp;2. 假设每个盘块大小为4kb，当文件不大于40Kb时，可直接从索引结点中读出该文件全部盘块号，这样读小文件时速度快；如果文件大于40kb时，<u>系统再逐步增加一级索引、二级索引、三级索引，这样对应可管理的文件大小为4MB、4GB、4TB，达到管理大文件的目标</u>。<br></p>
<p>空闲空间管理 - <strong>位图</strong></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/20/1fc47a834eb79c70b3409372e42f0f2d1f4010073b37bb9a.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;假如每个数据块长度为4KB，磁盘空间容量为4GB，则数据块总数为2^20，<br>位图额外的内存开销为128KB。<br></p>
<p>空闲空间管理 - 链表<br>&emsp;空闲数据块链表，与链接分配方法配合使用，不浪费空间。但不容易整合出连续空闲空间。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之虚拟内存技术]]></title>
      <url>/zhoujiabo.github.io/2020/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p><strong>几个事实</strong>：<br>&emsp;1、CPU能访问多大的内存空间取决于CPU的程序计数器，该计数器的字长越长，能访问的空间就越大。如对于程序计数器为32位的CPU，它最大能访问内存空间为4G（2^32）。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/df8a63741ae68cd19ab97243d5e4f1372a1d0a2cd64fe61a.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;2、计算机配置内存的实际空间常常小于处理器的寻址范围，如图，32位寻址能力的处理器只配置了256M的内存。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/afab27b59f6241ef5a9e7ba67dca17fbde494780c3a4d9fd.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;3、还有一些处理器因外部地址线的根数小于处理器程序计数器的位数，使地址总线的根数不能满足处理器的寻址范围。如Intel8086处理器的程序计数器32位，而处理器芯片的外部地址总线只有20根，所以它所能配置的内存只有1MB。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/00da96c6603616f57cc021a3969745e139a46f82c11d8c13.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;4、一个应用程序总是逐段被运行，而且在一段时间内会稳定运行在某一段程序里。（时间片轮转调度）<br>&emsp;5、进程对于物理空间的需要：<br>    &emsp;&emsp;a. 进程只需要一小部分的代码（请求CPU执行的代码部分）驻留内存<br>        &emsp;&emsp;b. 进程的逻辑空间可以远大于（分配给它的）物理空间<br></p>
<p>什么是虚拟内存：</p>
<blockquote>
<p>计算机系统内存管理的<strong>一种技术</strong>。它使得应用程序认为它拥有连续的可用内存（一个连续完整的地址空间），而实际上，进程通常会被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘（辅存）上，在需要时进行数据交换。目前大多数操作系统者使用了虚拟内存，如windows家族的”虚拟内存“，Linux的”交换空间“（十分形象）。</p>
</blockquote>
<p>大概的工作原理（方便理解）：<br>&emsp;把进程中要运行的程序从辅存中复制装入到内存运行，而其他暂时不运行的程序段就让它留在辅存。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/91391b217399f4087cf461187fe6dc5bd650756fa5f8fdfa.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;当需要执行另一段程序时，把内存中的程序段放回辅存，在内存腾出必要的空间后，再把辅存中的程序段装入内存来运行。（这个技术叫”swap“）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/06eaa6be9190059b4b8eae14bf1acdc6c2b33234eebae910.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;（计算机中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会出现内存不够用的情况，虚拟内存技术就是为解决这个问题而诞生的，系统拿出一部分硬盘空间来充当内存使用，虚拟内存就是硬盘上的一个超级大的文件，文件名为PageFile.Sys）<br></p>
<p>程序员看到的只是虚拟内存空间和虚拟地址，而处理器片外地址总线看到的是物理地址空间和物理地址。<br>如何将虚拟内存空间映射到真正的物理空间？<br>&emsp;这个工作需要软硬件共同完成，承担这个工作的硬件部分叫存储管理单元MMU，软件部分就是操作系统的内存管理模块。<br>Linux把虚拟空间分成若干个大小相等的存储分区，这样的分区叫做页。操作系统的内存管理模块建立了页表专门来映射物理地址。<br></p>
<p>虚拟内存的实现策略有按需调页（Demand paging）和Demand segmentation.<br>按需调页：<br>&emsp;CPU指令含内存访问，即访问该内存地址所在页面。称作页面引用（reference）。<br>存在有三种可能：<br>&emsp;a. 页面已经装入内存，有对应页帧 →CPU完成操作<br>&emsp;b. 非法的页面引用 →abort<br>&emsp;c. 合法引用，但是页面不在内存 →把页面装入内存</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/ab0bf2fdd1bd41bc275dfe15d4ac0fee082e15061ce15e49.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>有效位（valid-invalid bit）<br>&emsp;为每个进程的每个页表项，设计一个“有效位”，”v”表示页面驻留内存，”i”表示进程非法访问该页面，或者页面不存在。<br>初始化时，所有”有效位“都设置成”i”。<br><strong>CPU执行指令，访问内存单元时，一旦读到某个页表项，其“有效位”是”i”，则会引起缺页中断（page fault）</strong></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/cf978c464e184bd8ccc4b37ed1046796cbf24bcb018513c5.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>中断过程：<br>&emsp;1. 操作系统查找内存的数据结构，判断<br>        &emsp;&emsp;a. 它是非法引用 →abort<br>        &emsp;&emsp;b. 它是合法引用，但是页面不在内存<br>    &emsp;2. 操作系统查找内核的数据结构，找出一个空闲页帧<br>    &emsp;3. 把页面从外存换入至该空闲页帧<br>    &emsp;4. 更新内核的数据结构，更新进程的页表<br>    &emsp;5. 把进程页表中（该页面）页表项的有效位重置为v<br>    &emsp;6. 缺页中断程序返回，重新执行引起缺页中断的那条指令<br></p>
<p>当且仅当需要该页面时，才把它调入内存。<br>Lazy swapper ——从不换入这个页面，除非有进程真的访问这个页面。<br></p>
<p><strong>如果缺页响应时没有空闲页帧，如何调页？</strong><br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/cabe8f73b351f6368efaf971b803645ff6ba95929f1a6537.md.png" alt="" title="" class="">
                <p></p>
            </figure>

<p>因为换入换出操作涉及外存，（外存的访问比正常的内存访问慢几十倍）时间开销比较大。所以在没有空闲页时，我们要想办法让换出和换入的次数不会很多。</p>
<p>页面转换（Page Replacement）<br>&emsp;如果找不到空闲页帧，选择一个“牺牲者”页帧，换出位于该页帧的页面。<br><strong>一个技巧</strong>——利用modify(dirty) bit，减少页面传输的开销<br>&emsp;换出页面时判断，该页面装入后有没有被修改过，<strong>如果没被修改过，就不需换出，可直接丢弃；因为交换区里有它的备份</strong>。只有被修改过的页面才有必要换出，也就是更新交换区的备份。<br></p>
<p>Optimal算法：转换掉整个过程中最长时间不被引用的页面。（无法预知，最优但无法实现，用来作为性能分析的参考）</p>
<p>LRU（least recently use）算法：如何知道哪个进程最近最长时间没引用。<br>&emsp;○ 利用计数器实现<br>&emsp;——每个页面带一计数器，每次引用页面时，页表项的计数器更新为当时的时钟值；调用转换算法时，选取计数器最“早”的页面换出<br>&emsp;○ <strong>利用堆栈实现</strong><br>&emsp;——设计双向链表维护一个堆栈，<strong>引用某页面时，将该页面移动至栈顶；页面转换时，不需要搜索，直接选取页面</strong></p>
<p>近似LRU算法：<br>    ○ <strong>引用位（Reference bit）</strong><br>    ——每个页表项设计1位，引用位。初始时为0；页面被访问时，引用位被置1，需要置换页面时，问题选取引用位为0的页面（如果存在这样的页面），近似算法不规定所有引用位为0的页面的顺序。<br>    ○ <strong>计数（counting）</strong><br>    ——每个页面附着一个计数器，记录页面的引用次数。选取计数值最小或最大的页面换出。（难以判断，计数值小可能是刚装入内存）<br>    ○ <strong>Second chance算法（也称lock算法）</strong><br>    ——也需要引用位，需要置换页面时，（顺时针顺序）考察下一个页面，<strong>如果引用位是0，则选中。如果其引用位为1，则引用位被置0，留在内存，这次不选；顺时针继续考察下一页面</strong>。重复上述过程。<br></p>
<p>在为进程分配内存时，将涉及到<strong>三个问题</strong>：</p>
<blockquote>
<ol>
<li>为保证进程能正常运行，所需的最小页帧是多少</li>
<li>在为每个进程分配物理块时，应采取什么样的分配策略，分配的物理块是固定的，还是可变的</li>
<li>为不同进程所分配的物理块数是采取平均分配算法，还是根据进程的大小按比例分配<br></li>
</ol>
</blockquote>
<p><strong>几个概念</strong>：</p>
<blockquote>
<ol>
<li>固定分配，为每个进程分配一组固定数目的物理块，在进程运行期间不再改变</li>
<li>可变分配，先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少</li>
<li>局部置换，进程只能从它自己占用的页帧中选出一个，进行置换</li>
<li>全局置换，从所有页帧中选取，可以选取其它进程占用的页帧<br></li>
</ol>
</blockquote>
<p>系统抖动<br>    当进程没能拥有足够的页帧，会导致很高的缺页次数。其后果：<br>&emsp;a. 很低的CPU利用率<br>&emsp;b. 误导OS以为有必要提高多任务的程序<br>&emsp;c. 误导OS装入更多作业，内存中驻留更多进程<br>&emsp;d. 于是每个进程拥有的页帧数更少，，一直恶性循环下去<br>抖动（Thrashing）——进程忙于换入换出页面。（解决：可选择挂起一个或几个进程）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/3a58dca988255aab77d3fa1c9c3e1d15d6779cd9f6a19996.md.png" alt="" title="" class="">
                <p></p>
            </figure><br>

<p><strong>伙伴（Buddy）算法分配连续块</strong>——找到符合申请长度的连接块，先不马上分出去，把数据块一分为二，判断分割后的数据块是否仍然满足申请长度，如果满足继续“一分为二”，如果不满足，那么把分割前的连续块分配出去。当数据块被用完释放后，又可以逆向合并数据块成一个更大的连续块。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之三种页表]]></title>
      <url>/zhoujiabo.github.io/2020/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%A1%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><font color="red"><big>页表的数据结构</big></font><br>    &emsp;a. Hierarchical Page Table<br>    &emsp;b. Hashed Page Table<br>    &emsp;c. Inverted Page Table<br></p>
<p><font color="red"><big>层次页表（Hierarchical Page Table）：</big></font><br>    &emsp;将页表的逻辑地址拆分成多张页表。<br>    &emsp;a. 好处：可以离散存储页表（页表目录和页表项存放在内存的不同位置）<br>        减少页表对内存的占用<br>&emsp;坏处：寻址次数增加，意味着访问时间增加。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/9a260c796a7ea9b0fda24e6c2586c63a3f27122d6e0f6197.png" alt="" title="" class="">
                <p></p>
            </figure>

<p><strong>为什么用多级页表可以节省内存空间</strong>？<br>&emsp;在32位地址空间上，2^32 = 4G（内存空间），假设每个页大小为4K。<br>&emsp;用一级页表，需要页号个数 = 4G/4K = 1M个（2^20，需要20位来存，则页号的数据类型应是u32）<br>则每个页号占4byte，页表总共需要的内存空间为4M（4byte x 1M个）；<br>&emsp;如果用二级页表，假设每个目录大小为4M，则目录个数 = 4G/4M = 1024个，目录中每个页大小为4k，则每个目录中的页数为4M/4k= 1024个。(1024=2^10，目录号和页号的数据类型可以为u16,u32）假设这里每个目录号和页号占4字节，则页表总共需要的内存空间为8K（4byte<em>1024+4byte</em>1024）。<br></p>
<p><font color="red"><big>哈希页表（Hashed Page Table）：</big></font></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/bb9b30d8f5a78149101cc87c41740a5da87db9e539090f73.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;a. 多见于地址空间大于32位的CPU<br>&emsp;b. 数据结构：页表的每一个条目都是一个元素集合，这些元素哈希成同一位置形成链表（要处理碰撞）。每个元素有3个域：虚拟页码（哈希值），所映射的帧号，指向链表中下一个元素的指针。<br>    &emsp;c. 工作方式：虚拟地址中的虚拟页号转换到哈希表中，用虚拟页号与链表中的每一个元素的第一个域相比较。如果匹配，那么相应帧号（第二个域）就用来形成物理地址；如果不匹配，那么就对链表中的下一个节点进行比较，以寻找一个匹配的页号。<br></p>
<p><font color="red"><big>反向页表（Inverted Page Table）：</big></font></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/fe20cfad58ad57719021119b5735cc152c353cd7d290c54f.png" alt="" title="" class="">
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/19/f8d1bba8ba3e7d2ed86ad295fa535086862ac9ada0ef0373.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>设计思想：在传统页表基础上，为每个物理页增加一个“反向指针集合“，指向使用该物理页的各个页表项，形成物理地址到虚地址的反向映射</strong><br>特点：<br>    &emsp;a. <strong>一个操作系统中只有一个反向页表</strong><br>    &emsp;b. 反向页表对于每个真正的页帧才有一个条目，每个条目包含保存在真正内存位置的页的虚拟地址，以及拥有该页的进程的信息。<br>    &emsp;c. 相对传统的页表，它减少了存储每个页表所需要的内存空间，但它引用页时，大大增加了查找页表所需要的时间。（优化方案：可利用哈希表快速定位，降低查找难度）<br>    &emsp;d. 内存管理器为每个物理页建立了一个链表，包含了指向映射这个页的每一个进程的页表条目的指针。这个链表叫做PTE（page table entries），它能方便地找到映射到指定页帧的进程的速度。<br>    &emsp;e. <a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84/20835372" target="_blank" rel="noopener">反向映射</a><br>评价：<br>    &emsp;a. 反向页表是操作系统中实现快速实虚转换，支持页迁移的关键部件，它的实现有利于提高页迁移的效率。<br>    &emsp;b. 反向页表技术，弥补了仅仅依靠正向页表实现实虚映射所带来的开销，能够通过迁移页的物理地址快速定位需要修改的进程页表项。<br>    &emsp;c. 不足，系统中的每一个物理页结构都要维护一个额外的链表结构pte—chain．一个内存大小为256MB的系统中物理页的数目为64k，则需要为反向页表分配64×(sizeof(structpte—chain))kB大小的物理内存（尽管如此，经过测试，在高端系统和负载很大的情况下，反向页表支持的页迁移系统性能明显优于传统页迁移系统）<br>    &emsp;d. 改进，链表节点不再是“引用该物理页帧的所有页表项”，而是“相应的的虚拟内存区域（vm_area_struct结构）”，虚拟内存区域通过内存描述符（mm_struct结构）找到页全局目录，从而找到相应的页表项，在一定程度上能节约内存空间。（减少了每个PTE的长度）</p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之内存管理前序]]></title>
      <url>/zhoujiabo.github.io/2020/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%89%8D%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>基本概念和背景<br><br>&emsp;a. 内存包括主存（内存条，基于DRAM）和高速缓存（Cache，基于SRAM）两部分。<br>&emsp;b. 程序必须装入内存后，才能（以进程为单位）被CPU解释、执行。<br>&emsp;c. CPU能直接访问的，只有主存、寄存器<br>&emsp;d. 访问寄存器需要一个CPU时钟周期，很快；访问主存需要许多时钟周期，或者需要若干机器周期<br>&emsp;e. Cache位于主存、寄存器之间<br><br>&emsp;（高速缓冲存储器Cache主要是为了解决CPU和主存速度不匹配而设计的。Cache一般由SRAM芯片实现，它的存取速度接近CPU，快于DRAM，存储容量小于DRAM。它比主存的优先级高，CPU存取信息时优先访问Cache，找不到的话再去主存DRAM中找，同时把信息周围的数据块从主存复制到Cache中）<br><br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/18/5e5eafeeb0b6214c6f6916d93db2eb8008597566ba4beb76.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>汇编器Assembler<br>任务：<br>    &emsp;a. 把符号指令翻译成二进制指令<br>    &emsp;b. 把标号labels翻译成地址<br>    &emsp;c. 处理伪指令（pseudo-ops）<br>区别于编译，它基本上是one-to-one的翻译<br>产生的目标文件（object file）添加了<br>    &emsp;a. Text段：代码<br>    &emsp;b. Data段：初始化了的全局变量<br>    &emsp;c. Bss段：示初始化的全局变量<br></p>
<p>基地址寄存器和界限寄存器共同划定逻辑地址空间</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/18/76fa085098e7df67338314c2b17bd5a969f52c6961d29b82.png" alt="" title="" class="">
                <p></p>
            </figure><br>
<p>指令和数据的地址绑定（Binding）<br>指令和数据的地址绑定通常发生在3个阶段：<br>    &emsp;• 编辑时（学习汇编）：如果代码、数据的存放首地址已知，编译阶段即可确定绝对地址。如果首地址变更，则需要重新编译<br>    &emsp;• 装入时（学习单用户OS）：如果代码、数据的存放首地址未知，编译阶段生成可重定位地址，装入时才确定绝对地址<br>    &emsp;• 执行时（学习OS原理）：如果允许进程在执行时迁移其代码、数据，那么，地址绑定也在执行时进行。需要硬件装置支持其地址映射。（e.g. 基地址寄存器各界限寄存器）<br></p>
<p>区别于物理地址的各种逻辑地址空间是OS得以管理内存的必要条件<br>    &emsp;a. 逻辑地址 - generated by the CPU; also referred to as virtual address.<br>    &emsp;b. 逻辑地址 - 非物理的各种地址标记，包括符号名，包括编译、汇编、连接、装入操作产生的地址<br>    &emsp;c. 物理地址 - 内存单元接收到的地址。也就是说，”浮现“在地址总线上的地址，以二进制形式表达。</p>
<p>存储管理单元（MMU）<br>&emsp;MMU（Memory-Management-Unit）是CPU内部的硬件装置，其功能是将虚拟地址（或逻辑地址）转换成物理地址。</p>
<p>&emsp;例如一种简单的MMU策略，在用户进程将逻辑地址送往地址总线前，MMU把重定位寄存器（relocation register）的值，加到这个逻辑地址。<br>基于重定位寄存器的动态重定位（Dynamic relocation）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/18/2f7a511321d8a3430d34ecc2b9987abbc2b06c6f2b92bdc7.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>用户进程只能处理逻辑地址</strong>，无法获取真正的物理地址。<br></p>
<p>动态连接（Dynamic Linking）<br>&emsp;○ 进程即将用到的代码段，不被预先连接入程序，只有真正被调用的时刻才连接。<br>&emsp;○ 需要动态连接库（Linux的.so，或者Windows的.dll）的配合<br><br>&emsp;○ 设计一小段代码，称stub<br>&emsp;○ 当真正调用该段代码时，<strong>通过stub定位该段代码，或从外部装入内存</strong>。</p>
<p>动态装入（Dynamic Loading）<br>&emsp;○ 进程即将用到的子程序，不被预先装入，只有到真正被调用的时刻才装入内存<br>&emsp;○ 这样，进程本次运行中没有调用的子程序，就不会被装入内存，更有效地利用了内存空间<br>&emsp;○ 不需要操作系统的特别支持<br><br><br><strong>覆盖（overload）</strong>：<br>&emsp;一个程序不需要反所有的指令和数据都装入内存，而是将程序划分为若干个功能相对独立的程序段，按照程序的逻辑结构让那些不会同时执行的程序段共享同一块内存区。早期的计算机系统中使用覆盖技术来扩充内存，不过要求程序员手动对程序进行分块，这是一个费时费力让人头痛的事情。<br></p>
<p><strong>交换（Swapping）</strong>:<br>&emsp;进程映像暂时传输至后备存储空间保存（换出，swap out），需要执行时再装入内存（换入，swap in）。称为”交换“<br>&emsp;○ 后备存储空间<br>&emsp;&emsp;        ○ 快速<br>&emsp;&emsp;        ○ 大容量<br>&emsp;&emsp;        ○ 直接访问机制（direct access）<br>&emsp;○ 交换操作结合cpu调度算法，使得及时换出低优先级的进程，让高优先级的进程装入、执行<br>&emsp;○ 大部分交换时间用于传输。传输时间与交换数据量成正比<br>&emsp;○ 交换的思想或变种，频频见诸于UNIX、Linux、Windows等<br>&emsp;○ 系统只要保障就绪队列里的就绪进程全部驻留内存。其它进程映像可以被换出。<br></p>
<p>存储管理基本思想<br>&emsp;y = f(x)<br><br>存储管理算法的评估和比较<br>    &emsp;○ 硬件支持，Hardware Suppot<br>    &emsp;○ 性能，Performance<br>&emsp;○ 碎片，Fragmentation<br>    &emsp;○ 重定位，Relocation<br>&emsp;○ 交换，Swapping<br>&emsp;○ 内存共享，Memory sharing<br>&emsp;○ 内存保护，Memory protection<br></p>
<p>连续区内存分配<br>&emsp;    ○ 把主存划分成两个分区（partitions）<br>&emsp;&emsp;        a. 操作系统占一个分区，通常驻留主存的低端（低地址），中断矢量也在低端<br>&emsp;&emsp;        b. 用户进程占另一个分区，通常在主存的高端<br>&emsp;    ○ 运用重定位寄存器（Relocation registers）防止用户进程访问其它进程的空间，篡改操作系统的代码、数据<br>&emsp;&emsp;        a. 基地址寄存器（Base register）保存了进程物理地址的首地址<br>&emsp;&emsp;        b. 界限寄存器（Limit register）保存了逻辑地址的地址范围，任一个逻辑地址必须小于界限寄存器的值<br>&emsp;&emsp;        c. MMU能够动态地映射每一个地址<br></p>
<p>多重分区（Multiple-partition）连续区分配<br>&emsp;    ○ Hole - 有效可分配的内存块<br>&emsp;    ○ 多个长度不等的holes散布在内存各区域<br>    &emsp;○ 当一个进程申请进入主存时，OS选出一个hole，其长度足够容纳进程的映像。它就是分配给该进程的分区（partition）<br>    &emsp;○ OS维护一些管理信息，包括<br>    &emsp;&emsp;    a. 已经分配的分区<br>    &emsp;&emsp;    b. 可分配的分区（hole）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/18/f50ed12ef9e88a5e729b2716485ee041dc07fa1ced0e5f6b.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>如何找Hole?<br>&emsp;动态存储分配问题：如何在一串holes中找出一个能存储n个单元的hole<br><br>&emsp;    a. First-fit：找到第一个足够大的hole<br>&emsp;    b. Best-first：在所有足够在的holes里面找出最小的一个hole。（要遍历整个列表；可以先升序排序，然后first-fit。）<br></p>
<p><strong>碎片（Fragmentation）</strong><br>&emsp;    ○ <strong>External Fragmentation</strong>，这些内存块加起来能够满足一个请求，但是由于不连续（中间有断层），不能用来连续区分配。<br>&emsp;    ○ <strong>Internal Fragmentation</strong>，分出去的分区略大于请求的内存长度。这个余下的小内存块属于该分区，但是无法利用。（无法避免）<br></p>
<p>紧缩（compaction）操作减小external fragmentation<br>&emsp;    ○ 重排内存块，使所有空闲内存连续排列，合并成一块大的内存块<br>&emsp;    ○ 前提条件：<br>&emsp;&emsp;        a. 代码、数据可重定位<br>&emsp;&emsp;        b. 重定位可以在运行时操作<br></p>
<p>页式内存管理<br>&emsp;    ○ 注意一个事实：<strong>进程并不要求逻辑地址必须连续</strong><br>&emsp;    ○ 把物理空间等分成长度一致的数据块，称作“页帧”（frames）<br>&emsp;    ○ <strong>把逻辑空间等分成长度一致的数据块，称作“页”（pages），并且与页帧长度相等</strong><br>&emsp;    ○ 通常页长（也是页帧长度）是2的次幂，取512byte到8192byte之间的数值<br>&emsp;    ○ OS负责监控所有空闲页帧<br>&emsp;    ○ 若进程需要n页逻辑空间，OS分配n个空闲页帧给它，装入代码和数据<br>&emsp;    ○ OS分配页表需要的物理空间，布置好页表（就是映射函数）<br>&emsp;    ○ 页式内存管理存在Internal fragmentation问题<br></p>
<p>页表：<br>&emsp;页表是一种特殊的数据结构，存放在系统空间的页表区，存放逻辑页和物理页帧的对应关系。每个进程都拥有一个自己的页表，PCB表中有指针指向页表。<br></p>
<p>如何实现页表？<br>&emsp;页表基地址寄存器Page-table base register，指向页表的首地址<br>&emsp;页表长度寄存器Page-table length register，表示页表占用的空间长度<br>&emsp;○ 访问一个数据/地址，<strong>需要两次内存访问</strong>！（1次访问页表取得页帧位置，1次访问页内偏移地址取得数据）</p>
<p>解决2次访问问题，借助translation look-aside buffers（TLBS）<br>TLB也称为关联存储器Associative memory<br>&emsp;特征 - 并行搜索<br>&emsp;TLB用于对（p,d）的地址翻译；<strong>有助于更快速地获取物理页帧号</strong>。如果p恰好在TLB(hit)，直接从TLB得到页帧号；否则从内存页表中取得页帧号</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/18/a69027af08b107a3cb9b36b555ffcf6900cd634e6e2c3db6.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>内存保护<br>&emsp;○  在进程页表的每个页表项中，为每个页设置一个保护位Valid-iinvalid bit<br>&emsp;○ 页表项的“有效-无效”位（“有效”表示该页面在进程的逻辑地址空间范围内，是合法页面）<br></p>
<p>共享页面<br>&emsp;○ 共享代码<br>    &emsp;&emsp;    ○ 只读（可重入）代码只需一份，供若干进程共享（如文件编辑器，编译器、窗口系统）<br>    &emsp;&emsp;    ○ 对所有进程来说共享代码必须位于逻辑地址空间的相同位置<br>&emsp;○ 进程自有代码和数据<br>&emsp;&emsp;        ○ 进程各自拥有一份<br>&emsp;&emsp;        ○ 为自有代码、数据分配的页面，可以分布在进程逻辑地址空间的任意位置<br><br></p>
<p>下一章：操作系统学习之页表详解</p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之死锁]]></title>
      <url>/zhoujiabo.github.io/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%BB%E9%94%81/</url>
      <content type="html"><![CDATA[<p>有关“死锁”的话题：<br><br>    &emsp;• 死锁问题<br><br>    &emsp;• 关于死锁的系统模型<br><br>    &emsp;• 死锁状态的四大特征<br><br>    &emsp;• 处理死锁问题的思路（四个层次）<br><br>        &emsp;&emsp;○ 死锁预防，Deadlock Prevention<br><br>        &emsp;&emsp;○ 死锁避免，Deadlock Avoidance<br><br>        &emsp;&emsp;○ 死锁检测，Deadlock Detection<br><br>        &emsp;&emsp;○ 死锁恢复，Recovery from Deadlock<br></p>
<p>&emsp;死锁问题，定义：<br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A <span class="built_in">set</span> of blocked processes each holding a resource and waiting to acquire a resource held by another process <span class="keyword">in</span> the <span class="built_in">set</span>.</span><br></pre></td></tr></table></figure>
<p>一组被阻塞进程的集合（构成一个死循环）：<br><br>    &emsp;a. 集合中每个进程既占有一些资源，同时又等待另一些资源；<br><br>    &emsp;b. 进程所等待的资源恰恰被集合中的某个等待进程占用。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/896f8b38435c00078fe51bb31a69c726e8f42d64eee7815a.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>进程Pi使用资源遵循这样的流程：<br><br>&emsp;申请资源——申请没被批准则等待，申请获批准则使用该资源——使用完毕后，释放资源<br><br><br></p>
<p>死锁的<font color="red"><big>四个必要条件</big></font>：<br><br>&emsp;Deadlock can arise if four conditions hold simultaneously.<br><br>    &emsp;a) <strong>Mutual exclusion</strong> 任何时刻，最多只能由一个进程使用资源<br><br>    &emsp;b) <strong>Hold and wait</strong> 任一个进程，它至少占有一个资源，同时又等待更多资源；而这些被等待的资源目前由其它进程占用<br><br>    &emsp;c) <strong>No preemption</strong> 进程完成其任务后，才会自愿释放其占用的资源（不能被抢占）<br><br>    &emsp;d) <strong>Circular wait</strong> 若干进程间形成首尾相接循环等待资源的关系，例如a等待目前被b占用的资源，b又等待目前被c占用的资源，c等待目前被a占用的资源<br><br><br><br>解决死锁Deadlock：<br><br>——预防，不要让死锁发生<br><br>——监测，即时解决<br><br>——鸵鸟政策，操作系统将死锁的问题丢给程序员<br></p>
<p><font color="red"><big>死锁预防</big></font>：（静态策略，代价太大，或难以实现）<br><br>任何情况下，保证4个条件不会同时满足。破坏产生死锁的条件：<br><br>——Mutual Exclusion, 可共享的资源自然不满足此条件；不可共享的资源必然满足此条件。<br><br>——Hold and wait，确保一个进程申请一个资源时，它没有占用其它资源。<br><br>    &emsp;a. 策略一：进程开始执行前，它已经申请并一次性获得所有资源<br><br>    &emsp;b. 策略二：只允许在不占有资源的情况下申请（手上的资源还了才能申请）<br><br>问题：资源利用率低，很可能引起饥饿<br><br>——No Preemption，隐式抢占<br><br>    &emsp;a. 一个进程已经拥有部分资源，假如它试图申请其它资源，但是没能马上满足，它不得不等待；同时要求，“它释放已拥有的所有资源”。（系统偷偷收回，进程本身不知道，但是操作系统会在进程申请其它资源成功后，把暂时收过来的资源还给进程，这时进程所需的资源已经齐备，进入到就绪队列）<br><br>    &emsp;b. 以这种途径释放的资源，用来重新分配给等待队列里的进程<br>局限性：只适用于状态易于保存和恢复的资源（内存、CPU）<br><br>——Circular Wait <br><br>    &emsp;a. 为所有类型的资源定义一个顺序号<br><br>    &emsp;b. 策略：一个进程先后申请的资源，其资源类型的顺序号必须单调递增<br><br>    &emsp;c. 哪些资源的编号在前，哪些资源编号靠后，可以根据资源使用的频繁性，将常用的资源放在前面，不常使用的资源放在后面<br><br></p>
<p><font color="red"><big>死锁避免</big></font>：（动态策略，银行家算法）<br><br>&emsp;前提：系统拥有先验知识，知道每个进程将如何利用资源，例如，每个进程事先申报：每种类型资源的最大需求数<br><br>&emsp;死锁避免算法动态检测资源分配状态（resource-allocation state），它问题确保circular-wait条件永远不成立。<br></p>
<p>资源分配状态决定于3个因素：<br><br>    &emsp;○ 系统可分配的资源数<br><br>    &emsp;○ 进程拥有的资源数<br><br>    &emsp;○ 进程对每种类型资源的最大需要数<br></p>
<p><strong>安全状态（Safe State）定义</strong>：<br><br>&emsp;当一进程申请可用资源时，系统必须判断：此次分配之后，系统是否仍然处于“安全状态”。<br><br>&emsp;如果存在一个序列&lt;p1,p2……pn&gt;<br><br>&emsp;进程pi将申请的资源&emsp; &lt;（当前可用资源+所有进程pj占有的资源）其中j&lt;i。<br><br>&emsp;那么称系统处于“安全状态”。<br><br><br><br>例子：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/de575f10af5269809cb332a966dc24b4ac5d4269e1899b42.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;安全序列不唯一，只要系统分配资源后能使进程进入就绪队列（意味着一段时间后，系统就能回收进程释放的资源），就说明系统分配是安全的。<br><br><br><font color="red">Dijkstra的银行家算法</font>：<br><br>&emsp;a. 算法能够管理多类型，多实例的资源；<br><br>&emsp;b. 每个进程必须事先预报它将用到的最大资源数<br><br>&emsp;c. 一个进程申请资源后，它可能被要求等待<br><br>&emsp;d. 一个进程得到所有资源后，必须在有限时间内归还<br></p>
<p>银行家算法的数据结构：<br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;n表示进程总数，m表示资源类型总数</span><br><span class="line">①Available-长度为m的矢量</span><br><span class="line">available[j] = k；表示Rj类型的资源共有k个实例可用</span><br><span class="line">②Max-n*m矩阵</span><br><span class="line">Max[i][j] = k；表示进程Pi可申请最多k个Rj类型的资源</span><br><span class="line">③Allocation-n*m矩阵</span><br><span class="line">Allocation[i][j] = k；表示进程Pi拥有Rj类型的资源有k个</span><br><span class="line">④Need-n*m矩阵</span><br><span class="line">Need[i][j] = k；表示进程Pi还需要申请Rj类型的资源k个，才能完成任务</span><br><span class="line">（Need = Max - Allocation）</span><br></pre></td></tr></table></figure>
<p><strong>算法过程</strong>：<br><br>&emsp;1、定义Request矢量，Requesti[j] = k；表示进程Pi向银行发出申请，申请Rj类型的资源k个<br><br>&emsp;2、if Request&lt;=Need，进程申请的资源没有超过它需要的资源，说明贷款人是否守信用，继续<br><br>&emsp;3、if Request&lt;=Available银行家手上的钱能满足贷款人的申请，继续<br><br>&emsp;4、假如满足了该进程的申请，系统试分配资源给进程p,并更新三个资源矩阵Available,Allocation和Need<br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available[j] -= Request[j]</span><br><span class="line">Allocation[i][j] += Request[j]</span><br><span class="line">Need[i][j] -= Request[j]</span><br></pre></td></tr></table></figure>
<p>&emsp;5、系统执行安全性算法检测，若分配资源后系统处于“安全状态”，才正式分配；否则恢复原来的分配状态，让该进程等待（检查贷款后是否安全）<br><br></p>
<p><strong>安全性检测算法</strong>：<br><br>&emsp;1、令Work为长度m的矢量，Finish为长度n的矢量。初始值：<br><br>&emsp;&emsp;a. Work = Available <br><br>&emsp;&emsp;b. For i =  1,2,…,n， if Allocation != 0 then Finish[i] = false; else Finish[i] = true<br><br>&emsp;2、从进程集合中找到一个满足下列条件的进程：<br><br>&emsp;&emsp;Finish[i] = false;<br><br>&emsp;&emsp;Need[i][j] &lt;= Work[j]<br><br>&emsp;3、当进程获得资源后，可顺利执行，并修改Work和Finish向量<br><br>&emsp;&emsp;Work[i] += Allocation[i][j]<br><br>&emsp;&emsp;Finish[i] = true<br><br>&emsp;4、如果所有进程中的Finish[i] = true说明系统处于安全状态。<br></p>
<p>&emsp;<strong>死锁避免总结</strong>：安全检测运行频繁，开销大，且只处于安全状态，资源利用率较低（如下图）。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/078458d2a566825b9dd1d06834e396b15e3fa73568066622.png" alt="" title="" class="">
                <p></p>
            </figure><br>
<p><font color="red"><big>死锁检测和恢复：</big></font><br><br><br>&emsp;○ 容忍系统陷入死锁状态<br><br>&emsp;○ 设计死锁检测算法，供需要时调用<br><br>&emsp;○ 配置系统恢复的对策<br><br><br>&emsp;死锁检测，定时或或满足某些条件（如CPU利用率下降到40%）时运行一下。<br><br>&emsp;死锁恢复：无脑直接反所有死锁进程全部杀死，或每次只杀出一个死锁进程，直至系统脱离死锁状态。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/83163e57fcd618b36342af41a7bbdb40ff86ec6256b5a663.png" alt="" title="" class="">
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/61a549d54a92820ef0b20a1f50ba3d0e98f4722a380393c3.png" alt="" title="" class="">
                <p></p>
            </figure>]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之经典同步问题]]></title>
      <url>/zhoujiabo.github.io/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>经典同步问题<br><br>    &emsp;• 生产者-消费者问题<br><br>    &emsp;• 读者-写者问题<br><br>    &emsp;• 哲学家就餐问题<br><br><br>1）生产者-消息者问题<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/c406c928080ea41262efd30c7eeed169f668850ff790b0cd.png" alt="" title="" class="">
                <p></p>
            </figure><br>
<p>2）读者-写者问题<br><br>问题描述：<br><br>    &emsp;当一位写者在执行写操作时，不允许其它写者和读者操作共享变量——共享锁<br><br>    &emsp;当一位读者在读时，允许多个读者同时进行操作——互斥锁<br></p>
<p>第一种解法，读者优先<br><br>    &emsp;当有读者在临界区进行读操作时，后来的写者要门口等待，但后来的读者不用排队，可以直接进去。只要还有读者在临界区，则后面陆续赶到的读者就可以“插写者的队”。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/bdaa31eed3d9b162a411b71e14af396bb3131acbedb05eb0.png" alt="" title="" class="">
                <p></p>
            </figure>
<pre><code>&amp;emsp;显而易见，上面的算法可能会让写者一直等待，导致写者“饥饿”。&lt;br&gt;&lt;br&gt;</code></pre><p>第二种解法：写者优先（可能导致读者“饥饿”）<br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* 写者优先 */</span><br><span class="line">int rQ_len = 0;//读者队列长度</span><br><span class="line">int wQ_len = 0;//写者队列长度</span><br><span class="line">semaphore passport = 1;	//令牌</span><br><span class="line">semaphore read_count_mutex = 1;//对计数器资源的互斥访问</span><br><span class="line">semaphore write_count_mutex = 1;</span><br><span class="line">semaphore file_resource = 1; //对文件资源的互斥访问</span><br><span class="line"></span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wait</span>(passport);//如果有写者在临界区，passport-1后小于0，使读进程被阻塞。</span><br><span class="line">		<span class="built_in">wait</span>(read_count_mutex);</span><br><span class="line">		<span class="keyword">if</span>（!rQ_len）//除了第一个读者进来需要申请文件资源外，之后的读者可以直接访问临界区</span><br><span class="line">			<span class="built_in">wait</span>(file_resource);</span><br><span class="line">		rQ_len++;		</span><br><span class="line">		signal(read_count_mutex);</span><br><span class="line">		signal(passport);</span><br><span class="line">		</span><br><span class="line">		/* critical section */</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">wait</span>(read_count_mutex);		</span><br><span class="line">		rQ_len--;		//一个读者完成读操作</span><br><span class="line">		<span class="keyword">if</span>(!rQ_len)		//如果读者队列为空，释放文件资源</span><br><span class="line">			signal(file_resource);</span><br><span class="line">		signal(read_count_mutex);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wait</span>(write_count_mutex);</span><br><span class="line">		<span class="keyword">if</span>(!wQ_len)	//第一个写者进来，passport-1=0，进程继续执行，而之后的写者不会再进入<span class="keyword">if</span>(对passport信号量进行操作)</span><br><span class="line">			<span class="built_in">wait</span>(passport)</span><br><span class="line">		wQ_len++;</span><br><span class="line">		signal(write_count_mutex);</span><br><span class="line">		<span class="built_in">wait</span>(file_resource);</span><br><span class="line">		</span><br><span class="line">		/* critical section */</span><br><span class="line">		</span><br><span class="line">		signal(file_resource);//写者与写者互斥，所以每一个写者访问临界区后，都要释放资源</span><br><span class="line">		<span class="built_in">wait</span>(write_count_mutex);</span><br><span class="line">		wQ_len--;</span><br><span class="line">		<span class="keyword">if</span>(!wQ_len)//写者队列为空，释放令牌</span><br><span class="line">			signal(passport);</span><br><span class="line">		signal(write_count_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情形模拟：<br><br>&emsp;如果正在访问临界区的是写者，因为令牌一直被写者们持有，所以读者不能进入临界区。<br><br>&emsp;如果正在访问临界区的是读者，这时有写者来到门口排队，因为写者能立即获取令牌，所以后来的读者无法进入临界区，在临界区内的读者执行完成后(文件资源被释放)，写者能立即进入临界区。<br><br>要点分析：<br><br>&emsp;读者共享文件资源，只需申请一次；写者优先获取令牌，且当写者队列为空后才释放令牌<br></p>
<p>3）哲学家就餐问题：<br><br>&emsp;有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考（不交谈）。假设桌子上只有五只筷子，如何使他们都能吃到饭。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/db796408782b4d398de2baa13972b8f2d8425fcf55b79972.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量chopstick均为0，<br>当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限等待。<br></p>
<p>可能的解决方案（possible solutions）：<br><br>    &emsp;a spare resource（留一个空闲资源），allow at most four philosophers to be sitting simultaneously at the table.（最多四个人先就餐）<br><br><br>     &emsp;一次性获得资源，allow a philosopher to pick up chopsticks only a both are available, and pick up them simultaneously.（要么有一双筷子，要么没有）<br></p>
<p>&emsp;不对称解，use an asymmetric solution, an odd philosopher picks up first the left chopstick and then the right chopstick, whereas an even one picks up first the right and then the left. （奇数号哲学家先拿左边筷子，然后拿右手边筷子；偶数号哲学家行为相反）</p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之临界区问题]]></title>
      <url>/zhoujiabo.github.io/2020/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>进程同步中的临界区问题<br><br>&emsp;对共享数据（shared data）的并发访问（concurrent access），可能导致数据不一致问题；要确保数据一致性（data consistency）是个合理的要求。它需要一个机制，以保证合作进程们有序地执行。<br></p>
<p>&emsp;以生产者-消费者问题为例。count变量是记录缓冲区中被占用的单元总数，初始值为0。当生产者进程注入一个单元数据时，count增1；当消费者进程消费掉一个单元数据时，count减1。<br><br><br>“count++”语句被编译翻译成如下机器语言：<br><br>&emsp;register = count；register = register+1；count = register。<br><br><br>&emsp;假如并发执行的生产者进程和消费者进程恰巧经历一个时机点：它们都意欲修改共享变量count！上述汇编语句可能交叉执行。是否交叉执行，取决于CPU调度器的调度结果。<br><br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/16/06f3ecb2bc0f57523e735539c5ad116f47830d1d9cd15c4c.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;上面的场景，生产者进程和消费者进程的共享变量count=6（正确的结果应该是5）。<br><br></p>
<p>Race condition（竞争）: The situation where several processes access and manipulate（访问和操纵） shared data concurrently（并发地）. The final value of the shared data depends upon which process finishes last.<br><br>&emsp;为了避免race conditions，并发进程必须同步（synchronized），以确保一段时间内只有一个进程能访问共享数据。<br></p>
<p><font color="red">原子操作</font>（Atomic operation）能完整地一次性完成的，不允许中间被打断的操作。<br><br>进程中能访问共享数据的代码段叫<font color="red">临界区</font>（critical section）。<br></p>
<p>临界区问题的解决方案必须满足三个条件：<br><br>&emsp;• 互斥（mutual exclusion）——如果一个进程在“临界区”正在执行，那么其它进程不能进入“临界区”<br><br>&emsp;• 空闲让进（progress）——如果没有进程处于它的临界区，和某些进程申请进入其临界区。那么只有那些不在remainder sections的进程，才能参与能否进入临界区的选举，而且这个选举无限期推迟。<br><br>&emsp;• 有限等待（Bounded Waiting）——某一进程从其提出请求，至它获准进入临界区的这段时间里，其它进程进入他们的临界区的次数存在上界。<br></p>
<p><font color="red">Peterson算法</font>(双进程)：<br><br>&emsp;一个实现互斥锁的并发程序设计算法，可以控制两个线程访问一个共享的单用户资源而不发生访问冲突<br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Peterson算法 */</span><br><span class="line">void procedure0()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag[0] = <span class="literal">true</span>;//P0申请进入临界区</span><br><span class="line">        </span><br><span class="line">        //如果flag[1]为<span class="literal">false</span>（P1没有申请进入临界区），则P0可以直接进入临界区；</span><br><span class="line">        //如果flag[1]=<span class="literal">true</span>，而且turn==1（有权访问共享资源的进程为P1），则P0循环等待。</span><br><span class="line">        <span class="keyword">while</span>(flag[1]&amp;&amp;turn==1);</span><br><span class="line">		</span><br><span class="line">		visit();//访问临界区</span><br><span class="line">		</span><br><span class="line">		flag[0] = <span class="literal">false</span>;//访问临界区完成，P0释放出临界区</span><br><span class="line">		turn = 1;</span><br><span class="line">		/*	remainder section*/	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法理解要点：flag[n]的值为真，表示ID号为n的进程希望进入该临界区.，变量turn保存有权访问共享资源的进程的ID号。<br><br><font color="red">lamport算法</font><br>（N进程）：又称面包房算法，先来先服务算法。跟很多银行采用的排队机制一样。客户到了银行，先领取一个服务号。一旦某个窗口出现空闲，拥有最小服务号的客户就可以去空闲窗口办理业务（进入临界区）。<br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Lamport面包房算法 */</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	choosing[i] = ture; </span><br><span class="line">	number[i] = max(number[0],number[1],......number[n-1])+1;</span><br><span class="line">	choosing[i] = <span class="literal">false</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(j=0;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(choosing[j]); </span><br><span class="line">		<span class="keyword">while</span>((number[j]!=0)&amp;&amp;((number[j],j)&lt;(number[i],i)));</span><br><span class="line">		</span><br><span class="line">		/* critical section */</span><br><span class="line">		</span><br><span class="line">		number[i] = 0;</span><br><span class="line">		/* remainder section */</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法理解要点：<br><br>&emsp;boolean choosing[n] 表示进程是否在取号<br><br>&emsp;int number[n] 记录每个进程取到的号码<br><br>&emsp;（a，b）&lt;（c，d）等价于（a&lt;c）|（a==c&amp;&amp;b&lt;d）<br><br>&emsp;一般来说，后到的进程取到的号码比其它先到进程取到的号码要大，但是存在两个进程同时进来，结果找到的最大号码一样，导致领到的号码也一样。<br><br></p>
<p>硬件指令解决方案：<br><br>&emsp;<font color="red">关中断</font>——进程切换需要依赖中断来实现，如果直接将中断屏蔽，则不会引起进程切换。但关中断时间过长会影响系统效率，限制处理器交叉执行程序的能力，而且关中断方法不适用于多CPU系统。<br><br>&emsp;<font color="red">Test-and-Set指令</font>——原子指令，不会被中断，其功能是读出指定标志后，把该标志设置为真。为每个临界区资源设置一个共享变量lock，true表示被占用。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/e883329ff8264994ce67ff3de7cd2cbddfebbf526c18aba4.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>&emsp;<font color="red">swap指令</font>——原子指令，不会被中断，功能是交换两个变量的值。<br>为每个临界资源设置一个共享变量lock，再设置一个局部变量key，用来和lock交换信息。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/8b91d5e8ebb7dea1c19dfe77f6129010ca00ffeb37c9ad8b.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>硬件指令缺点：bounded waiting不一定能满足<br><br></p>
<p><font color="red">信号量</font><br>（Semaphore）:<br><br>信号量是个整形变量，信号量只允许两个标准操作：wait()和signal()（原名P操作，V操作，也叫PV原语）。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/17/fc4cb0c7c63698180193ab02adf88bf5e7620191f9755bfd.png" alt="" title="" class="">
                <p></p>
            </figure><br>
<p>wait()和signal()的核心就是一段不可分割不可中断的程序段（执行过程中关闭中断）。<br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* PV原语 */</span><br><span class="line"><span class="built_in">wait</span>(S)</span><br><span class="line">&#123;</span><br><span class="line">	value--;</span><br><span class="line">	<span class="keyword">if</span>(value&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		add this process to waiting queue;</span><br><span class="line">		block();//阻塞自己，主动交出CPU，引起新一轮CPU调度</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(S)</span><br><span class="line">&#123;</span><br><span class="line">	value++;</span><br><span class="line">	<span class="keyword">if</span>(value&lt;=0)</span><br><span class="line">	&#123;</span><br><span class="line">		remove a process P from the waiting queue;</span><br><span class="line">		wakeup(P);//唤醒等待队列里的一个进程，将它移入就绪队</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之线程]]></title>
      <url>/zhoujiabo.github.io/2020/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>线程（threads）：<br><br>&emsp;• 线程可以理解为“轻量级进程”或者“进程中的进程”；过去传统的进程是程序执行流的最小单位，而引入线程后，线程就成为了程序执行流的最小单位，是一个基本的cpu执行单元。<br><br>&emsp;• 线程不仅提高了系统的并发度，而且大大提高了系统的资源利用率；使进程能同时做更多的事，而且有效地节省了进程切换的开销，线程几乎不拥有系统资源，它共享系统分配给进程的资源。<br></p>
<p>线程相对进程的优势：<br><br>    &emsp;• Responsiveness(e.g. Web应用前端)<br><br>    &emsp;• Resource Sharing(e.g. shared variable)<br><br>    &emsp;• Economeyy(e.g. save memory)<br><br>    &emsp;• Utilization of MP Architecture<br><br><br>用户级线程和内核级线程：<br><br>    &emsp;• 用户级线程（User Threads）——线程管理（创建、资源蛀、调度、通信等）由user-level threads library“一手包办”，不依靠OS内核。<br><br>    &emsp;• 内核级（Kernel Threads）——线程管理由操作系统内核的kernel-level threads实现<br><br><br>多线程（MultiThreads）模型<br><br>    Many-to-One:<br><br>    &emsp;a. 将多个user-level threads映射到同一个kernel thread构成一组对应关系，操作系统运行环境里，可以存在很多组这样的对应关系。凡是不支持线程的OS内核，都可以用这个模型。<br><br>    &emsp;b. 优点：用户级线程的切换在用户空间即可完成，所以线程管理的系统开销小，效率高；缺点：一个用户线程被阻塞，会影响整个进程（进程的其它线程）<br><br><br>    One-to-One:<br><br>        &emsp;a. 一个用户级线程映射到一个内核级线程<br><br>        &emsp;b. 优点：当一个线程被阻塞时，别的线程还可以继续执行；并发能力高，多线程可以在多核处理机上并行执行；缺点：一个进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到内核态，线程管理成本高<br><br><br>      Many-to-Many: <br><br>        &emsp;a. n个用户级线程映射到m个内核级线程，每个用户进程对应m个内核级线程。<br></p>
<p>线程相对于进程管理，带来的新问题：<br><br>    &emsp;a. fork()操作和exec()操作的语义有变化<br><br>    &emsp;b. 撤销线程（Thread cancellation）<br><br>    &emsp;c. Signal handling<br><br>    &emsp;d. Thread pools<br><br>    &emsp;e. Thread specific data<br><br>    &emsp;f. Scheduler activations<br></p>
<p>总结进程和线程的区别：<br><br>    &emsp;a. 一个线程只能属于一个进程，而一个进程可以有多个进程，但至少有一个线程<br><br>    &emsp;b. 线程的划分尺度小于进程，使得多线程程序的并发性高<br><br>    &emsp;c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大提高了程序的运行效率（但线程能够提高的总性能是有上限的）<br><br>    &emsp;d. 资源分配给进程，同一进程的所有线程共享该进程的所有资源<br>CPU分配给进程，而真正在CPU上运行的是线程<br></p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之CPU调度]]></title>
      <url>/zhoujiabo.github.io/2020/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8BCPU%E8%B0%83%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>CPU调度的使命：<br><br>&emsp;从内存准备就绪的进程中（就绪队列中的进程），选取一个进程；将CPU分配给该进程。<br><br><br>CPU调度发生的情形：<br><br>&emsp;一种是“非抢占式的”，进程完成或发生某种事件（如I/O请求），才主动放弃cpu使用权；如进程主动发起I/O请求，但IO设备还没准备好，这时发生IO阻塞，进程进入wait状态；或者说内核分配给进程的时间片已经耗尽了，进程进入Ready状态；还有就是进程创建了子进程，并调用wait()等待子进程执行完毕，进程就重新进入Ready状态等待阻塞结束；（让进程运行直到结束或阻塞）<br><br>&emsp;另一种是“抢占式的(preemptive)“，Ready状态队列中出现了优先级更高的进程，或者发生中断。<br><br><br>追求的指标：<br><br>&emsp;a. CPU利用率<br><br>&emsp;b. 吞吐率（Throughput）-单位时间内完成执行的进程数<br><br>&emsp;c. 周转时间（Turnaround time）-从进入就绪队列到执行完毕所耗用的cpu累积时间<br><br>&emsp;d. 等待时间 - 某一进程等待在就绪队列里面的累积时间<br><br>&emsp;e. 响应时间 - 某一进程从发出调度请求，到某得到CPU调度器响应，某间从经历的时间<br><br><br><br>调度算法：<br><br><br><strong>FCFS</strong>(first-come,first-serve) 适合CPU繁忙型作业，而不适合IO繁忙型作业<br><br>（CPU繁忙型作业：需要进行大量满负荷甚至超负荷整数和浮点数运算，主要在内存中进行，俗话说就是吃CPU，比如各种科学计算，大型的数据建模等等；I/O繁忙型作业：需要频繁进行硬盘或其他存储介质读写，比如各种数据中心，网络存储和云存服务器）<br><br><br><strong>SJF</strong>（shortest job first）（有非抢占式和抢占式之分）效率高，不过对长作业不利，完全未考虑作业(进程)的紧迫程度；而且有个致命的问题，无法准确预估进程的执行时间，”指数平均”算法预估burst cycle，但事实证明这个模型不够准确，所以很难实现SJF算法。<br></p>
<p><strong>优先权法</strong>（Priority scheduling）（有非抢占式和抢占式之分）<br><br>&emsp;根据进程的优先级确定哪个进程使用CPU。<br><br>&emsp;问题：使用抢占式优先权法，优先权较低的就绪进程可能永远得不到CPU。<br><br>&emsp;解决：Aging思想，就绪进程等在就绪队列中的时间，折算叠加到进程优先权，因此，等待在就绪队列里的进程，其优先权会逐渐提高。<br><br><br><strong>轮转法</strong>（Round-Robin，RR）：<br><br>&emsp;所有就绪进程排成一个队列，队首总是先被调度选中，在CPU上运行一个时间片后，系统发生定时器中断，该进程停止运行，并重新入队（到就绪队列的末尾），随后系统把CPU分给新的就绪队列队首进程。<br><br>评价：<br><br>&emsp;平均周转时间通常优于SJF，响应时间一定优于SJF。<br><br>&emsp;缺点：上下文切换的开销。所以选择一个合适的时间片十分重要。<br></p>
<p><strong>多队列调度</strong>：<br><br>&emsp;根据进程属性，如进程类型、内存大小、进程优先级等，把就绪队列拆分成几个队列；例如：要求交互的进程在前台队列;<br>可以批处理的进程，在后台队列。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/16/9b047bcabf84e506e7265c07da551952fb079dfe810c6984.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>每个队列有其自己的调度算法，例如<br><br>&emsp;前台就绪队列——RR<br><br>&emsp;后就绪队列——FCFS<br><br><br>设计多层队列：<br><br>就绪进程进入就绪队列时，决定去哪儿？<br><br>怎么在多个队列中分配CPU？<br><br>&emsp;a. 固定优先权法，例如，先前台队列，再后台队列<br><br>&emsp;b. 时间片方法，例如80%的CPU时间给前台队列，剩下的20%给后台队列。<br><br><br><br>多层反馈队列：<br><br>&emsp;要另外设计一个算法，管理进程在就绪队列层次间的迁移；例如如果Q0中的进程未在时间片8ms内完成，则进入Q1队列，如果在Q1队列中还没完成，则进程被放到Q2就绪队列等待。<br></p>
<p>实时调度<br><br>&emsp;硬实时——调度机制能够确保一个关键任务在给定的时间点前完成<br><br>&emsp;软实时——调度机制尽量给予关键任务最高优先级，尽量在预定时间点前完成<br><br><br><br>调度算法评估方法：<br><br>&emsp;• 确定模型法（Deterministic modeling）- 采用事先设定的负荷，计算在给定负荷下每个算法的性能（误差率较大）<br><br>&emsp;• 排队模型（Queueing models）<br><br>&emsp;• 编程实现该算法，观察其执行情况<br><br>&emsp;• 仿真——给真实数据，在虚拟系统上运行。<br></p>
]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之进程管理]]></title>
      <url>/zhoujiabo.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p><font color="red"><big>起源——</big></font></p>
<p>程序就是一个指令序列<br><br>&emsp;在程序执行的过程中，需要将其放入内存中之后都会被cpu处理。早期的计算机中只支持单道程序，所以计算机中的所有资源都被这一个程序所享有。内存也只是供当前运行的程序所使用。内存被划分为程序段和数据段，程序段存放程序代码，数据段存放程序中的数据。因为当时只有一个程序，所以很容易就能在内存中找到相应的程序段和数据段。<br><br>随着计算机的发展，开始运行多道程序，内存中就需要存放各个运行的程序的相关信息，这样就产生了一个问题，操作系统如何才能找到各程序的存放位置。<br></p>
<p>&emsp;为了方便操作系统管理和完成各个程序运行，引入了进程和进程实体的概念。操作系统为每个运行的程序配置了一个数据结构，进程控制块（PCB），用来描述进程的各种信息，如程序代码和数据存放的位置（不是直接存放程序段和数据段存），由于PCB的存在，系统能很容易地获取程序在内存中的位置。<br></p>
<p><font color="red"><big>定义——</big></font><br><br>&emsp;PCB、程序段、数据段三部分构成进程实体，也称进程映像。进程实体是静态的，进程是动态的，是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<p>三个要素：进程在执行什么程序，在处理什么数据，状态（什么阶段）。<br><br>定义：Process is a program in execution; process execution must progress in sequential fashion.<br><br>它是动态的，有生命周期的，如果它不在执行，它就没了。<br><br>进程状态：<br><br>&emsp;new, running, waiting（等待某个事件发生后才能进入就绪态）,  ready（进程拥有除CPU外所有需要的资源）,  terminated<br><br>进程控制块(PCB)关联信息：<br><br>&emsp;a. process state（进程状态）<br><br>&emsp;b. program counter（程序计数器如PC）<br><br>&emsp;c. cpu registers（用于进程上下文切换）<br><br>&emsp;d. cpu scheduling information（CPU调度信息）<br><br>&emsp;e. memory-management information（内存管理信息）<br><br>&emsp;f. accounting information（记账信息，如使用了什么资源，使用了多长时间）<br><br>&emsp;g. io status information（I/O状态信息）<br><br>&emsp;PCB的数据结构十分复杂，每个进程对应一个PCB，所其数据结构要尽可能优化。<br><br><br><font color="red"><big>进程切换——</big></font><br><br><br>就绪队列，各种io等待队列（根据所等待的资源分类）</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/15/30e72f482948b6be38df47a775f62a8d143ed22b5f3bd394.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>进程调度队列，动态反映操作系统全貌。<br><br>Job queue —— 等待进入计算机系统的待处理任务<br><br>Ready queue —— 驻留内存，准备就绪，等待CPU<br><br>Device queue —— 等待IO设备的进程<br><br>进程一经创建，即在这些队列之间迁移，直到被终止。<br></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/15/71612f85e118d0cd6210193b64ad005bb068666ecd66bd56.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>
进程切换：<br>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/15/5ccd0cf30d65f988f44f0886e515a0a71bc2c063db89f6d0.png" alt="" title="" class="">
                <p></p>
            </figure>
进程上下文切换，context switch<br>
&emsp;a. cpu任何时候（某个时刻）只能为一个进程服务<br>
&emsp;b. 当cpu转向另一个进程服务时，由于cpu内部资源有限，它必须保存原有进程的状态，装入待服务进程的状态，也即“进程上下文切换”<br>
&emsp;c. “状态”指寄存器、标志位、堆栈等当前值<br>
&emsp;d. 上下文切换时间是一种额外开销（overhead），因为期间cpu不做对用户进程直接有益的事（保存和恢复现场）<br>
&emsp;e. 上下文切换时间决定于cpu硬件支持力度（对寄存器操作）<br>
<br>
<font color="red"><big>进程控制——</big></font><br><br>
对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。实质就是在进程的各个状态之间完成转换。<br>
进程的控制通常由原语完成（所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断），原语的使用能确保PCB中的进程状态和其实际所在队列表示的进程状态一致。无论哪个原语，要做的都是三件事情：<br>
1）更新PCB中的信息，例如修改进程状态标志，将运行环境保存到PCB，从PCB中恢复运行环境等等<br>
&emsp;a. 所有进程的控制原语都一定会修改进程状态标志；<br>
&emsp;b. 剥夺当前运行的进程的CPU使用权，必然要保存其运行环境；<br>
&emsp;c. 某个进程开始运行前必然要恢复其运行环境。<br>
2）将PCB插入合适队列<br>
3）分配/回收资源<br>
<br>
<font color="red"><big>进程通信——</big></font><br><br>
进程是分配系统资源的单位，各进程拥有的内存地址空间相互独立，一个进程不能直接访问另一个进程的地址空间，那进程之间如何安全地进行信息交换呢？<br>
方法：<br>
    • 共享存储：<br>
&emsp;内存中分配一块共享空间，两个进程都能对他进行访问，以达到通信的效果。但是需要注意的是，两个进程对共享空间的访问必须是互斥的，即一个进程在访问共享空间时，另一个进程不能对共享空间进行访问。<br><br>
    • 管道通信：<br>
&emsp;“管道”是指用于连接读写进程的一个共享文件，又叫pipe文件。其实就是在内存中开辟一个大小固定的缓冲区<br>
&emsp;a. 管道只能采用半双工通信，某一时间段只能实现单向传输，如果要实现全双工通信，则需要设置两个管道<br>
&emsp;b. 各进程对管道的访问必须是互斥的<br>
&emsp;c. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走；当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞<br>
&emsp;d. 如果没写满，就不允许读取；如果没有将管道内数据取空，就不允许写<br>
&emsp;e. 数据一旦被读出，就从管道中被抛弃，就意味着读进程最多只能有一个，否则可能会有读错数据的情况。<br><br>
    • 消息传递：<br>
&emsp;进程间的数据交换以格式化的信息Message为单位。进程通过操作系统提供的“发送/接收消息”两个原语进行数据交换。格式化的消息分为消息头，消息尾。<br>
&emsp;消息传递的两种方式：<br>
&emsp;——直接通信：发送进程通过发送原语将消息直接挂到接受进程的消息缓冲队列中<br>
&emsp;——间接通信：消息要先发送到一个中间实体（信箱）中，因此也称为“信箱通信方式”<br>
<br>
感谢：
&emsp;[ZerinHwang03](https://me.csdn.net/weixin_39721347)]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统学习之操作系统概念]]></title>
      <url>/zhoujiabo.github.io/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><font color="blue"><big>操作系统定义：</big></font></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A program that  acts as an intermediary between a user of a computer and the computer hardware.</span><br></pre></td></tr></table></figure>
<p>操作的目标：使用用户<font color="red">方便</font>地使用计算机 和 使计算机硬件<font color="red">高效率</font>运行。（某个程序在某种意义来说也是一个用户）（方便的角度：以后的操作系统应该把网络，多机集成到一块）<br><br><br><br><br><font color="blue"><big>硬件系统：</big></font></p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/14/937131a987554d8bd511900aad864149318d443e995abab2.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>三种总线：地址总线，数据总线，信号总线<br><br>一个或数个CPU，加上一些设备控制器，通过内部总线连接在一起，它们共享内存；这些CPU和设备并行执行，并且竞争使用内存的访问周期。</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/14/d5bc1c99a58a42cce95ca9194bb7fc7c2bdebf4cec228d16.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>
<br>

<p><font color="blue"><big>现代操作系统的特征：</big></font><br><br>多程序，Multiprogramming<br><br>&emsp;a. 单用户系统有先天缺陷，无法让CPU和io设备同时处于运转状态<br><br>&emsp;b. 多程序思想让多个程序竞争使用cpu，使cpu总是有用户程序执行<br><br>&emsp;c. 作业调试器每次选择一个作业，交cpu执行<br><br>&emsp;d. 当这个作业被迫等待时（例如有io操作），cpu转向另一个作业。<br><br><br><br>多任务Multitasking，分时系统Timesharing<br><br>进一步扩展多程序思想，使cpu更快地在作业之间切换。这样 ，作业总能及时地得到cpu，响应用户的交互操作，称为交互式计算。<br><br>&emsp;a. 响应时间（Response time）必须在1s之内<br><br>&emsp;b. 每个用户至少有王道作业在内存中执行&ensp;→由此产生进程<br><br>&emsp;c. 如果存在两个以上的进程等待cpu执行&ensp;→需要cpu调试<br><br>&emsp;d. 如果内存空间装不下进程&ensp;→需要换入换出操作<br><br>&emsp;e. 虚拟内存管理技术，使小内存也能运行大进程<br></p>
<p>中断驱动的硬件操作<br><br>软件申请，软件操作错误等，将产生<font color="red">异常</font>，或<font color="red">陷入</font>。</p>
<p>设计一个操作系统会面临的几个问题与解决方法：<br><br>&emsp;”无限循环”问题 （定时器控制）<br><br>&emsp;进程干扰其它进程问题<br><br>&emsp;进程干扰os问题（dual-mode机制）<br><br>&emsp;等等</p>
<p>CPU提供dual-mode机制，实现os自我保护<br><br>&emsp;a. 用户态(user mode)和内核态（kernel mode）<br><br>&emsp;b. cpu的mode bit或者类似手段可以在内核与用户态之间切换<br><br>&emsp;以此区分系统在执行用户代码还是内核代码；有些cpu带有特权指令，这些指令只能在内核态执行；系统调用自动地从用户态切换到内核态，系统调用返回指令自动地从内核态切换到用户态。<br><br><br><br><br><font color="blue"><big>操作系统结构分类：</big></font><br><br><br>1）简单结构，MS-DOS为例：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/14/993e52ee5d0220a304c21af43a86039687f0077c8d754c54.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>2）层次化方法，UNIX为例：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/14/1dd4830244964f05ee9f4dc4c86e1505658ba2d284b776bc.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>3）微内核结构：<br><br>将OS的功能模块转移到用户态空间，剩下的就是微内核，处于用户态空间的功能模块通过消息传递机制进行通信<br><br>有利因素：（代码少）<br><br>&emsp;容易升级微内核，和移植OS到不同类型的cpu、体系结构，更可靠安全<br><br>不利因素：（频繁访问）<br><br>&emsp;用户态空间与内核态空间之间的通信导致用户态与内核态切换十分频繁，性能开销大（不能完全采用这种结构，根据微内核结构设计的操作系统不流行，因为缺点太突出了。）<br></p>
<p>4）模块化结构：<br><br>应用object-oriented思想方法，核心组件相对独立分离，模块之间通过预知的界面对话，可动态装入内核，可动态卸载。以Solaris为例：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/14/0b4ea2c45af67b9b310d161006b28f932a9ef26d6e0881b5.md.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>
<font color="blue"><big>操作系统的服务分类：</big></font><br>
<font color="red">一类</font>服务直接帮助用户<br>
&emsp;a. 如用户界面（命令行CLI或图形界面GUI）<br>
&emsp;b. 程序执行（使OS能够装入程序到内存，执行驻留内存的程序，结束程序的执行，以及出错时的异常处理）<br>
&emsp;c. IO操作<br>
&emsp;d. 文件系统相关操作<br>
&emsp;e. 进程间通信<br>
&emsp;通过共享内存实现通信 或 通过消息传递实现通信<br>
&emsp;f. 出错检测-OS必须随时应对系统出错<br>
&emsp;出错可能由硬件引起，如cpu、内存、io设备，对于各种出错，OS必须有合适的处理程序，OS应该提供调试、查错工具。<br>
<font color="red">另一类</font>服务确保系统共享资源的高效操作<br>
&emsp;a. 资源分配<br>
&emsp;b. 记账-跟踪记录哪些用户使用了多少资源，使用了哪些资源<br>
&emsp;c. 保护和安全，确保对资源的访问都是受控的；外来访问都需通过身份认证，不允许非法访问。<br>

<p>操作系统的几大服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程管理 内存管理 存储设备管理 大容量存储器管理 I/O子系统管理</span><br></pre></td></tr></table></figure>
<p>一个操作系统应该具备的几个基本功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件操作 状态信息展示 文件内容修改 编程语言支持 程序装入和执行 用户间通信</span><br></pre></td></tr></table></figure>


<br>
下一章：操作系统学习之进程管理]]></content>
      
        <categories>
            
            <category> 操作系统学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+admin]]></title>
      <url>/zhoujiabo.github.io/2020/02/13/hexo-admin/</url>
      <content type="html"><![CDATA[<p>写博客最传统古老的方式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先在bash命令行下先hexo new <span class="string">"title"</span>创建文章，</span><br><span class="line">再通过文本编辑器进行编辑，然后输入命令启动或上传，</span><br><span class="line">最后到自己的博客里查看效果。</span><br></pre></td></tr></table></figure>

<p>但是现在有一个方便的工具插件，<strong>hexo-admin</strong>！通过这个插件我们能直接在后台写文章，并能预览效果，而不用发布后才能看，有问题再改。</p>
<p>预览功能如图：</p>
<figure class="image-box">
                <img src="https://file.moetu.org/images/2020/02/13/b25de1c6462e12e87982ea61d369faf31a6f50e8861fccaf.png" alt="" title="" class="">
                <p></p>
            </figure>
<br>

<p>安装配置教程我就不说了，百度，CSDN里有很多，也比较简单。<br>我参考的教程有两个：<br><br>&emsp;<a href="https://www.jianshu.com/p/e542bea49c88" target="_blank" rel="noopener"><font color="blue">为hexo添加hexo-admin组件</a><br><br>&emsp;<a href="https://segmentfault.com/a/1190000018488921" target="_blank" rel="noopener"><font color="blue">Hexo Admin管理</a></p>
]]></content>
      
        <categories>
            
            <category> 折腾类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> admin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+leancloud评论无法保存(mellow)]]></title>
      <url>/zhoujiabo.github.io/2020/02/13/hexo+leancloud%E8%AF%84%E8%AE%BA%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98(mellow)/</url>
      <content type="html"><![CDATA[<p>我的theme是mellow(附主题安装方法： <a href="https://github.com/codefine/hexo-theme-mellow.wiki.git" target="_blank" rel="noopener">https://github.com/codefine/hexo-theme-mellow.wiki.git</a>)</p>
<p>但我配置valine评论时，出现了如下问题：</p>
<p>评论留言：</p>
<figure class="image-box">
                <img src="https://i.loli.net/2020/02/13/HKX2kaMjyZmIVsv.jpg" alt="" title="" class="">
                <p></p>
            </figure>
<p>刷新之后：</p>
<figure class="image-box">
                <img src="https://i.loli.net/2020/02/13/NYkOc1M4BwLrEah.png" alt="" title="" class="">
                <p></p>
            </figure>


<p>可以正常评论，但是再次打开时评论又<font color="red">不见了</font>,leancloud里我创建的应用comment里也没有数据。。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原因：valine评论和文章浏览统计功能均基于LeanCloud，两者有冲突!!!</span><br><span class="line">解决方案：关闭leancloud_visitors，然后在valine里加入参数<span class="string">"visit_counter: true"</span>，将评论和统计合二为一！</span><br></pre></td></tr></table></figure>

<p>具体修改如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#valine评论系统</span></span><br><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  appid: your appid</span><br><span class="line">  appkey: your appkey</span><br><span class="line">  notify: <span class="literal">false</span>  <span class="comment">#是否开启邮箱提醒</span></span><br><span class="line">  verify: <span class="literal">false</span>  <span class="comment">#是否开启验证码</span></span><br><span class="line">  visit_counter: <span class="literal">true</span> </span><br><span class="line">  placeholder: you can comment here <span class="comment">#留言板中的预留信息</span></span><br><span class="line">  avatar: <span class="string">'wavatar'</span>  <span class="comment">#用户头像</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 文章浏览统计</span></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 折腾类 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> leancloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/zhoujiabo.github.io/2020/02/12/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
