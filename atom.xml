<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou&#39;s Blog</title>
  
  
  <link href="/zhoujiabo.github.io/atom.xml" rel="self"/>
  
  <link href="https://cral-freedom.github.io/zhoujiabo.github.io/"/>
  <updated>2020-08-14T03:16:31.000Z</updated>
  <id>https://cral-freedom.github.io/zhoujiabo.github.io/</id>
  
  <author>
    <name>zhoujiabo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【apue】动态进程池</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91%E5%8A%A8%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91%E5%8A%A8%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-08-14T02:41:00.000Z</published>
    <updated>2020-08-14T03:16:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>引言：<br>&emsp;回顾之前文章《socket - STREAM》中的例程，服务端接受客户端请求后，fork子进程来响应请求。但这样无限制地fork进程，当请求非常多时，会导致fork失败，服务端将无法响应客户端请求。</p><p>我们可以借鉴之前线程池的思想，创建一个进程池处理。<br>①静态进程池：直接fork出N个子进程，然后由N个子进程接受客户端的连接，响应他们的请求。（不灵活，且创建的进程个数比较难确定；进程数少了，请求多时可能无法及时响应；进程数多了，可能造成资源浪费。）</p><p>②动态进程池：进程池上限为MAXCLIENT，允许最少存在X个空闲进程（没有与客户端连接），最多存在Y个空闲进程。程序先创建X个子进程，当请求增多时，继续fork进程响应请求；当请求减少时，存在较多空闲进程时，kill空闲进程。</p><p>例程：server.c（服务端）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MAXCLIENT 20</span></span><br><span class="line"><span class="comment">#define MINIDLESERVER 5     </span></span><br><span class="line"><span class="comment">#define MAXIDLESERVER 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SIG_NOTIFY  SIGUSR2</span></span><br><span class="line"><span class="comment">#define BUFSIZE     1024</span></span><br><span class="line"><span class="comment">#define IPSTRSIZE   40</span></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    STAT_IDLE = 1,</span><br><span class="line">    STAT_BUSY</span><br><span class="line">&#125;;</span><br><span class="line">struct server_st</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int sd;</span><br><span class="line">static int busy_count,idle_count;</span><br><span class="line">static struct server_st *server_pool; //struct array address</span><br><span class="line"></span><br><span class="line">static int establish_socket(void);</span><br><span class="line">static int creat_pool(void);</span><br><span class="line">static void manage_pool(void);</span><br><span class="line"></span><br><span class="line">static void usr_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void server_job(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t ppid;</span><br><span class="line">    int client_sd;</span><br><span class="line">    struct sockaddr_in raddr;</span><br><span class="line">    socklen_t raddr_len;</span><br><span class="line">    time_t stamp;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    char ipstr[IPSTRSIZE];</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    raddr_len = sizeof(raddr);</span><br><span class="line">    ppid = getppid();</span><br><span class="line">    <span class="keyword">if</span>(ppid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"getppid()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        server_pool[pos].state = STAT_IDLE;</span><br><span class="line">        <span class="built_in">kill</span>(ppid,SIG_NOTIFY);</span><br><span class="line"></span><br><span class="line">        client_sd = accept(sd,(void *)&amp;raddr,&amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(client_sd &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"accept()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server_pool[pos].state = STAT_BUSY;</span><br><span class="line">        <span class="built_in">kill</span>(ppid,SIG_NOTIFY);//notify parent process the check server pool, mainly to caculate the busy_count</span><br><span class="line"></span><br><span class="line">//        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">//        <span class="built_in">printf</span>(<span class="string">"client:%s:%d\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">        stamp = time(NULL);</span><br><span class="line">        len = snprintf(buf,BUFSIZE,<span class="string">"%ld\n"</span>,(long)stamp);//can<span class="string">'t be long long</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if(send(client_sd,buf,len,0) &lt; 0)//can'</span>t be sd</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"send()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(5);</span><br><span class="line">        close(client_sd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //avoid zombie process(the children will be reclaimed by init process; parent process mustn<span class="string">'t call wait()) and children will not send SIGCHLD to parent process when they terminate</span></span><br><span class="line"><span class="string">    struct sigaction sa;//sa is temp val</span></span><br><span class="line"><span class="string">    sa.sa_handler = SIG_IGN;</span></span><br><span class="line"><span class="string">    sigemptyset(&amp;sa.sa_mask);</span></span><br><span class="line"><span class="string">    sa.sa_flags = SA_NOCLDWAIT;</span></span><br><span class="line"><span class="string">    sigaction(SIGCHLD,&amp;sa,NULL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    //do nothing, just as a driver signal</span></span><br><span class="line"><span class="string">    sa.sa_handler  = usr_handler;</span></span><br><span class="line"><span class="string">    sigemptyset(&amp;sa.sa_mask);</span></span><br><span class="line"><span class="string">    sa.sa_flags = 0;</span></span><br><span class="line"><span class="string">    sigaction(SIG_NOTIFY,&amp;sa,NULL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    establish_socket();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    //puts("establish_socket ok");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if(creat_pool() &lt; 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        fprintf(stderr,"creat_pool() fail!\n");</span></span><br><span class="line"><span class="string">        exit(1);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    //puts("creat_pool ok");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    manage_pool();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    exit(0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static int get_free_pos(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int i;</span></span><br><span class="line"><span class="string">    if(idle_count + busy_count &gt;= MAXCLIENT)</span></span><br><span class="line"><span class="string">        return -1;</span></span><br><span class="line"><span class="string">    for(i = 0; i &lt; MAXCLIENT; i++)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if(server_pool[i].pid == -1)</span></span><br><span class="line"><span class="string">            return i;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return -1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static int add_1_server(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int pos;</span></span><br><span class="line"><span class="string">    pid_t pid;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pos = get_free_pos();</span></span><br><span class="line"><span class="string">    if(pos &lt; 0)</span></span><br><span class="line"><span class="string">        return -1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    server_pool[pos].state = STAT_IDLE;</span></span><br><span class="line"><span class="string">    pid = fork();</span></span><br><span class="line"><span class="string">    if(pid &lt; 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        perror("fork");</span></span><br><span class="line"><span class="string">        exit(1);</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">    if(pid == 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        server_job(pos);</span></span><br><span class="line"><span class="string">        exit(0);</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        server_pool[pos].pid = pid;</span></span><br><span class="line"><span class="string">        idle_count ++;</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;   </span></span><br><span class="line"><span class="string">static int del_1_server(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int i;</span></span><br><span class="line"><span class="string">    if(idle_count == 0)</span></span><br><span class="line"><span class="string">        return -1;</span></span><br><span class="line"><span class="string">    for(i = 0; i &lt; MAXCLIENT; i++)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if(server_pool[i].pid != -1 &amp;&amp; server_pool[i].state == STAT_IDLE)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            kill(server_pool[i].pid,SIGTERM);//terminal child process</span></span><br><span class="line"><span class="string">            server_pool[i].pid = -1;</span></span><br><span class="line"><span class="string">            idle_count --;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">static int scan_pool(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int i;</span></span><br><span class="line"><span class="string">    int idle = 0,busy = 0;</span></span><br><span class="line"><span class="string">    for(i = 0; i &lt; MAXCLIENT; i++)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if(server_pool[i].pid == -1)//unused</span></span><br><span class="line"><span class="string">            continue;</span></span><br><span class="line"><span class="string">        if(kill(server_pool[i].pid,0) == ESRCH)//the process don'</span>t exist</span><br><span class="line">        &#123;</span><br><span class="line">            server_pool[i].pid = -1;</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(server_pool[i].state == STAT_IDLE)</span><br><span class="line">            idle ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(server_pool[i].state == STAT_BUSY)</span><br><span class="line">            busy ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fprintf(stderr,<span class="string">"unkown state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    idle_count = idle;</span><br><span class="line">    busy_count = busy;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***************************************</span><br><span class="line">1 get socket        SOCK_STREAM</span><br><span class="line">2 <span class="built_in">set</span> sockopt       SO_REUSEADDR</span><br><span class="line">3 <span class="built_in">bind</span> laddr        <span class="string">"0.0.0.0"</span>:1999</span><br><span class="line">4 <span class="built_in">set</span> listen        max:200</span><br><span class="line">****************************************/</span><br><span class="line">static int establish_socket(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_in laddr;</span><br><span class="line">    int val = 1;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,sizeof(val)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVER_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,200) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int creat_pool(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    server_pool = mmap(NULL,sizeof(struct server_st)*MAXCLIENT,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);</span><br><span class="line">    <span class="keyword">if</span>(server_pool == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        //puts(<span class="string">"mmap() fail"</span>);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(server_pool,-1,sizeof(struct server_st)*MAXCLIENT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//signal dirver program</span><br><span class="line">static void manage_pool(void)</span><br><span class="line">&#123;</span><br><span class="line">    sigset_t <span class="built_in">set</span>,oset;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIG_NOTIFY);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MINIDLESERVER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(add_1_server() &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"init minidle server fail\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        //<span class="built_in">wait</span> <span class="keyword">for</span> a signal; when receive SIG_NOTIFY, use oset replace <span class="built_in">set</span>, <span class="keyword">then</span> block and <span class="built_in">wait</span> the next SIG_NOTIFY</span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line"></span><br><span class="line">        scan_pool();//update the busy_count and idle_count</span><br><span class="line"></span><br><span class="line">        //contrl the pool, keep the idleserver count [5,10]</span><br><span class="line">        <span class="keyword">if</span>(idle_count &gt; MAXIDLESERVER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = 0; i &lt; (idle_count - MAXIDLESERVER); i++)</span><br><span class="line">                del_1_server();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(idle_count &lt; MINIDLESERVER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = 0; i &lt; (MINIDLESERVER - idle_count); i++)</span><br><span class="line">                add_1_server();</span><br><span class="line">        &#125;</span><br><span class="line">        //<span class="built_in">printf</span> pool state</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; MAXCLIENT; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(server_pool[i].pid == -1)</span><br><span class="line">                putchar(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(server_pool[i].state == STAT_IDLE)</span><br><span class="line">                putchar(<span class="string">'u'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(server_pool[i].state == STAT_BUSY)</span><br><span class="line">                putchar(<span class="string">'x'</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fprintf(stderr,<span class="string">"unkown state.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        putchar(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oset,NULL);//recover sigset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：实际工程中，服务端要做成守护进程，然后其中的报错要改成提交系统日志（syslog）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：&lt;br&gt;&amp;emsp;回顾之前文章《socket - STREAM》中的例程，服务端接受客户端请求后，fork子进程来响应请求。但这样无限制地fork进程，当请求非常多时，会导致fork失败，服务端将无法响应客户端请求。&lt;/p&gt;
&lt;p&gt;我们可以借鉴之前线程池的思想，创建
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="动态进程池" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E5%8A%A8%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【apue】如何避免僵尸进程</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-08-14T02:31:00.000Z</published>
    <updated>2020-08-14T02:40:42.428Z</updated>
    
    <content type="html"><![CDATA[<p>引言：<br>&emsp;<strong>对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。<br>    如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。<br>    如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。</strong></p><p><em>一个子进程在终止或停止时，会向其父进程发送SIGCHLD信号</em>。</p><p>对于SIGCHLD信号，如果我们定义为：</p><blockquote><p>1.SIG_DFL：默认的处理方式是不理会这个信号，但是也不会丢弃子进行状态，所以如果不用wait，waitpid对其子进行进行状态信息回收，会产生僵尸进程。<br>2.SIG_IGN：忽略，此时我们的子进程终止的时候，由init进程进程回收，所以不会产生僵尸进程。（不需要要在父进程中调用wait()）</p></blockquote><p>如果调用sigaction（）函数，且sa_flag中设置了SA_NOCLDWAIT标志，则子进程终止时候，不产生僵尸进程，<strong>同时不向父进程发送SIGCHLD信号</strong></p><p>(例程见下一篇：动态进程池)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：&lt;br&gt;&amp;emsp;&lt;strong&gt;对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。&lt;br&gt;    如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。&lt;br&gt;    如果父进程等待子进程结束，将增加父进程的负担，影响服
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="SIGCHLD信号" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/SIGCHLD%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>【apue】socket - STREAM</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91socket-STREAM/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91socket-STREAM/</id>
    <published>2020-08-14T01:46:00.000Z</published>
    <updated>2020-08-14T02:30:48.324Z</updated>
    
    <content type="html"><![CDATA[<p><strong>流式套接字</strong>(面向连接的套接字)</p><blockquote><pre><code>能保证收到的消息是正确的(可靠) 通信之前必须先建立一个连接 socket(); bind(); listen(); accept(); connect()； send(); close();</code></pre></blockquote><p><strong>SOCK_STREAM</strong>: 提供有序的、可靠的、双工的、基于连接的字节流。可支持带外数据传输机制。 </p><p>异常退出后，如果端口没有被及时回收，再次bind会报错；<br>解决：setsockopt()，SO_REUSEADDR参数。</p><p>例程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">//proto.h</span><br><span class="line"><span class="comment">#ifndef PROTO_H__</span></span><br><span class="line"><span class="comment">#define PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SERVER_PORT "1999"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//client.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int sd,newsd;</span><br><span class="line">    struct sockaddr_in raddr;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    long long stamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVER_PORT));</span><br><span class="line">    inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sd,(void *)&amp;raddr,sizeof(raddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // connect server success!!!</span><br><span class="line"></span><br><span class="line">    fp = fdopen(sd,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fdopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fscanf(fp,<span class="string">"%lld"</span>,&amp;stamp) &lt; 1) //match error</span><br><span class="line">        fprintf(stderr,<span class="string">"fscanf error\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(stdout,<span class="string">"stamp = %lld\n"</span>,stamp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//server.c 服务端与客户端连接成功后，fork子进程来发送消息</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define IPSTRSIZE 40</span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static void server_job(int sd)</span><br><span class="line">&#123;   </span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    int len;</span><br><span class="line">    </span><br><span class="line">    len = sprintf(buf,<span class="string">"%lld\n"</span>,(long long)time(NULL));</span><br><span class="line">    </span><br><span class="line">    //had established the connect, so just send msg</span><br><span class="line">    <span class="keyword">if</span>(send(sd,buf,len,0) &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sd,newsd;</span><br><span class="line">    char ipstr[IPSTRSIZE];</span><br><span class="line">    struct sockaddr_in laddr,raddr;</span><br><span class="line">    socklen_t raddr_len;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int val = 1;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd,SOL_SOCKET,SO_REUSEADDR,&amp;val,sizeof(val)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVER_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sd,100) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = sizeof(raddr);</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        newsd = accept(sd,(void *)&amp;raddr,&amp;raddr_len);</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == 0)    //child</span><br><span class="line">        &#123;</span><br><span class="line">            close(sd);</span><br><span class="line">            inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client: %s:%d\n"</span>,ipstr,ntohs(raddr.sin_port));</span><br><span class="line">            server_job(newsd);</span><br><span class="line">            close(newsd);</span><br><span class="line">            <span class="built_in">exit</span>(0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(newsd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述程序还有个问题：子进程完成消息发送后exit，但父进程在while循环，不会退出，没有wait回收子进程</strong>。<br>解决方法见下一篇：如何避免僵尸进程。</p><p>补充几个命令：</p><blockquote><p>netstat -anu    //查看打开的UDP端口<br>    netstat -ant    //查看打开的TCP端口<br>    nc ip port        //请求某端口的内容<br>    hostname -I 查看当前ip地址<br>    sudo ufw disable 关闭防火墙<br>    sudo systemctl status apache2<br>    eog xxx        //eog是解码器，用于查看图片</p></blockquote><p><a href="https://www.cnblogs.com/lfri/p/10522392.html" target="_blank" rel="noopener">如何在Ubuntu 16.04上安装Apache Web服务器</a></p><p>例程2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">/*******************************</span><br><span class="line">从web爬取图片（前提：已开启apache服务，且网页输入127.0.0.1/test.jpg 可查看图片</span><br><span class="line">即/var/www/html下有图片，注意文件权限）</span><br><span class="line"></span><br><span class="line">验证：</span><br><span class="line">./webdl 127.0.0.1 &gt; /tmp/out   //将图片保存</span><br><span class="line">eog /tmp/out    //用eog解码，查看图片</span><br><span class="line">*******************************/</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int sd,newsd;</span><br><span class="line">    struct sockaddr_in raddr;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    char rbuf[BUFSIZE];</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(80);</span><br><span class="line">    inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(connect(sd,(void *)&amp;raddr,sizeof(raddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // connect server success!!!</span><br><span class="line"></span><br><span class="line">    fp = fdopen(sd,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fdopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fprintf(fp,<span class="string">"GET /test.jpg\r\n\r\n"</span>);</span><br><span class="line">    fflush(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        len = fread(rbuf,sizeof(char),BUFSIZE,fp);</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        fwrite(rbuf,sizeof(char),len,stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;流式套接字&lt;/strong&gt;(面向连接的套接字)&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;能保证收到的消息是正确的(可靠)
 通信之前必须先建立一个连接
 socket();
 bind();
 listen();
 accept();
 c
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="流式套接字" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E6%B5%81%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
      <category term="SIGCHLD" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/SIGCHLD/"/>
    
  </entry>
  
  <entry>
    <title>【apue】socket - DGRAM</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91socket/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/14/%E3%80%90apue%E3%80%91socket/</id>
    <published>2020-08-13T16:06:00.000Z</published>
    <updated>2020-08-14T01:46:31.493Z</updated>
    
    <content type="html"><![CDATA[<p>3、网络套接字sockekt<br><strong>讨论：跨主机的传输要注意的问题</strong></p><blockquote><p>   1、字节序问题：<br>        大端：低地址处放高字节<br>        小端：低地址处放低字节<br>        解决：<br>        主机字节序：host<br>        网络字节序：network<br>        _ to _ _ : htons,htonl,ntohs,ntohl（最后的字符指长度short, long）<br>        （纯文本传输不用转换）</p></blockquote><blockquote><p>   2、对齐：<br>        struct<br>        {<br>            int i;<br>            float f;<br>            char ch;<br>        };    //占12个字节<br>        解决：不对齐</p></blockquote><blockquote><p>   3、类型长度问题<br>        int<br>        char<br>        解决：int32_t, uint32_t, int8_t, int64_t</p></blockquote><p><strong>报式套接字(DGRAM)</strong></p><blockquote><pre><code>被动端（先运行）     socket();     bind();     recvfrom();//addrlen要初始化，不然第一次发送会失败     close();             主动端：     socket();     bind();（可省略，不绑定端口，直接使用本机随意可用的端口）     sndto();     close();</code></pre></blockquote><p>相关函数：</p><blockquote><p>int socket(int domain, int type, int protocol);<br>inet_pton();//转换ip4或ipv6地址（点分式）为整型数<br>inet_ntop();//将大整数转换成点分式的ip地址<br>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);<br>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);<br>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">man 7 ip(ipv4)</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t    sin_family; /* address family: AF_INET */</span><br><span class="line">        in_port_t      sin_port;   /* port <span class="keyword">in</span> network byte order */</span><br><span class="line">        struct in_addr sin_addr;   /* internet address */</span><br><span class="line">        &#125;;</span><br><span class="line">与struct sockaddr *src_addr不同，用(void *)转化；</span><br><span class="line"></span><br><span class="line">/***************************************************</span><br><span class="line">laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCV_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)//<span class="built_in">bind</span> a name to socket</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">****************************************************/</span><br></pre></td></tr></table></figure><br><p>例程1：（basic）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">//proto.h</span><br><span class="line"><span class="comment">#ifndef PROTO_H__</span></span><br><span class="line"><span class="comment">#define PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define RCV_PORT "1999"</span></span><br><span class="line"><span class="comment">#define NAMESIZE 11</span></span><br><span class="line">struct msg_st</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t name[NAMESIZE];</span><br><span class="line">    int32_t math;</span><br><span class="line">    int32_t chinese;</span><br><span class="line">&#125;__attribute__((packed));//cancel align</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//rcver.c</span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"><span class="comment">#define IPSTRSIZE 40</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sd;</span><br><span class="line">    char ipstr[IPSTRSIZE];</span><br><span class="line">    struct msg_st rbuf;</span><br><span class="line">    struct sockaddr_in laddr,raddr;//<span class="built_in">local</span> / remote  address</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,0);//ipv4,datagrams,default protocol:UDP</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCV_PORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"0.0.0.0"</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sd,(void *)&amp;laddr,sizeof(laddr)) &lt; 0)//<span class="built_in">bind</span> a name to socket</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //!!!! addrlen must be initialized</span><br><span class="line">    addrlen = sizeof(raddr);</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd,&amp;rbuf,sizeof(rbuf),0,(void *)&amp;raddr,&amp;addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ipstr,IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----Message from %s:%d----\n"</span>,ipstr,raddr.sin_port);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name:%s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"math:%d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"chinese:%d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//snder.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int sd;</span><br><span class="line">    struct msg_st sbuf;</span><br><span class="line">    struct sockaddr_in raddr;//remote  address</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usag...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    sd = socket(AF_INET,SOCK_DGRAM,0);//ipv4,datagrams,default protocol:UDP</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//  <span class="built_in">bind</span>();     //ignore</span><br><span class="line">    memset(&amp;sbuf,<span class="string">'\0'</span>,sizeof(sbuf));</span><br><span class="line">    strcpy(sbuf.name,<span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%100);</span><br><span class="line">    sbuf.chinese = htonl(rand()%100);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(RCV_PORT));</span><br><span class="line">    inet_pton(AF_INET,argv[1],&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd,&amp;sbuf,sizeof(sbuf),0,(void *)&amp;raddr,sizeof(raddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多点通讯：广播（全网广播，子网广播），多播/组播</p><blockquote><pre><code>setsockopt();getsockopt();        广播：(man 7 socket)level：SOL_SOCKEToptname：SO_BROADCAST    多播组：（man 7 ip）level：IPPROTO_IP主动端创建多播组，被动端加入多播组。optname：IP_MULTICAST_IF，创建多播组         IP_ADD_MEMBERSHIP，加入多播组</code></pre></blockquote><blockquote><pre><code>UDP: 丢包 -- 原因：阻塞        解决：闭环流控（停等式流控）     漏桶、令牌桶：没有校验，开环流控 停等式流控：闭环流控，确保能够收到包，但并没有降低丢包率 TTL：能够经过的路由的个数（Linux环境下默认为64，Windows下默认为128）</code></pre></blockquote><p>例程2：尝试用setsockopt设置广播/多播组通信。（自行实现）</p><p>例程3：用变长的方式组织结构体数据<br>修改提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">①proto.h</span><br><span class="line"></span><br><span class="line">//512 is UDP recommend size</span><br><span class="line">//two 8 is masthead and (sizeof(msg_st) - 1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define NAMEMAX (512-8-8)   </span></span><br><span class="line"></span><br><span class="line">struct msg_st</span><br><span class="line">&#123;</span><br><span class="line">    int32_t math;</span><br><span class="line">    int32_t chinese;</span><br><span class="line">    uint8_t name[1]; //variable</span><br><span class="line">&#125;__attribute__((packed));//cancel align</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">②snder.c和rcver.c中，定义struct msg_st *bufp;结构体指针，再malloc内存空间。</span><br><span class="line">    size = sizeof(struct msg_st) + NAMEMAX -1;</span><br><span class="line">    rbufp = malloc(size);   //其实就是512-8</span><br></pre></td></tr></table></figure><p>例程4：实现myftp_udp（简易检验client收到数据后回复ack，不加流控算法，用有限状态机思想编程）</p><p>例程5：实现myftp_udp_verify(在例程4的基础上完善，①在RTT时间内未收到Ack，防server丢包；②给数据包加编号，如果收到的两个数据包编号相同，说明Ack包丢了；给Ack包加编号校验，防Ack包延迟到达)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3、网络套接字sockekt&lt;br&gt;&lt;strong&gt;讨论：跨主机的传输要注意的问题&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   1、字节序问题：&lt;br&gt;        大端：低地址处放高字节&lt;br&gt;        小端：低地址处放低字节&lt;br&gt;     
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="socket" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/socket/"/>
    
      <category term="报式套接字" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E6%8A%A5%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>【apue】进程间通信 - 消息队列、信号量数组，共享内存</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/13/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-XSI/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/13/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-XSI/</id>
    <published>2020-08-13T15:24:00.000Z</published>
    <updated>2020-08-13T16:05:09.160Z</updated>
    
    <content type="html"><![CDATA[<p>2、XSI -&gt; SysV<br>    &emsp;IPC    -&gt; Inter-Process Communication<br>    &emsp;主动端：先发包的一方<br>    &emsp;被动端：先收包的一方（被动端先运行，创建通信机制）</p><p>相关函数：<br>    ①key_t ftok(const char <em>pathname, int proj_id);//取得一个key，实现类似哈希<br>    &emsp;pathname：文件名，实际要的是inode（唯一性）<br>    &emsp;proj_id：杂质<br>*</em>key：确保两个没有亲缘关系的进程，拿到同一个通信机制（同一个msgid）**<br>    ②消息队列、信号量数组、共享内存三种通信方法中所使用的函数命令类似，<strong>xxxget();创建    xxxop();发送/接收    xxxctl();初始化/销毁</strong></p><p><strong>Message Queues</strong></p><pre><code>int msgget(key_t key, int msgflg);参数：    key：这个位置的值可以是IPC_PRIVATE，用于有亲缘关系的进程间通信；         如果是普通的key值，则msgflg中要有IPC_CREAT，创建消息队列返回值：成功返回msgid，否则返回-1，设置errnossize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,                  int msgflg);</code></pre><blockquote><p><strong>消息队列特点</strong>：<br>    ①消息队列有一个缓存的机制，即使发送端在没有创建msg实例前，先snd了几次，<br>     接收端随后运行时还是能收到发送端发送的内容<br>    ②不是严格意义上的队列，msgrcv中有个msgtyp，可以选择接收特定的包，不是严格意义上的先进先出<br>    ③如果进程异常退出，创建的消息队列没有被销毁（ipcs查看当前存在的通信机制）<br>     ipcrm -q msqid（命令行删除某个消息队列）</p></blockquote><p>例程1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//proto.h文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef PROTO_H__</span></span><br><span class="line"><span class="comment">#define PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define KEYPATH "/etc/services"</span></span><br><span class="line"><span class="comment">#define KEYPROJ 'a'</span></span><br><span class="line"><span class="comment">#define NAMESIZE 32</span></span><br><span class="line"></span><br><span class="line">struct msg_st</span><br><span class="line">&#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char name[NAMESIZE];</span><br><span class="line">    int math;</span><br><span class="line">    int chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//rcver.c</span><br><span class="line"></span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    key_t key;</span><br><span class="line">    int msgid;</span><br><span class="line">    struct msg_st rbuf;</span><br><span class="line"></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key,IPC_CREAT|0600);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid,&amp;rbuf,sizeof(rbuf)-sizeof(long),0,0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"msgrcv"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name:%s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"math:%d\n"</span>,rbuf.math);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"chinese:%d\n"</span>,rbuf.chinese);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgctl(msgid,IPC_RMID,NULL);//destroy msg queue</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//snder.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "proto.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    key_t key;</span><br><span class="line">    int msgid;</span><br><span class="line">    struct msg_st sbuf;</span><br><span class="line"></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key,0);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sbuf.mtype = 1;</span><br><span class="line">    strcpy(sbuf.name,<span class="string">"zhou"</span>);</span><br><span class="line">    sbuf.math = rand()%100;</span><br><span class="line">    sbuf.chinese = rand()%100;</span><br><span class="line">    //msgsnd中msgsz的大小为buf中除开mtype外的数据的大小</span><br><span class="line">    <span class="keyword">if</span>(msgsnd(msgid,&amp;sbuf,sizeof(sbuf)-sizeof(long),0) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgsnd()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    puts(<span class="string">"snd ok"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例程2：尝试实现myftp(类似cat)，snder发path给rcver，rcver接收后去获取相应的文件内容然后发送snder。<br><br><br><strong>Semaphore Arrays（信号量数组）</strong></p><blockquote><p>有A,B两种资源的情况时，如果不用信号量数组进行控制，<br>    让一个进程单独拿到A资源或B资源，容易乱进程僵/饿死<br>    （1号抢A，等待B，B被2号占有；2号占有B，又在等待A）<br>    如果信号量数组只有1个元素，就是我们之前学的信号量，控制一种资源的使用；<br>    <strong>如果只有1个元素，且元素中只有一个资源量，就是我们之前学的互斥量</strong>。<br>    <em>我们希望进程在取资源时，要么获得需要的全部资源，要么不占用任何资源</em>。</p></blockquote><pre><code>int semget(key_t key, int nsems, int semflg);//nsems为数组大小int semctl(int semid, int semnum, int cmd, ...);//semnum为数组下标，cmd为SETVAL时，设置资源总量int semop(int semid, struct sembuf *sops, size_t nsops);//sops为结构体数组首地址，nsops为数组大小</code></pre><blockquote><p>struct sembuf：<br>         unsigned short sem_num;  /* semaphore number <em>/<br>           short          sem_op;   /</em> semaphore operation <em>/<br>           short          sem_flg;  /</em> operation flags <em>/<br>(*</em>sem_num为信号量数组下标，sem_op可正可负，负表示取资源，正表示还资源**)</p></blockquote><p>例程：（实现互斥量）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/sem.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define FNAME "/tmp/out"</span></span><br><span class="line"><span class="comment">#define THRNUM 10 </span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static int semid;</span><br><span class="line">static void P(void)</span><br><span class="line">&#123;   </span><br><span class="line">    struct sembuf sop;</span><br><span class="line">    </span><br><span class="line">    sop.sem_num = 0;</span><br><span class="line">    sop.sem_op = -1;</span><br><span class="line">    sop.sem_flg = 0;</span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;sop,1) &lt; 0)//operat one sembuf</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR || errno != EAGAIN)</span><br><span class="line">        &#123;   </span><br><span class="line">            perror(<span class="string">"semop()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void V(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf sop;</span><br><span class="line"></span><br><span class="line">    sop.sem_num = 0;</span><br><span class="line">    sop.sem_op = 1;</span><br><span class="line">    sop.sem_flg = 0;</span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;sop,1) &lt; 0)//operat one sembuf</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR || errno != EAGAIN)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"semop()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void *thr_add(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    fd = open(FNAME,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    P();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(fd,buf,BUFSIZE) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        perror(<span class="string">"read()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    sleep(1);</span><br><span class="line">    lseek(fd,0,SEEK_SET);</span><br><span class="line">    dprintf(fd,<span class="string">"%d"</span>,atoi(buf)+1);</span><br><span class="line">    fflush(NULL);</span><br><span class="line">    V();</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">    </span><br><span class="line">&#125;   </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,err;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    semid = semget(IPC_PRIVATE,1,0600);//sem array member <span class="built_in">set</span> 1</span><br><span class="line">    <span class="keyword">if</span>(semid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(semctl(semid,0,SETVAL,1) &lt; 0)//sem_array[0] value is 1</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"semctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_add,NULL);</span><br><span class="line">        <span class="keyword">if</span>(err != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    semctl(semid,0,IPC_RMID);   //destory semid</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>**Shared Memory**<pre><code>shmget();void *shmat(int shm_id, const void *shm_addr, int shmflg);    //attch参数：    shm_addr，可以为NULL，让系统在当前进程中找到合适的地址，然后将共享内存映射过来    shmflg，一般为0返回值：失败返回(void *)-1。int shmdt(const void *shmaddr);//detach，将共享内存从当前进程分离shmctl();</code></pre><p>例程：（子写父读）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MEMSIZE 1024</span></span><br><span class="line"></span><br><span class="line">//shmget一块空间后，fork子进程，父子进程间进行通信</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int shmid;</span><br><span class="line">    char *ptr;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(IPC_PRIVATE,MEMSIZE,0600);//create shared memory</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child write</span><br><span class="line">    &#123;</span><br><span class="line">        //<span class="keyword">if</span> shmaddr is NULL, system choose a suitable addr <span class="keyword">in</span> the current process to attch </span><br><span class="line">        ptr = shmat(shmid,NULL,0);//attch to child process</span><br><span class="line">        <span class="keyword">if</span>(ptr == (void *)-1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        strcpy(ptr,<span class="string">"hello"</span>);</span><br><span class="line">        shmdt(ptr); //dettach</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>            //parent <span class="built_in">read</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">        ptr = shmat(shmid,NULL,0);//attch to child process</span><br><span class="line">        <span class="keyword">if</span>(ptr == (void *)-1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(ptr);</span><br><span class="line">        shmdt(ptr); //dettach</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2、XSI -&amp;gt; SysV&lt;br&gt;    &amp;emsp;IPC    -&amp;gt; Inter-Process Communication&lt;br&gt;    &amp;emsp;主动端：先发包的一方&lt;br&gt;    &amp;emsp;被动端：先收包的一方（被动端先运行，创建通信机制）&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程间通信" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>【apue】进程间通信 - 管道</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/13/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/13/%E3%80%90apue%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2020-08-13T15:12:00.000Z</published>
    <updated>2020-08-13T15:22:12.335Z</updated>
    
    <content type="html"><![CDATA[<p>通信方式分类：<br>①位于同一台主机上的        —-    管道、XSI<br>    &emsp;有亲缘关系<br>    &emsp;没有亲缘关系</p><p>②位于不同主机上的        —-    socket</p><p>1、管道</p><blockquote><p>①内核提供，单工<br>    ②自同步机制（迁就比较慢的一方）<br>    ③管道要凑齐读写两方才能进行操作<br>    ④两个管道协同，可实现双工</p></blockquote><p>匿名管道（磁盘看不到，<strong>有亲缘关系的进程间通信</strong>）<br>        &emsp;pipe();//<strong>默认pd[0]读端 [1]写端</strong></p><p>命令管道（实际是一个p文件）<br>        &emsp;mkfifo();//创建命令管道，man 3 mkfifo</p><figure class="image-box">                <img src="https://file.moetu.org/images/2020/08/13/a429ef6ca6c2e80468b3572b6032c5f3c59ef7f04b096061.png" alt="mkfifo xxx 命令行创建" title="" class="">                <p>mkfifo xxx 命令行创建</p>            </figure><blockquote><p>关于效率：想象整个程序是多段粗细不同的水管衔接起来的；限制整体流速的是最细的那一段，<br>所以要优化，提高效率，需要找到结症所在；即使你把直径10m的水管换成100m，但因为最细的那段水管<br>是1m的，所以之前做的工作对整体效率没有任何提升，是无用功。</p></blockquote><p>例程：（父子进程通过匿名管道通信）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int pd[2];</span><br><span class="line">    int len;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pipe(pd) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child <span class="built_in">read</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(pd[1]);   //关闭不需要的写端 </span><br><span class="line">        len = <span class="built_in">read</span>(pd[0],buf,BUFSIZE);</span><br><span class="line">        close(pd[0]);   //读完后关闭读端</span><br><span class="line">        puts(buf);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>            //parent write</span><br><span class="line">    &#123;</span><br><span class="line">        close(pd[0]);</span><br><span class="line">        write(pd[1],<span class="string">"hello"</span>,6);</span><br><span class="line">        close(pd[1]);</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://file.moetu.org/images/2020/08/13/d9092404faa19a33bae807ac9b60a477ecfc8d3dc46a43e2.png" alt="" title="" class="">                <p></p>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通信方式分类：&lt;br&gt;①位于同一台主机上的        —-    管道、XSI&lt;br&gt;    &amp;emsp;有亲缘关系&lt;br&gt;    &amp;emsp;没有亲缘关系&lt;/p&gt;
&lt;p&gt;②位于不同主机上的        —-    socket&lt;/p&gt;
&lt;p&gt;1、管道&lt;/p&gt;
&lt;bl
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程间通信" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg命令</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/ffmpeg%E5%91%BD%E4%BB%A4/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/ffmpeg%E5%91%BD%E4%BB%A4/</id>
    <published>2020-08-03T10:13:00.000Z</published>
    <updated>2020-08-03T10:17:31.825Z</updated>
    
    <content type="html"><![CDATA[<p>ffmpeg使用</p><p>一、音频：</p><p>1.转换<br>    &emsp;①m4a转mp3：ffmpeg -i “input.m4a” -codec:v copy -codec:a libmp3lame -q:a 0 “output.mp3”<br>    &emsp;②mp3转wav：ffmpeg -i input.mp3 -acodec pcm_s16le -ac 1 -ar 8000 output.wav<br>    &emsp;③m4a转wav：ffmpeg -i input.m4a -acodec pcm_s16le -ac 1 -ar 8000 output.wav</p><p>2、压缩：<br>    &emsp;ffmpeg -i input.mp3 -ab 128 output.mp3    （-ab – 表明音频比特率。）</p><p>3、预览或测试音频<br>    &emsp;ffplay xxx.mp3</p><p><strong>转换音频文件脚本tran.sh:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir newfiles</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> *.m4a;<span class="keyword">do</span> ffmpeg -i <span class="string">"<span class="variable">$f</span>"</span> -codec:v copy -codec:a libmp3lame -q:a 0 newfiles/<span class="string">"<span class="variable">$&#123;f%.m4a&#125;</span>.mp3"</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment">#转换音频文件脚本：</span></span><br><span class="line"><span class="comment">#利用ffmpgeg，将当前目录下的.m4a文件转换成.mp3格式文件，存储到newfiles中</span></span><br><span class="line"><span class="comment">#用-qscale:a（或别名-q:a）控制质量。值是特定于编码器的，因此对于libmp3lame，范围是0-9，其中值越小表示质量越高。</span></span><br><span class="line"><span class="comment">#0-3通常会产生透明的结果，4（默认值）应接近感知透明，而6通常会产生“可接受的”质量。</span></span><br></pre></td></tr></table></figure><p>二、视频</p><p>1、转换视频文件到不同的格式<br>    &emsp;①ffmpeg -i video.mp4 video.avi<br>    &emsp;②ffmpeg -i video.flv video.mpeg</p><p>2、从一个视频文件移除音频流<br>    &emsp;ffmpeg -i input.mp4 -an output.mp4    （-an 表示没有音频录制）</p><p>3、从一个媒体文件移除视频流（提取音频）<br>    &emsp;ffmpeg -i input.mp4 -vn output.mp3    （-vn 代表没有视频录制）</p><p>4、调整视频播放速度<br>    &emsp;ffmpeg -i input.mp4 -vf “setpts=0.5*PTS” output.mp4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ffmpeg使用&lt;/p&gt;
&lt;p&gt;一、音频：&lt;/p&gt;
&lt;p&gt;1.转换&lt;br&gt;    &amp;emsp;①m4a转mp3：ffmpeg -i “input.m4a” -codec:v copy -codec:a libmp3lame -q:a 0 “output.mp3”&lt;br&gt;  
      
    
    </summary>
    
    
      <category term="工具使用" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="音视频转换格式" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【apue】管道实例-池类算法</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E7%AE%A1%E9%81%93%E5%AE%9E%E4%BE%8B-%E6%B1%A0%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E7%AE%A1%E9%81%93%E5%AE%9E%E4%BE%8B-%E6%B1%A0%E7%B1%BB%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-03T04:25:00.000Z</published>
    <updated>2020-08-03T04:41:02.275Z</updated>
    
    <content type="html"><![CDATA[<p>回顾之前学多线程互斥量与条件变量时写的池类算法：</p><blockquote></blockquote><pre><code>维护一个num线程池，main（上游线程）分配任务，N个线程（下游线程）到池中抢任务并计算main线程分发数字（任务），&gt;0为有任务，=0当前任务被完成，=-1没有任务可以分发了；其它线程抢任务，计算完成后将num清0；如果num为-1,线程跳出循环结束。</code></pre><p>但是其效率还是比较低的，因为池中只有一个数据，大部分时间线程还是处于等待状态。</p><p>现在用管道（循环队列封装的）来做一个更大池，上游线程往管道写数据，下游线程从管道取数据计算。</p><p>管道封装：<br>①mypipe.h</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef MYPIPE_H__</span></span><br><span class="line"><span class="comment">#define MYPIPE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PIPESIZE      1024</span></span><br><span class="line"></span><br><span class="line">//身份位图，读者|写者</span><br><span class="line"><span class="comment">#define MYPIPE_READ   0X00000001UL</span></span><br><span class="line"><span class="comment">#define MYPIPE_WRITE  0x00000002UL</span></span><br><span class="line">typedef void mypipe_t;</span><br><span class="line">typedef int pipe_data_t;</span><br><span class="line"></span><br><span class="line">mypipe_t *mypipe_init(void);</span><br><span class="line">int mypipe_destroy(mypipe_t *ptr);</span><br><span class="line"></span><br><span class="line">/*********************************************</span><br><span class="line">*如果是骗你的怎么办，注册了读者身份，却去写管道</span><br><span class="line">*可以加一个权限位图</span><br><span class="line">***********************************************/</span><br><span class="line">int mypipe_register(mypipe_t *ptr,int opmap);</span><br><span class="line">int mypipe_unregister(mypipe_t *ptr,int opmap);</span><br><span class="line"></span><br><span class="line">/*********************************************</span><br><span class="line">*函数：想要从管道中读取count个数据，存储到buf中</span><br><span class="line">*返回值：</span><br><span class="line">*   -1  身份不是读者（待补充）</span><br><span class="line">*    0  管道为空且没有写者，退出读等待</span><br><span class="line">*   &gt;0  实际读取的数据个数</span><br><span class="line">***********************************************/</span><br><span class="line">int mypipe_read(mypipe_t *ptr,pipe_data_t *buf,size_t count);</span><br><span class="line">int mypipe_write(mypipe_t *ptr,const pipe_data_t *buf,size_t count);</span><br><span class="line"></span><br><span class="line">//如果管道为空，返回-1；如果管道不为空，读取完成后，无论有没有写者存在，都直接返回实际读取到的数据个数</span><br><span class="line">int mypipe_try_read(mypipe_t *ptr,pipe_data_t *buf,size_t count);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p>②mypipe.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include "mypipe.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DATA_MAX (PIPESIZE+1)  //循环队列,加一空位作判断 </span></span><br><span class="line"></span><br><span class="line">struct mypipe_st</span><br><span class="line">&#123;</span><br><span class="line">    int head;</span><br><span class="line">    int tail;</span><br><span class="line">    pipe_data_t data[DATA_MAX];    //管道大小</span><br><span class="line">    int datasize;</span><br><span class="line">    pthread_mutex_t mut;</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line">    int count_rd;           //读者数量</span><br><span class="line">    int count_wr;           //写者数量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mypipe_t *mypipe_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me;</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    me-&gt;head = 0;</span><br><span class="line">    me-&gt;tail = 0;</span><br><span class="line">    me-&gt;datasize = 0;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut,NULL);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond,NULL);</span><br><span class="line">    me-&gt;count_rd = 0;</span><br><span class="line">    me-&gt;count_wr = 0;</span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int mypipe_register(mypipe_t *ptr,int opmap)</span><br><span class="line">&#123;</span><br><span class="line">    int id_unlegal = 1;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_READ)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_rd++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_wr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id_unlegal)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//有新的读者或写者到来</span><br><span class="line"></span><br><span class="line">    //如果只有写者，或只有读者，则继续等待</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;count_rd &lt;= 0 || me-&gt;count_wr &lt;= 0)</span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mypipe_unregister(mypipe_t *ptr,int opmap)</span><br><span class="line">&#123;</span><br><span class="line">    int id_unlegal = 1;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_READ)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_rd--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opmap &amp; MYPIPE_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        id_unlegal = 0;</span><br><span class="line">        me-&gt;count_wr--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id_unlegal)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//有读者或写者走了</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int next(int n)</span><br><span class="line">&#123;</span><br><span class="line">    n = (n + 1) % DATA_MAX;</span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">static int mypipe_readbyte_unlocked(struct mypipe_st *me,pipe_data_t *datap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;datasize &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    *datap = me-&gt;data[me-&gt;head];</span><br><span class="line">    me-&gt;head = next(me-&gt;head);</span><br><span class="line">    me-&gt;datasize --;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int mypipe_read(mypipe_t *ptr,pipe_data_t *buf,size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    //当前管道空</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;datasize &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(me-&gt;count_wr &gt; 0)//有写者，才继续等待</span><br><span class="line">            pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line">        <span class="keyword">else</span> //没有写者，解锁，退出读</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mypipe_readbyte_unlocked(me,buf+i) != 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知数据被读出，可写</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int mypipe_writebyte_unlocked(struct mypipe_st *me,const pipe_data_t *ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;datasize &gt;= DATA_MAX)</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    me-&gt;data[me-&gt;tail] = *ch;</span><br><span class="line">    me-&gt;tail = next(me-&gt;tail);</span><br><span class="line">    me-&gt;datasize ++;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int mypipe_write(mypipe_t *ptr,const pipe_data_t *buf,size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    //当前管道满</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;datasize &gt;= DATA_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(me-&gt;count_rd &gt; 0)//还有读者，则继续等待</span><br><span class="line">            pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line">        <span class="keyword">else</span>    //没有读者，解锁，退出写</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mypipe_writebyte_unlocked(me,buf+i) != 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知有数据到来，可读</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mypipe_destroy(mypipe_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    free(me);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mypipe_try_read(mypipe_t *ptr,pipe_data_t *buf,size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    struct mypipe_st *me = ptr;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(me-&gt;datasize &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mypipe_readbyte_unlocked(me,buf+i) != 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知数据被读出，可写</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③main.c和makefile就不贴出来了。</p><p><img src="https://file.moetu.org/images/2020/08/03/6551e26d5cf543e283fb336b825c73e941c8ac96f6c9dae3.png" alt="测试结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回顾之前学多线程互斥量与条件变量时写的池类算法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;维护一个num线程池，main（上游线程）分配任务，N个线程（下游线程）到池中抢任务并计算
main线程分发数字（任务），&amp;gt;0为有任务
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="管道封装" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E7%AE%A1%E9%81%93%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>【apue】文件锁</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E6%96%87%E4%BB%B6%E9%94%81/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E6%96%87%E4%BB%B6%E9%94%81/</id>
    <published>2020-08-03T04:07:00.000Z</published>
    <updated>2020-08-03T04:10:47.070Z</updated>
    
    <content type="html"><![CDATA[<p>5、文件锁<br>    fcntl();<br>    lockf();//比较常用<br>    flock();</p><p>意外解锁现象：<br>&emsp;<strong>文件锁是加在inode层面的</strong>，如果有多个fd指向一个inode，其中一个fd关闭，会造成其它fd意外解锁。</p><p>加锁后写数据，解锁前要调用fflush，将缓冲区的内容写入文件。</p><p>之前用互斥量实现的add.c，现在用文件锁重构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">include &lt;unistd.h&gt;</span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#define PROCNUM  (10)</span></span><br><span class="line"><span class="comment">#define FNAME "/tmp/out"</span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static void proc_add(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = fileno(fp);</span><br><span class="line">    lockf(fd,F_LOCK,0);</span><br><span class="line">    fgets(buf,BUFSIZE,fp);</span><br><span class="line">    rewind(fp);//equal to fseek(fp,0,SEEK_SET);</span><br><span class="line">//    sleep(1);//放大线程竞争</span><br><span class="line">    fprintf(fp,<span class="string">"%d\n"</span>,atoi(buf)+1);</span><br><span class="line">    fflush(fp);//将缓冲区中内容写入文件</span><br><span class="line">    lockf(fd,F_ULOCK,0);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int err,i;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid  = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            proc_add();</span><br><span class="line">            <span class="built_in">exit</span>(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; PROCNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;5、文件锁&lt;br&gt;    fcntl();&lt;br&gt;    lockf();//比较常用&lt;br&gt;    flock();&lt;/p&gt;
&lt;p&gt;意外解锁现象：&lt;br&gt;&amp;emsp;&lt;strong&gt;文件锁是加在inode层面的&lt;/strong&gt;，如果有多个fd指向一个inode，其中一个
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高级IO" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E9%AB%98%E7%BA%A7IO/"/>
    
  </entry>
  
  <entry>
    <title>【apue】存储映射IO</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84IO/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84IO/</id>
    <published>2020-08-03T03:55:00.000Z</published>
    <updated>2020-08-03T04:05:05.567Z</updated>
    
    <content type="html"><![CDATA[<p>4、存储映射IO<br>    mmap();//<strong>有亲缘关系进程间通信，共享内存</strong>。</p><p>函数详解：</p><blockquote><p>void *mmap(void *addr, size_t length, int prot, int flags,<br>                  int fd, off_t offset);<br>    参数：<br>        addr：一般直接赋NULL，让内核随意找一块空间<br>        prot：内存的读写权限设置<br>        flags：特殊要求，MAP_SHARED和MAP_PRIVATE中的一个，再或上其它内容<br>                如果有或上MAP_ANONYMOUS，匿名空间，内容初始化为0，不需要fd，直接设置-1<br>        fd，offset，length：将文件的某个位置开始，length长度的内容映射到内存<br>    返回值：<br>        成功返回首地址，失败返回MAP_FAILED<br><br><br>    int munmap(void *addr, size_t length);</p></blockquote><p>例子1：将指定fd的内容映射到某个存储空间，统计其中a的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char *ptr;</span><br><span class="line">    struct <span class="built_in">stat</span> statres;</span><br><span class="line">    int i,count = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[1],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd,&amp;statres) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fstat()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = mmap(NULL,statres.st_size,PROT_READ,MAP_SHARED,fd,0);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        munmap(ptr,statres.st_size);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; statres.st_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr[i] == <span class="string">'a'</span>)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">    munmap(ptr,statres.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：mmap申请一块空间后，fork子进程，父子进程间进行通信</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MEMSIZE 1024</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;   </span><br><span class="line">    pid_t pid;</span><br><span class="line">    char *ptr;</span><br><span class="line">    int i,count = 0;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    ptr = mmap(NULL,MEMSIZE,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        munmap(ptr,MEMSIZE);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == 0)    //child write</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(ptr,<span class="string">"hello"</span>);</span><br><span class="line">        munmap(ptr,MEMSIZE);//子进程也要解除映射</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>            //parent <span class="built_in">read</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(NULL);</span><br><span class="line">        puts(ptr);</span><br><span class="line">        munmap(ptr,MEMSIZE);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4、存储映射IO&lt;br&gt;    mmap();//&lt;strong&gt;有亲缘关系进程间通信，共享内存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;函数详解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;void *mmap(void *addr, size_t length, int pro
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高级IO" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E9%AB%98%E7%BA%A7IO/"/>
    
  </entry>
  
  <entry>
    <title>【apue】非阻塞IO与IO多路转接</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E9%AB%98%E7%BA%A7IO/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/%E3%80%90apue%E3%80%91%E9%AB%98%E7%BA%A7IO/</id>
    <published>2020-08-03T02:46:00.000Z</published>
    <updated>2020-08-03T04:22:01.516Z</updated>
    
    <content type="html"><![CDATA[<p>非阻塞IO    —-    阻塞IO    </p><p>补充：有限状态机编程</p><p>1、非阻塞IO<br>    简单流程：自然流程是结构化的（如open -&gt; put -&gt; close）<br>    复杂流程：自然流程不是结构化的（网络协议）</p><pre><code>数据中继引擎：    （当我们指定打开的设备为O_NONBLOCK，read/write就不会阻塞；没有读到内容，    返回-1，设置errno为EAGAIN）    因此读完数据后状态机就会陷入忙推状态，一直在等待新的数据。</code></pre><p>利用有限状态机编程思想，实现两个文件（或终端，要在main中加while(1) pause();）相互传输数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TTY1 "./file1"</span></span><br><span class="line"><span class="comment">#define TTY2 "./file2"</span></span><br><span class="line"><span class="comment">#define BUFSIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    STATE_R = 1,</span><br><span class="line">    STATE_W,</span><br><span class="line">    STATE_Ex,</span><br><span class="line">    STATE_T</span><br><span class="line">&#125;;</span><br><span class="line">struct fsm_st</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">stat</span>;</span><br><span class="line">    int sfd;</span><br><span class="line">    int dfd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    int len;</span><br><span class="line">    int pos;</span><br><span class="line">    char *errstr;</span><br><span class="line">&#125;;</span><br><span class="line">static void driver(struct fsm_st *fsm)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    switch(fsm-&gt;<span class="built_in">stat</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_R:</span><br><span class="line">            fsm-&gt;len = <span class="built_in">read</span>(fsm-&gt;sfd,fsm-&gt;buf,BUFSIZE);</span><br><span class="line">            <span class="keyword">if</span>(fsm-&gt;len == 0)//读取完成，结束</span><br><span class="line">                fsm-&gt;<span class="built_in">stat</span> = STATE_T;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fsm-&gt;len &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN)//假错，重新读</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_R;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"read()"</span>;</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_Ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fsm-&gt;pos = 0;</span><br><span class="line">                fsm-&gt;<span class="built_in">stat</span> = STATE_W;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> STATE_W:</span><br><span class="line">            ret = write(fsm-&gt;dfd,fsm-&gt;buf+fsm-&gt;pos,fsm-&gt;len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_W;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"write()"</span>;</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_Ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                //坚持写完</span><br><span class="line">                fsm-&gt;len -= ret;</span><br><span class="line">                <span class="keyword">if</span>(fsm-&gt;len == 0)</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_R;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fsm-&gt;pos += ret;</span><br><span class="line">                    fsm-&gt;<span class="built_in">stat</span> = STATE_W;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_Ex:</span><br><span class="line">            perror(fsm-&gt;errstr);</span><br><span class="line">            fsm-&gt;<span class="built_in">stat</span> = STATE_T;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_T:</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            abort();</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void relay(int fd1, int fd2)</span><br><span class="line">&#123;</span><br><span class="line">    int fd1_save,fd2_save;</span><br><span class="line">    struct fsm_st fsm12,fsm21;</span><br><span class="line"></span><br><span class="line">    //先确保两个文件是非阻塞的</span><br><span class="line">    fd1_save = fcntl(fd1,F_GETFD);</span><br><span class="line">    fcntl(fd1,F_SETFD,fd1_save|O_NONBLOCK);</span><br><span class="line">    fd2_save = fcntl(fd2,F_GETFD);</span><br><span class="line">    fcntl(fd2,F_SETFD,fd2_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fsm12.stat = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line">    fsm21.stat = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fsm12.stat != STATE_T || fsm21.stat != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        driver(&amp;fsm12);</span><br><span class="line">        driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(fd1,F_SETFD,fd1_save);</span><br><span class="line">    fcntl(fd2,F_SETFD,fd2_save);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int fd1,fd2;</span><br><span class="line"></span><br><span class="line">    fd1 = open(TTY1,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd1 &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd2 = open(TTY2,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd2 &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    relay(fd1,fd2);</span><br><span class="line"></span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尝试封装一个数据中继引擎</strong>（封装方法类似之前的anytimer，下面部分程序供参考：）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">enum rel_state</span><br><span class="line">&#123;   </span><br><span class="line">    REL_RUNNING = 1,</span><br><span class="line">    REL_CANCELED,</span><br><span class="line">    REL_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rel_job_st</span><br><span class="line">&#123;   </span><br><span class="line">    int rel_stat;               //中继任务状态</span><br><span class="line">    int fd1,fd2;                //交换数据双方</span><br><span class="line">    struct fsm_st fsm12,fsm21;  //两个有限状态机</span><br><span class="line">    int fd1_save,fd2_save;       //保存好的原文件状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int get_free_pos_unlocked(void);</span><br><span class="line">static void fsm_driver(struct fsm_st *fsm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void *thr_relayer(void *p)</span><br><span class="line">&#123;   </span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_mutex_lock(&amp;job_mut);</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; REL_JOBMAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(job[i]-&gt;rel_stat == REL_RUNNING)</span><br><span class="line">                &#123;</span><br><span class="line">                    fsm_driver(&amp;job[i]-&gt;fsm12);</span><br><span class="line">                    fsm_driver(&amp;job[i]-&gt;fsm21);</span><br><span class="line">                    <span class="keyword">if</span>(job[i]-&gt;fsm12.stat == STATE_T &amp;&amp; \</span><br><span class="line">                        job[i]-&gt;rel_stat = REL_OVER;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;job_mut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、IO多路转接</p><blockquote><p>监视文件描述符：<br>    select();    //以事件为单位组织文件描述符；最古老，移植性好；接口设计有缺陷；<br>    poll();        //以文件描述符为单位来组织事件；移植性也可以，用户自己来维护一些内容<br>    epoll();    //方言</p></blockquote><p><strong>以事件为单位组织文件描述符：</strong><br>int select(int nfds, fd_set *readfds, fd_set *writefds,<br>                  fd_set *exceptfds, struct timeval *timeout);</p><p>函数会阻塞直到：<br>    ①一个或多个文件描述符变成“ready”态<br>    ②被信号打断<br>    ③超时</p><p>参数：<br>    &emsp;nfds：最大的文件描述符+1<br>    &emsp;三个集合：*将发生变化的描述符以位图方式回写，没有变化则全部位清0，需要重新布置监视任务 *<br>    &emsp;timeout：超时设置，NULL则阻塞<br>返回值：<br>    &emsp;&gt;0，    成功，返回三集合（读集，写集，异常集）中发生变化的fd个数<br>    &emsp;=0，    超时<br>    &emsp;-1，    失败，设置errno</p><p>文件描述符集合：fd_set（类似信号集sigset_t）<br>    &emsp;FD_CLR：从fd集合中删除指定fd；<br>    &emsp;FD_ISSET：判断fd是否属性某个集合<br>    &emsp;FD_SET：添加一个fd到集合<br>    &emsp;FD_ZERO：清空集体</p><p>布置监视任务，监视，查看监视结果。</p><blockquote><p>select缺陷：<br>    监视现场和监视结果存放的是同一块空间<br>    监视的事件太单一，除了读，写，其它都算是异常</p></blockquote><p>用select()监视读写事件发生：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    STATE_R = 1,</span><br><span class="line">    STATE_W,</span><br><span class="line">STATE_AUTO,// 大于这个值，则自动推状态机</span><br><span class="line">    STATE_Ex,</span><br><span class="line">    STATE_T</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">修改relay.c中的推动状态机部分的程序</span><br><span class="line"><span class="keyword">while</span>(fsm12.stat != STATE_T || fsm21.stat != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        //布置监视现场</span><br><span class="line">        FD_ZERO(&amp;rset);</span><br><span class="line">        FD_ZERO(&amp;wset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_R)</span><br><span class="line">            FD_SET(fsm12.sfd,&amp;rset);</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_W)</span><br><span class="line">            FD_SET(fsm12.dfd,&amp;wset);</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_R)</span><br><span class="line">            FD_SET(fsm21.sfd,&amp;rset);</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_W)</span><br><span class="line">            FD_SET(fsm21.dfd,&amp;wset);</span><br><span class="line"></span><br><span class="line">        //监视</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat &lt; STATE_AUTO || fsm21.stat &lt; STATE_AUTO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(select(max(fd1,fd2)+1, &amp;rset, &amp;wset, NULL, NULL) &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"select()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查看监视结果</span><br><span class="line">        <span class="keyword">if</span>( FD_ISSET(fd1,&amp;rset) || FD_ISSET(fd2,&amp;wset) \</span><br><span class="line">                ||fsm12.stat &gt; STATE_AUTO)</span><br><span class="line">            driver(&amp;fsm12);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( FD_ISSET(fd2,&amp;rset) || FD_ISSET(fd1,&amp;wset) \</span><br><span class="line">                ||fsm21.stat &gt; STATE_AUTO)</span><br><span class="line">            driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>以文件描述符为单位来组织事件：</strong><br>int poll(struct pollfd *fds, nfds_t nfds, int timeout);<br>参数：<br>    &emsp;fds：结构体数组的起始地址<br>    &emsp;nfds：监视的fd个数<br>    &emsp;timeout：单位为ms，0表示非阻塞，-1表示阻塞</p><p>struct pollfd {<br>               int   fd;         /* file descriptor <em>/<br>               short events;     /</em> 我们关心的事件 <em>/<br>               short revents;    /</em> 实际返回的事件 */<br>           };<br>events，revents都是16位的位图，暂时可监视7种事件</p><p>用poll()监视两个文件描述符的变化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fsm12.stat != STATE_T || fsm21.stat != STATE_T)</span><br><span class="line">    &#123;</span><br><span class="line">        //布置监视现场</span><br><span class="line">        pfd[0].events = 0;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_R)</span><br><span class="line">            pfd[0].events |= POLLIN;</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_W)</span><br><span class="line">            pfd[0].events |= POLLOUT;</span><br><span class="line"></span><br><span class="line">        pfd[1].events = 0;</span><br><span class="line">        <span class="keyword">if</span>(fsm21.stat == STATE_R)</span><br><span class="line">            pfd[1].events |= POLLIN;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat == STATE_W)</span><br><span class="line">            pfd[1].events |= POLLOUT;</span><br><span class="line"></span><br><span class="line">        //监视</span><br><span class="line">        <span class="keyword">if</span>(fsm12.stat &lt; STATE_AUTO || fsm21.stat &lt; STATE_AUTO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(poll(pfd, 2, -1) &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"select()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查看监视结果</span><br><span class="line">        <span class="keyword">if</span>( (pfd[0].revents &amp; POLLIN) || (pfd[1].revents &amp; POLLOUT) \</span><br><span class="line">                ||fsm12.stat &gt; STATE_AUTO )</span><br><span class="line">            driver(&amp;fsm12);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (pfd[1].revents &amp; POLLIN) || (pfd[0].revents &amp; POLLOUT)  \</span><br><span class="line">                ||fsm21.stat &gt; STATE_AUTO )</span><br><span class="line">            driver(&amp;fsm21);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>epoll：相当于将poll机制封装了一层，放到了内核当中。</strong><br>struct pollfd数组由内核维护，提供几个系统调用给用户使用。<br>    epoll_create();    //创建一个epoll实例，参数现在是任意的正值，返回值是fd，可以用close关闭<br>    epoll_ctl();    //<strong>EPERM  目标fd不支持epoll.</strong><br>    epoll_wait();</p><blockquote><p>学习IO多路转接后，可以尝试用poll来优化之前的数据中继引擎。</p></blockquote><p>3、其它读写函数</p><p>读写多个buffers：<br>    readv();<br>    writev();<br>坚持读写n个字节（apue.h）：<br>    readn();<br>    writen();</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非阻塞IO    —-    阻塞IO    &lt;/p&gt;
&lt;p&gt;补充：有限状态机编程&lt;/p&gt;
&lt;p&gt;1、非阻塞IO&lt;br&gt;    简单流程：自然流程是结构化的（如open -&amp;gt; put -&amp;gt; close）&lt;br&gt;    复杂流程：自然流程不是结构化的（网络协议）&lt;
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高级IO" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E9%AB%98%E7%BA%A7IO/"/>
    
      <category term="有限状态机编程思想" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Xshell设置与使用</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/Xshell%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/08/03/Xshell%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-08-03T02:07:00.000Z</published>
    <updated>2020-08-03T10:17:59.941Z</updated>
    
    <content type="html"><![CDATA[<p>配色：New Black</p><p>字体：DejaVu Sans Mono  12</p><p>关闭提示音：工具 - 选项 - 高级 - 禁用铃声</p><p>不使用Xftp：工具 - 选项 - 高级 - 打开SFTP会话，不执行Xftp</p><p>SFTP命令：</p><blockquote></blockquote><pre><code>服务器端（虚拟机）操作：    支持的常规命令：ls cd mkdir mv pwd rm rmdir clear</code></pre><br>    本地端（电脑）相关操作：        lls 显示本地工作目录文件列表        lpwd 显示本地工作目录路径        explore 使用电脑资源管理器打开本地工作目录        lcd 切换本地工作目录（切换文件传输位置）<br>            文件传输：        put 上传文件到服务器        get 下载文件到本地<br>                bye    关闭SFTP会话        quit 完成SFTP会话<p>linux快捷键：<br>    &emsp;ctrl + u：删除光标前字符<br>    &emsp;ctrl + k：删除光标后字符<br>    &emsp;ctrl + a：光标移动行首<br>    &emsp;ctrl + e：光标移动行尾</p><p>xshell快捷键：<br>    &emsp;切换窗口：shift/ctrl + tab</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配色：New Black&lt;/p&gt;
&lt;p&gt;字体：DejaVu Sans Mono  12&lt;/p&gt;
&lt;p&gt;关闭提示音：工具 - 选项 - 高级 - 禁用铃声&lt;/p&gt;
&lt;p&gt;不使用Xftp：工具 - 选项 - 高级 - 打开SFTP会话，不执行Xftp&lt;/p&gt;
&lt;p&gt;SFTP命令
      
    
    </summary>
    
    
      <category term="工具使用" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Xshell" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/Xshell/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机和电脑能相互ping通，但使用putty远程连接</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%94%B5%E8%84%91%E8%83%BD%E7%9B%B8%E4%BA%92ping%E9%80%9A%EF%BC%8C%E4%BD%86%E4%BD%BF%E7%94%A8putty%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%94%B5%E8%84%91%E8%83%BD%E7%9B%B8%E4%BA%92ping%E9%80%9A%EF%BC%8C%E4%BD%86%E4%BD%BF%E7%94%A8putty%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</id>
    <published>2020-07-31T14:52:00.000Z</published>
    <updated>2020-07-31T15:03:26.271Z</updated>
    
    <content type="html"><![CDATA[<p>用filezilla，putty或xshell无法连接虚拟机！！！！</p><p>找好两天，在某篇文章中的评论找到了正解。</p><blockquote><p>设置的静态ip不要和电脑中的适配网卡ip相同！！！<br>如果VMnet8中网关为192.168.174.2，则电脑适配网卡可以设置为192.168.174.1<br>最后虚拟机中静态ip设置192.168.174.3</p></blockquote><p>我的问题就是：将静态Ip设置成192.168.174.1，后果就是<br>虚拟机和电脑能相互Ping通，但无法用putty远程连接.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用filezilla，putty或xshell无法连接虚拟机！！！！&lt;/p&gt;
&lt;p&gt;找好两天，在某篇文章中的评论找到了正解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置的静态ip不要和电脑中的适配网卡ip相同！！！&lt;br&gt;如果VMnet8中网关为192.168.174.2
      
    
    </summary>
    
    
      <category term="Linux问题集" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="虚拟机" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【apue】线程实例</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/30/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/30/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-07-30T01:46:00.000Z</published>
    <updated>2020-07-30T02:20:16.362Z</updated>
    
    <content type="html"><![CDATA[<p>一、模拟信号量实现：</p><p>main.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include "mysem.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  (RIGHT-LEFT+1)</span></span><br><span class="line"><span class="comment">#define N       4       </span></span><br><span class="line">//不限制创建线程的数量，但同一时刻只能有4个线程</span><br><span class="line"></span><br><span class="line">static mysem_t *sem;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line"></span><br><span class="line">    i = (int)p;</span><br><span class="line"></span><br><span class="line">    mark = 1;</span><br><span class="line">    <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = 0;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is primer\n"</span>,i);</span><br><span class="line"></span><br><span class="line">    //sleep(5); //放大信号量效果，同一时刻只能存在N个线程</span><br><span class="line">    mysem_add(sem,1);//归还信号量</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    sem = mysem_init(N);</span><br><span class="line">    <span class="keyword">if</span>(sem == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"mysem_init() fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mysem_sub(sem,1);//使用信号量</span><br><span class="line">        err = pthread_create(tid+(i-LEFT),NULL,thr_primer,(void *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT],NULL);//回收线程,接收返回值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysem_destroy(sem);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mysem.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include "mysem.h"</span></span><br><span class="line"></span><br><span class="line">typedef void mysem_t;</span><br><span class="line"></span><br><span class="line">struct mysem_st</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    pthread_mutex_t mut;</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mysem_t *mysem_init(int initval)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me;</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    me-&gt;value = initval;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut,NULL);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mysem_add(mysem_t *ptr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    me-&gt;value += n;</span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//通知其它线程value有变化</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mysem_sub(mysem_t *ptr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;value &lt; n)</span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    me-&gt;value -= n;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mysem_destroy(mysem_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mysem_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自行补充makefile和mysem.h文件。<br>上面的信号量实现，是为了限制同一时间的线程数量；要<em>测试</em>：先将main中的sleep取消注释；新建终端，隔一段时间ps一次，会发现，除main线程不变外，同一时间总是存在4个线程，它们的id号会变化。</p><p>二、用多线程<strong>重构令牌桶</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "mytbf.h"</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct mytbf_st</span><br><span class="line">&#123;</span><br><span class="line">    int cps;</span><br><span class="line">    int burst;</span><br><span class="line">    int token;</span><br><span class="line">    int pos;</span><br><span class="line">    pthread_mutex_t mut;</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static pthread_t tid_alrm;</span><br><span class="line">static struct mytbf_st *job[MYTBF_MAX];//static,默认初始化为0</span><br><span class="line">static pthread_mutex_t mut_job = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">static pthread_once_t init_once;</span><br><span class="line"></span><br><span class="line">static void *thr_alrm(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                            pthread_mutex_lock(&amp;job[i]-&gt;mut);</span><br><span class="line">                job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">                <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                    job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">                pthread_cond_broadcast(&amp;job[i]-&gt;cond);//通知token发生变化</span><br><span class="line">                pthread_mutex_unlock(&amp;job[i]-&gt;mut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void module_unload(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_cancel(tid_alrm);</span><br><span class="line">    pthread_join(tid_alrm,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            mytbf_destroy(job[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void module_load(void)</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    err = pthread_create(&amp;tid_alrm,NULL,thr_alrm,NULL);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int get_free_pos_unlock(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == NULL)</span><br><span class="line">            <span class="built_in">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mytbf_t *mytbf_init(int cps,int burst)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me;</span><br><span class="line">    int pos;</span><br><span class="line"></span><br><span class="line">    pthread_once(&amp;init_once,module_load);</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;//malloc失败</span><br><span class="line"></span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;token = 0;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut,NULL);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond,NULL);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);//加锁</span><br><span class="line">    pos = get_free_pos_unlock();</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        free(me);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_job);//解锁</span><br><span class="line">        <span class="built_in">return</span> NULL;//令牌桶个数达到上限</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line">    job[pos] = me;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);//解锁</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int min(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="built_in">return</span> a;</span><br><span class="line">    <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//size为想要取的token数，返回值为实际取得的token数</span><br><span class="line">int mytbf_fetchtoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);//加锁</span><br><span class="line"></span><br><span class="line">    //通知法</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //等待其它人来通知，得到通知第一反应是先抢锁;如果条件不成立解锁继续等&gt;待</span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond,&amp;me-&gt;mut);</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">    //查询法，忙等</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;me-&gt;mut);//解锁</span><br><span class="line">        sched_yield();//出让CPU使用权</span><br><span class="line">        pthread_mutex_lock(&amp;me-&gt;mut);//抢锁</span><br><span class="line">    &#125;</span><br><span class="line">*/</span><br><span class="line">    n = min(me-&gt;token,size);</span><br><span class="line"></span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归还未使用的token</span><br><span class="line">int mytbf_returntoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);//加锁</span><br><span class="line"></span><br><span class="line">    me-&gt;token += size;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);//广播通知token发生变化</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);//解锁</span><br><span class="line">    <span class="built_in">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mytbf_destroy(mytbf_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;//转换</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_job);</span><br><span class="line">    job[me-&gt;pos] = NULL;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_job);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    free(ptr);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、用线程<strong>重构anytimer</strong>：</p><p>思路：<br>①module_load时创建<strong>一个始终运行的定时线程</strong>（job数组中所有元素的sec–，出现sec减至0的元素就发广播通知）；module_unload挂到钩子函数，在exit前运行，进行清理回收工作；<br>②<strong>每个定时任务都要一个自己的等待执行线程</strong>，计时完成（收到通知）后执行任务，线程退出，但因为有将tid保存到timjob_st中，所以可以在最后deljob时，调用pthread_join回收线程。<br>③<em>回收线程和销毁定时任务策略</em>：已完成的任务，是执行后直接销毁；还是先不管，到最后module_unload时统一销毁；或者超过一定数量回收一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、模拟信号量实现：&lt;/p&gt;
&lt;p&gt;main.c&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="信号量" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>【apue】线程竞争与同步</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/29/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/29/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%90%8C%E6%AD%A5/</id>
    <published>2020-07-29T10:43:00.000Z</published>
    <updated>2020-07-29T11:23:33.967Z</updated>
    
    <content type="html"><![CDATA[<p>线程竞争：<br>    因为进程中多个线程的代码段是共用的，所以在访问一些资源和变量时可能产生冲突。</p><p>竞争例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define THRNUM  (10)</span></span><br><span class="line"><span class="comment">#define FNAME "/tmp/out"</span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line">static void* thr_add(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    fp = fopen(FNAME,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fgets(buf,BUFSIZE,fp);</span><br><span class="line">    rewind(fp);//equal to fseek(fp,0,SEEK_SET);</span><br><span class="line">    sleep(1);//放大线程竞争</span><br><span class="line">    fprintf(fp,<span class="string">"%d\n"</span>,atoi(buf)+1);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_add,NULL);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>echo 1 &gt; /tmp/out<br>./add<br>cat /tmp/out<br>得到2（所有线程读到的都是1，对文件重复写2）<br>解决思路：用互斥量，限制同一时间只能有一个线程对文件进行读写</p><p>3、线程同步</p><p>互斥量（某一时刻只能有一个人在小黑屋里写或读写（更严格））<br>    pthread_mutex_t;<br>    pthread_mutex_init();<br>    pthread_mutex_destory();<br>    pthread_mutex_lock();        //阻塞<br>    pthread_mutex_trylock();    //非阻塞<br>    pthread_mutex_unlock();</p><p>sleep();放大竞争和故障。</p><p><strong>sched_yield();//出让CPU使用权</strong></p><p><strong>互斥锁，不是限制某个资源某个变量的读写，而限制代码能否运行下去。我们将被限制的代码区称为临界区。</strong></p><blockquote><p>第一次man pthread_mutex_init可能失败，要安装manpages-posix-dev)</p></blockquote><p>线程池：<br>    例：primer_pool_busy.c（查询法）<br>    维护一个num线程池，main（上游线程）分配任务，N个线程（下游线程）到池中抢任务并计算<br>    main线程分发数字（任务），&gt;0为有任务，=0当前任务被完成，=-1没有任务可以分发了；<br>    其它线程抢任务，计算完成后将num清0；如果num为-1,线程跳出循环结束。</p><p><strong>要注意临界区内的所有跳转语句，如果是跳转出临界区外，则跳转前要解锁，避免造成死锁</strong>。<br>临界区内的调用函数要能返回。</p><p><strong>动态模块的单次初始化函数：pthread_once();</strong></p><p>条件变量<br>    pthread_cond_t<br>    phtread_cond_init();<br>    phtread_cond_destroy();<br>    pthread_cond_broadcast();<br>    pthread_cond_signal();<br>    pthread_cond_wait();    </p><p>信号量<br>    限制某时刻使用资源的用量</p><p>读写锁<br>    读锁 —&gt; 共享锁<br>    写锁 —&gt; 互斥锁<br>    避免写者饿死：如果有写者到来，后来的读者不能再读。<br><br><br><big><strong>通过已学的线程知识，重构primer0.c</strong></big></p><p><strong>交叉分配法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  10 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct thr_arg_st</span><br><span class="line">&#123;</span><br><span class="line">    int id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line">    int ID;</span><br><span class="line">    ID = ((struct thr_arg_st *)p)-&gt;id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT+ID; i &lt;= RIGHT; i += THRNUM)</span><br><span class="line">    &#123;</span><br><span class="line">        mark = 1;</span><br><span class="line">        <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = 0;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is primer\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,id;</span><br><span class="line">    struct thr_arg_st *arg;</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(id = 0; id &lt; THRNUM; id++)</span><br><span class="line">    &#123;</span><br><span class="line">        arg = malloc(sizeof(*arg));</span><br><span class="line">        arg-&gt;id = id;</span><br><span class="line">        err = pthread_create((tid+id),NULL,thr_primer,arg);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(id = 0; id &lt; THRNUM; id++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[id],&amp;ptr);//回收线程,接收返回值</span><br><span class="line">        free(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池方法：</strong></p><blockquote><p>线程池实现:<br>    main线程分发数字（任务），&gt;0为有任务，=0当前任务被完成，=-1没有任务可以分发了；<br>    其它线程抢任务，计算完成后将num清0；如果num为-1,线程跳出循环结束。</p></blockquote><br>    ①查询法，忙等（涉及互斥量）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  (4)</span></span><br><span class="line"></span><br><span class="line">static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">static int num = 0;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line">    int n = (int)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">if</span>(num == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = num;</span><br><span class="line">        num = 0;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line"></span><br><span class="line">        mark = 1;</span><br><span class="line">        <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = 0;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]:%d is primer\n"</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_primer,(void *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">while</span>(num != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            sched_yield();//出让CPU使用权</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        &#125;</span><br><span class="line">        num = i;//下发新的数字</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">    num = -1;//提醒线程结束</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//回收线程</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>②通知法（涉及互斥量，条件变量）（cpu使用率较低）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEFT    30000000</span></span><br><span class="line"><span class="comment">#define RIGHT   30000200</span></span><br><span class="line"><span class="comment">#define THRNUM  (4)</span></span><br><span class="line"></span><br><span class="line">static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">static pthread_cond_t cond_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line">static int num = 0;</span><br><span class="line"></span><br><span class="line">static void* thr_primer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,mark;</span><br><span class="line">    int n = (int)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">while</span>(num == 0)</span><br><span class="line">        &#123;   </span><br><span class="line">            pthread_cond_wait(&amp;cond_num,&amp;mut_num);//等待任务下发或结束</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == -1)</span><br><span class="line">        &#123;   </span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        i = num;</span><br><span class="line">                num = 0;</span><br><span class="line">        pthread_cond_broadcast(&amp;cond_num);//广播通知任务被领取</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁</span><br><span class="line"></span><br><span class="line">        mark = 1;</span><br><span class="line">        <span class="keyword">for</span>(j = 2; j &lt; i/2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = 0;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d]:%d is primer\n"</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[THRNUM];</span><br><span class="line">    int err,i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i,NULL,thr_primer,(void *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //main线程下发数字</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">        <span class="keyword">while</span>(num != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond_num,&amp;mut_num);//等待任务被线程领取</span><br><span class="line">        &#125;</span><br><span class="line">        num = i;</span><br><span class="line">        pthread_cond_signal(&amp;cond_num);//通知下游线程，有任务分发下来</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);//抢锁</span><br><span class="line">    num = -1;//提醒线程结束</span><br><span class="line">    pthread_cond_broadcast(&amp;cond_num);//通知下游所有线程退出</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);//解锁    </span><br><span class="line"></span><br><span class="line">    //回收线程</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    pthread_cond_destroy(&amp;cond_num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程竞争：&lt;br&gt;    因为进程中多个线程的代码段是共用的，所以在访问一些资源和变量时可能产生冲突。&lt;/p&gt;
&lt;p&gt;竞争例子：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池方法" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【apue】线程介绍</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/29/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/29/%E3%80%90apue%E3%80%91%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-29T10:23:00.000Z</published>
    <updated>2020-07-30T02:27:03.008Z</updated>
    
    <content type="html"><![CDATA[<p><strong>会话承载进程组，进程组承载进程，进程承载线程。</strong></p><p>1、线程的概念<br>    <strong>一个正在运行的函数<br>    多个线程的地址空间是共享的（代码段是共用的，栈是独立的）</strong><br>    posix线程是一套标准，而不是实现<br>    openmp线程<br>    线程标识：pthread_t（p是指posix标准）<br>    线程消耗进程号(ps ax -L 查看线程，LWP)<br>    编译和链接都要带-pthread。<br>    线程的调度取决于调度器的调度策略</p><p>pthread_equal();//比较两个线程<br>pthread_self();//返回当前线程标识</p><p>2、线程的创建<br>    pthread_create();<br>    //参数：pthread_t的地址，指定属性，入口函数地址，函数参数<br>    //返回值，成为返回0；失败返回error number，用strerror辅助报错</p><p>   线程的终止：<br>    3种方式：<br>&emsp;1）线程从启动例程返回，返回值就是线程的退出码<br>&emsp;2）线程可以被同一进程中的其它线程取消<br>&emsp;3）线程调用pthread_exit()</p><p>回收线程：pthread_join（类似进程中的wait）</p><p>   栈的清理<br>    pthread_cleanup_push();<br>    pthread_cleanup_pop();<br>    //比钩子函数多了主动权，pthread_cleanup_pop可以选择压栈的函数是否被调用<br>    //要成对出现，pop操作一定要有，如果放到pthread_exit后面，则都当成1。</p><p>简单例程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line">static void *func(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">"thread is working."</span>);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    puts(<span class="string">"begin."</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid,NULL,func,NULL);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"pthread_create():%s\n"</span>,strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid,NULL); //  等待线程终止</span><br><span class="line">    puts(<span class="string">"end."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);    //进程结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的取消选项：<br>pthread_cancel();<br>&emsp;取消有两种状态：允许和不允许；<br>&emsp;允许取消又分为异步cancel和推迟cancel(默认)，推迟至cancel点再响应<br>&emsp;cancel点：POSIX定义的cancel点，都是<strong>可能引发阻塞的系统调用</strong><br>            pthread_setcancelstate()：设置是否允许取消    pthread_setcanceltype()：设置取消方式<br><strong>pthread_testcancel()：本函数什么都不做，就是一个cancel点(人为设置cancel点)</strong></p><p>   线程分离<br>    pthread_detach(); 设置线程的分离属性，其它线程不能对它回收。</p><br>4、线程属性:<p><strong>80%的问题用默认属性就可以解决</strong>。</p><p>&emsp;pthread_attr_init();<br>    &emsp;pthread_attr_destroy();<br>    &emsp;pthread_attr_setstacksize();<br>    &emsp;pthread_attr_setdetachstate();<br>&emsp;其它见man pthread_attr_init中的see also</p><p>   线程同步的属性<br>    互斥量属性：<br>        &emsp;pthread_mutexattr_init();<br>        &emsp;pthread_mutexattr_destroy();<br>        是否跨进程起作用：<br>        &emsp;pthread_mutexattr_getpshared();<br>        &emsp;pthread_mutexattr_setpshared();<br>&emsp;clone();//<em>可自定义地创建所需要的线程或进程</em><br>        互斥量类型：<br>        &emsp;pthread_mutexattr_gettype();<br>        &emsp;pthread_mutexattr_settype();<br>    条件变量属性：<br>        &emsp;pthread_condattr_init();<br>        &emsp;pthread_condattr_destroy();<br>        。。。。<br>    读写锁属性：<br>        。。。。</p><p>5、重入<br>   ①多线程中的IO<br>        <em>stdio默认都是支持多线程并发的</em>，先lock缓冲区，东西放进去，unlock。<br>        （<em>也有不加锁的版本</em>，可以尝试man getchar_unlocked查看）</p><p>   ②线程与信号<br>            <strong>每个线程都有mask和pending位图，而进程只有一个pending位图。每个线程从内核态<br>        退出时，先用mask与进程的pending按位与，再与线程的pending按位与</strong>。<br>                pthread_sigmask();<br>sigwait();<br>pthread_kill();</p><p>   ③线程与fork</p><p>6、openmp线程标准<br>    <a href="http://www.OpenMP.org" target="_blank" rel="noopener">www.OpenMP.org</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;会话承载进程组，进程组承载进程，进程承载线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、线程的概念&lt;br&gt;    &lt;strong&gt;一个正在运行的函数&lt;br&gt;    多个线程的地址空间是共享的（代码段是共用的，栈是独立的）&lt;/strong&gt;&lt;br&gt;    posi
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="pthread" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>【apue】信号进阶</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BF%A1%E5%8F%B7%E8%BF%9B%E9%98%B6/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BF%A1%E5%8F%B7%E8%BF%9B%E9%98%B6/</id>
    <published>2020-07-25T15:01:00.000Z</published>
    <updated>2020-07-25T16:26:18.306Z</updated>
    
    <content type="html"><![CDATA[<p>7、信号集<br>&emsp;信号集类型：sigset_t<br>&emsp;sigemptyset();<br>&emsp;sigfillset();<br>&emsp;sigaddset();<br>&emsp;sigdelset();<br>&emsp;sigismember();</p><p>8、信号屏蔽字/pending集的处理<br>&emsp;sigprocmask();//设置信号屏蔽字，可以决定信号什么时候才响应。<br>&emsp;原型：int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);//set是信号集合，how是处理/操作方式</p><blockquote><p>首先，若oldset是非空指针，那么进程的当前信号屏蔽字通过oset返回。<br>其次，若set是一个非空指针，则参数how指示如何修改当前信号屏蔽字。<br>注意，不能阻塞SIGKILL和SIGSTOP信号。</p></blockquote><p>how有三种行为：SIG_BLOCK，阻塞某信号，即将mask中该信号对应的位清0；SIG_UNBLOCK，解除阻塞，即将mask的对应位恢复成1；SIG_SETMASK，直接设置屏蔽字。</p><p>block.c例程（<strong>阻塞SIGINT信号</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void int_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    write(1,<span class="string">"!"</span>,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    sigset_t <span class="built_in">set</span>,oset,saveset;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = 0; j &lt; 1000; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(1,<span class="string">"*"</span>,1);</span><br><span class="line">            sleep(1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        write(1,<span class="string">"\n"</span>,1);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;oset,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、<strong>扩展(重要！)</strong><br>    sigsuspend();//wait for signal，原子操作；<br>    解除某个信号集的阻塞状态，马上进入等待信号阶段，信号一定会砸到sigsuspend();<br>    <strong>pause()的缺陷：不用用于信号驱动程序（有信号到来才能继续执行）<br>    信号驱动程序中，不能用pause()来等待一个信号，因为它是非原子操作，信号砸不到pause()上。</strong></p><p><strong>信号驱动例程（有SIGINT到来才能继续打印）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void int_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    write(1,<span class="string">"!"</span>,1);</span><br><span class="line">&#125;//</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    sigset_t <span class="built_in">set</span>,oset,saveset;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;saveset);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oset);</span><br><span class="line">    <span class="keyword">for</span>(j = 0; j &lt; 1000; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(1,<span class="string">"*"</span>,1);</span><br><span class="line">            sleep(1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        write(1,<span class="string">"\n"</span>,1);</span><br><span class="line">        sigsuspend(&amp;oset);//等待一个信号</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;saveset,NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sigaction();//用来替换signal();<br><strong>signal()中的缺陷：<br>&emsp;多个信号可以共用一个信号处理函数，容易发生重入。<br>&emsp;没有区别信号的来源，容易被别的用户干涉。</strong><br>    int sigaction(int signum, const struct sigaction <em>act,<br>                     struct sigaction *oldact);<br>    struct sigaction {<br>               void     (</em>sa_handler)(int);<br>               void     (<em>sa_sigaction)(int, siginfo_t *, void *);<br>               sigset_t   sa_mask;<br>               int        sa_flags;<br>               void     (</em>sa_restorer)(void);<br>           };<br>    ①sa_handler和sa_sigaction不能同时设置，可以理解为它俩是共用体；<br>    ②sa_mask:在响应当前信号时，还需要将哪些信号block住；<br>    ③三参的信号处理函数：<br>        int是信号类别，当多个信号可以共用一个信号处理函数时有意义；<br>        siginfo_t是信号属性结构体，其中最常用的是sig_code（从哪来，用户，内核，信号队列，，，）<br>                 从而可以决定是否响应该信号，使其只响应从指定位置来的信号。<br>        void *，第三个参数不再使用，原来为ucontext_t *类型，保存信号响应之前的上下文</p></blockquote><p>用sigaction函数(单参)重构mydaemon.c（<strong>防止重入</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static FILE *fp;</span><br><span class="line">static void daemon_exit(int s)</span><br><span class="line">&#123;</span><br><span class="line">    //fprintf(fp,<span class="string">"mydaemon_exit()\n"</span>);//测试时用</span><br><span class="line">    fclose(fp);</span><br><span class="line">    closelog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    struct sigaction sa;</span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"mydaemon"</span>,LOG_PID,LOG_DAEMON);//关联syslog，想要写日志的人物为mydaemon，日志包含其pid，日志的来源为守护进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sa.sa_handler = daemon_exit;//信号处理函数</span><br><span class="line">    sa.sa_flags = 0;//没有特殊要求</span><br><span class="line"></span><br><span class="line">    //信号在响应过程中要屏蔽的信号集，防止重入</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    //在响应SIGINT时，其本身也是被屏蔽着的；换句话说，在响应SIGINT时，下面三个</span><br><span class="line">信号都是被屏蔽住的</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGINT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask,SIGTERM);</span><br><span class="line"></span><br><span class="line">    //注册信号及其响应行为</span><br><span class="line">    sigaction(SIGINT,&amp;sa,NULL);</span><br><span class="line">    sigaction(SIGQUIT,&amp;sa,NULL);</span><br><span class="line">    sigaction(SIGTERM,&amp;sa,NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = creatdaemon();</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR,<span class="string">"creatdaemon() failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        syslog(LOG_INFO,<span class="string">"creatdaemon() success!"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    daemontask();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://file.moetu.org/images/2020/07/25/sigaction0c52dcb349719bd1.png" alt="注意：前面的ctrl+c未响应，是因为中断信号发给了当前shell进程，而不是发给mydaemon的" title="" class="">                <p>注意：前面的ctrl+c未响应，是因为中断信号发给了当前shell进程，而不是发给mydaemon的</p>            </figure><br>    setitimer();//用来替换alarm();    setitimer()，设置时钟周期，误差不累积，精度到us。    倒计时到0时发送时钟信号，且会将it_interval赋给it_value，进入下一个周期。<p><strong>尝试1：使用单一计时器，利用alarm或setitimer构造一组函数，实现任意数量的计时器。</strong></p><figure class="image-box">                <img src="https://file.moetu.org/images/2020/07/25/anytimerf1458c5094c43365.png" alt="效果图" title="" class="">                <p>效果图</p>            </figure><p>参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef ANYTIMER_H__</span></span><br><span class="line"><span class="comment">#define ANYTIMER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define JOB_MAX 1024</span></span><br><span class="line"><span class="comment">#define ARGSIZE 1024</span></span><br><span class="line">typedef void jobfunc_t(char *);</span><br><span class="line"></span><br><span class="line">typedef enum jobstat</span><br><span class="line">&#123;</span><br><span class="line">    Running,</span><br><span class="line">    Cancel,      </span><br><span class="line">    Pause,      </span><br><span class="line">    Finish</span><br><span class="line">&#125;estat;</span><br><span class="line"></span><br><span class="line">struct timjob_st</span><br><span class="line">&#123;</span><br><span class="line">    int time;   //设置的时间 </span><br><span class="line">    int sec;    //倒计时时间</span><br><span class="line">    jobfunc_t *jobp;</span><br><span class="line">    char arg[ARGSIZE];</span><br><span class="line">    estat <span class="built_in">stat</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************************</span><br><span class="line">*<span class="built_in">return</span> &gt;= 0        成功，返回任务id</span><br><span class="line">*       == -ENOSPC  失败，数组满</span><br><span class="line">*       == -ENOMEM  失败，内存空间不足</span><br><span class="line">*******************************/</span><br><span class="line">int at_addjob(int time,jobfunc_t *jobp,char *arg);</span><br><span class="line"></span><br><span class="line">int at_canceljob(int id);   //取消任务，能计时但不会执行动作  </span><br><span class="line">int at_deljob(int id);      //执行动作完成，可销毁</span><br><span class="line">//int at_pausejob(int id);//暂时没用到</span><br><span class="line">//int at_resumejob(int id);</span><br><span class="line">int job_num(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p><strong>尝试2：用刚学到的setitimer和sigaction函数（三参）重构令牌桶程序（只有来自内核的SIGALRM信号才有效）</strong><br>原来的令牌桶程序的bug：令牌桶程序（./mytbf /etc/services）在运行，如果有其它进程向它不断发送SIGALRM信号（新建shell，命令行输入 while true; do kill -SIGALRM ‘pid’; done），流速直接上升到峰值，内容很快输出完毕。</p><p>10、实时信号<br>①实时信号是要排队的，它的响应是有顺序要求的。<br>②既收到实时信号又收到标准信号，先响应标准信号。<br>③实时信号不丢失。</p><p>还是之前的信号驱动例程，用实时信号（SIGRTMIN+6）替换SIGINT；编译执行，新建终端，命令行输入kill -40 pid，发送多次时，可以观察到信号没有丢失，都得到了响应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7、信号集&lt;br&gt;&amp;emsp;信号集类型：sigset_t&lt;br&gt;&amp;emsp;sigemptyset();&lt;br&gt;&amp;emsp;sigfillset();&lt;br&gt;&amp;emsp;sigaddset();&lt;br&gt;&amp;emsp;sigdelset();&lt;br&gt;&amp;emsp;sigisme
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="sigaction, setitimer" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/sigaction-setitimer/"/>
    
      <category term="实现anytimer" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E5%AE%9E%E7%8E%B0anytimer/"/>
    
  </entry>
  
  <entry>
    <title>【apue】令牌桶封装</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BB%A4%E7%89%8C%E6%A1%B6%E5%B0%81%E8%A3%85/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BB%A4%E7%89%8C%E6%A1%B6%E5%B0%81%E8%A3%85/</id>
    <published>2020-07-25T14:37:00.000Z</published>
    <updated>2020-07-25T14:59:26.236Z</updated>
    
    <content type="html"><![CDATA[<p>将令牌桶封装成一个库，以便满足多个用户或进程的不同流控需求。</p><p>mkdir mytbf<br>cd mytbf<br>touch main.c mytbf.c mytbf.h makefile</p><blockquote><p>补充vim多标签：同时打开编辑多个文件<br>vim * -p //打开当前目录下所有文件<br><br>切换标签<br>    :tabr    跳到第一个标签<br>    :tabl    跳到最后一个标签<br>    :tabn    下一个标签，快捷方式gt<br>    :tabp    上一个标签，快捷方式gT<br><br>关闭与保存<br>    :wall    保存所有标签<br>    :qall    退出所有标签<br>    :q        关闭当前标签<br>    :only    只保留当前标签<br><br>新建文件<br>    :tabnew</p></blockquote><p>makefile文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all:mytbf</span><br><span class="line"></span><br><span class="line">mytbf:main.o mytbf.o</span><br><span class="line">    gcc $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">clean: </span><br><span class="line">    rm -rf *.o mytbf</span><br></pre></td></tr></table></figure><p>可能遇到的问题：makefile:3: *** missing separator (did you mean TAB instead of 8 spaces?).  Stop.</p><blockquote><p>原因：vimrc中设置了用4个空格替换tab键。<br>解决：非编辑模式下输入:%s/^[ ]+/\t/g</p></blockquote><p>mytbf.h文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> main.c  makefile  mytbf.c  mytbf.h                                          X</span><br><span class="line"><span class="comment">#ifndef MYTBF_H__</span></span><br><span class="line"><span class="comment">#define MYTBF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MYTBF_MAX 1024</span></span><br><span class="line"></span><br><span class="line">typedef void mytbf_t;</span><br><span class="line"></span><br><span class="line">mytbf_t *mytbf_init(int cps,int burst);</span><br><span class="line"></span><br><span class="line">int mytbf_fetchtoken(mytbf_t *ptr,int size);</span><br><span class="line"></span><br><span class="line">int mytbf_returntoken(mytbf_t *ptr,int size);</span><br><span class="line"></span><br><span class="line">int mytbf_destory(mytbf_t *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p>mytbf.c文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include "mytbf.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef void (*sighandler_t) (int);</span><br><span class="line"></span><br><span class="line">struct mytbf_st</span><br><span class="line">&#123;</span><br><span class="line">    int cps;</span><br><span class="line">    int burst;</span><br><span class="line">    int token;</span><br><span class="line">    int pos;</span><br><span class="line">&#125;;</span><br><span class="line">static int inited = 0;</span><br><span class="line">static struct mytbf_st *job[MYTBF_MAX];//static,默认初始化为0</span><br><span class="line"></span><br><span class="line">sighandler_t alrm_handler_save;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    alarm(1);//设置下一秒的时钟</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            job[i]-&gt;token += job[i]-&gt;cps;</span><br><span class="line">            <span class="keyword">if</span>(job[i]-&gt;token &gt; job[i]-&gt;burst)</span><br><span class="line">                job[i]-&gt;token = job[i]-&gt;burst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void module_unload(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    signal(SIGALRM,alrm_handler_save);//恢复原来的行为</span><br><span class="line">    alarm(0);//将闹钟关掉</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        free(job[i]);</span><br><span class="line">        job[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void module_load(void)</span><br><span class="line">&#123;</span><br><span class="line">    alrm_handler_save = signal(SIGALRM,alrm_handler);</span><br><span class="line">    alarm(1);</span><br><span class="line"></span><br><span class="line">    atexit(module_unload);</span><br><span class="line">&#125;</span><br><span class="line">static int get_free_pos(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; MYTBF_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(job[i] == NULL)</span><br><span class="line">            <span class="built_in">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mytbf_t *mytbf_init(int cps,int burst)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me;</span><br><span class="line">    int pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inited)</span><br><span class="line">    &#123;</span><br><span class="line">        module_load();</span><br><span class="line">        inited = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pos = get_free_pos();</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> NULL;//令牌桶个数达到上限</span><br><span class="line"></span><br><span class="line">    me = malloc(sizeof(*me));</span><br><span class="line">        <span class="keyword">if</span>(me == NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;//malloc失败</span><br><span class="line"></span><br><span class="line">    me-&gt;cps = cps;</span><br><span class="line">    me-&gt;burst = burst;</span><br><span class="line">    me-&gt;token = 0;</span><br><span class="line">    me-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line">    job[pos] = me;</span><br><span class="line">    <span class="built_in">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line">static int min(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="built_in">return</span> a;</span><br><span class="line">    <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//size为想要取的token数，返回值为实际取得的token数</span><br><span class="line">int mytbf_fetchtoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(me-&gt;token &lt;= 0)</span><br><span class="line">        pause();</span><br><span class="line"></span><br><span class="line">    n = min(me-&gt;token,size);</span><br><span class="line"></span><br><span class="line">    me-&gt;token -= n;</span><br><span class="line">    <span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归还未使用的token</span><br><span class="line">int mytbf_returntoken(mytbf_t *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    me-&gt;token += size;</span><br><span class="line">    <span class="keyword">if</span>(me-&gt;token &gt; me-&gt;burst)</span><br><span class="line">        me-&gt;token = me-&gt;burst;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int mytbf_destory(mytbf_t *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct mytbf_st *me = ptr;//转换</span><br><span class="line"></span><br><span class="line">    job[me-&gt;pos] = NULL;</span><br><span class="line">    free(ptr);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include "mytbf.h"</span></span><br><span class="line"><span class="comment">#define CPS 10 //流控制，每秒10个字符    </span></span><br><span class="line"><span class="comment">#define BUFSIZE 1024</span></span><br><span class="line"><span class="comment">#define BURST 100   //最多只能攒100次权限</span></span><br><span class="line"></span><br><span class="line">//令牌桶：没有数据到来，就攒权限；数据来时，连续读写token次。</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mytbf_t *tbf;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    long len,ret,pos;</span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage ...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tbf = mytbf_init(CPS,BURST);//初始化一个令牌桶</span><br><span class="line">    <span class="keyword">if</span>(tbf == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"mytbf_init() fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fd = open(argv[1],O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(fd &lt; 0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">        size  = mytbf_fetchtoken(tbf,BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span>(size &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,<span class="string">"mytbf_fetchtoken() fail:%s\n"</span>,strerror(-size));</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( (len = <span class="built_in">read</span>(fd,buf,size)) &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(len == 0)//没有数据到来或已读取完成，继续等待新数据</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(size - len &gt; 0)//有可能没消耗完token，，文件尾</span><br><span class="line">            mytbf_returntoken(tbf,size-len);</span><br><span class="line"></span><br><span class="line">        pos = 0;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; 0) //防止漏写</span><br><span class="line">        &#123;</span><br><span class="line">            ret = write(1,buf+pos,len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret; //这次又写了ret个字节，pos是已写的字节数</span><br><span class="line">            len -= ret; //还剩多少个字节没写</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    mytbf_destory(tbf);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将令牌桶封装成一个库，以便满足多个用户或进程的不同流控需求。&lt;/p&gt;
&lt;p&gt;mkdir mytbf&lt;br&gt;cd mytbf&lt;br&gt;touch main.c mytbf.c mytbf.h makefile&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;补充vim多标签：同时打开编
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="vim 多标签" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/vim-%E5%A4%9A%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>【apue】漏桶与令牌桶</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E6%BC%8F%E6%A1%B6%E4%B8%8E%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E6%BC%8F%E6%A1%B6%E4%B8%8E%E4%BB%A4%E7%89%8C%E6%A1%B6/</id>
    <published>2020-07-25T11:02:00.000Z</published>
    <updated>2020-07-25T11:54:33.106Z</updated>
    
    <content type="html"><![CDATA[<p>漏桶：每秒打印10个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#define CPS 10 //流控制，每秒10个字符    </span></span><br><span class="line"><span class="comment">#define BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static volatile int loop = 1;</span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    alarm(1);//设置下一秒时钟</span><br><span class="line">    loop = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int fd;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    long len,ret,pos;</span><br><span class="line">    struct itimerval itv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"usage ...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    signal(SIGALRM,alrm_handler);</span><br><span class="line">    alarm(1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        fd = open(argv[1],O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(fd &lt; 0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop)</span><br><span class="line">            pause();// 等待时钟信号</span><br><span class="line">        loop = 1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( (len = <span class="built_in">read</span>(fd,buf,BUFSIZE)) &lt; 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)//如果是中断打断了读操作，则不报错，重新读</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == 0)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = 0;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; 0) //防止漏写</span><br><span class="line">        &#123;</span><br><span class="line">            ret = write(1,buf+pos,len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(1);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret; //这次又写了ret个字节，pos是已写的字节数</span><br><span class="line">            len -= ret; //还剩多少个字节没写</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://file.moetu.org/images/2020/07/25/e9ebf16bb9f0c42038e51f012c214fe1cc4b9a0c89cfa248.png" alt="" title="" class="">                <p></p>            </figure><br>令牌桶：漏桶的优化<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define BURST 100   //最多只能攒100次权限</span></span><br><span class="line"></span><br><span class="line">//没有数据到来，就攒权限；数据来时，连续读写token次。</span><br><span class="line"></span><br><span class="line">static volatile sig_atomic_t token = 0;</span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    alarm(1);</span><br><span class="line">    token++; </span><br><span class="line">    <span class="keyword">if</span>(token &gt; BURST)</span><br><span class="line">        token = BURST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(token &lt;= 0)//没有token</span><br><span class="line">            pause();</span><br><span class="line">        token--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( (len = <span class="built_in">read</span>(fd,buf,BUFSIZE)) &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(len == 0)//没有数据或已读取完成，继续等新的数据</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>测试方法：先准备一个有少量数据的文件/tmp/out，命令行./slowcat2 /tmp/out，数据以10字符/s打印完成后等待新数据到来；等一会儿，新建终端，输入cat /etc/services &gt;&gt; /tmp/out追加数据到/tmp/out，这时因为攒的权限够多，所以可以观察到：回车后瞬间输出大量内容，然后恢复10字符/s的打印速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;漏桶：每秒打印10个字符&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="流控" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E6%B5%81%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>【apue】信号基础</title>
    <link href="https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BF%A1%E5%8F%B7/"/>
    <id>https://cral-freedom.github.io/zhoujiabo.github.io/2020/07/25/%E3%80%90apue%E3%80%91%E4%BF%A1%E5%8F%B7/</id>
    <published>2020-07-25T09:07:00.000Z</published>
    <updated>2020-07-25T10:48:03.048Z</updated>
    
    <content type="html"><![CDATA[<p>先补充两个概念:</p><p>同步，用户知道什么时候发生什么事件。（单进程程序）<br>异步，这个事件什么时候到来不知道，会产生什么结果不知道。</p><p>异步事件的处理：查询法，通知法<br>发生频率稀疏—通知法（但是也要有相应的机制监听）</p><p>一、信号</p><p>1、信号的概念<br>    <strong>信号是软件层面的中断。信号的响应依赖于中断。</strong></p><p>2、signal()<br>#include &lt;signal.h&gt;<br>typedef void (*sighandler_t)(int);    //sighandler_t是函数指针，返回值为void，参数为int<br>sighandler_t signal(int signum, sighandler_t handler);<br>@param：<br>    signum：为信号编号，如SIGINT表示终端中断符，ctrl+c是其快捷方式<br>    handler：为函数指针，也可以是SIG_IGN忽略信号，或SIG_DFL默认动作<br>@return：上一个信号的行为</p><p>void ( *signal(int signum, void (*func)(int)) )(int)<br>//头文件中没有sighandler_t的定义，每次要用时在文件头加typedef void (*sighandler_t)(int);</p><p>signal小例程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void int_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    write(1,<span class="string">"!"</span>,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,int_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(1,<span class="string">"*"</span>,1);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言的缺陷之一：名空间管理不善，如果名字冲突就完蛋了。</p><p>信号会打断阻塞的系统调用。<br>    查看man手册知open存在返回值为EINTR的情况，<strong>当阻塞等待打开一个慢设备时，调用可能被信号打断。<br>    所以在使用阻塞系统调用时，要判断是真错还是假错（被信号打断）</strong></p><p>重构mycpy.c中open和read内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    sfd = open(argv[1], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(sfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR)//不是信号导致的打开失败</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //<span class="keyword">else</span> <span class="built_in">continue</span>;//是假错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(sfd &lt; 0);</span><br></pre></td></tr></table></figure><p>3、信号的不可靠<br>    信号的行为不可靠，执行现场是由内核布置的，<strong>有可能第一次调用还没结束就发生了第二次调用。</strong></p><p>4、可重入函数<br>    所有的系统调用都是可重入的，一部分库函数也是可重入的，如memcpy</p><p><strong>一些库函数其本身是不可重入的，所以需要额外的_r版本函数，<br>如rand_r,localtime_r,,,专门用于信号处理。</strong></p><p>5、<strong>信号的响应过程（重点）</strong></p><p>2个位图，mask，pending，理论上是32位的。<br>mask是信号屏蔽字（初始全为1），pending位图（初始全为0）</p><p>&emsp;从内核回到用户态时要进行mask&amp;pending，如果有信号到来(pending对应位为1)，则将mask，pending中的信号位归0，<br>栈中PC寄存器值表示的执行位置地址换成int_handler函数地址；响应完成后，mask对应信号位恢复，<br>PC寄存器值也恢复原来的执行位置。</p><blockquote><p>总结与思考：<br>①信号从收到到响应有一个不可避免的延迟。<br>&emsp;信号是进程从kernel回到user的路上响应的。<br>②如何忽略掉一个信号？<br>&emsp;SIG_IGN实现实际就是将mask中表示某信号的位置0<br>③标准信号为什么要丢失？<br>&emsp;位图不会计数<br>④标准信号的响应没有严格的顺序<br>⑤不能从信号处理函数中随意的往外跳。（可能会错过mask的恢复过程，sigsetjump,siglongjump）</p></blockquote><p>6、常用函数<br>    kill();//发信号，int kill(pid_t pid, int sig);<br>&emsp;参数pid:<br>&emsp;&emsp;&gt;0，发送信号到对应pid的进程<br>&emsp;&emsp;0，当前进程的进程组广播（组内广播）<br>&emsp;&emsp;-1，发送信号到init以外的所有进程（全局广播），一般是Init进程用来广播通知所有进程终止。<br>&emsp;&emsp;&lt;-1，发送信号到ID为|-pid|的进程组中的所有进程（特定gid的组广播）。<br>&emsp;参数sig：为0时，不会发送信号，用于测试一个进程或进程组是否存在。<br>&emsp;errno：EPERM，没有发送信号的权限；ESRCH，进程或进程组不存在</p><p>raise();//发送信号给当前进程，int raise(int sig);</p><p>alarm();//设置时钟信号，unsigned int alarm(unsigned int seconds);<br>&emsp;当seconds倒计时到0，产生SIGALRM信号，默认动作是终止当前进程。<br><strong>有些平台sleep是用alarm+pause封装的。所以不要在程序中混用alarm和sleep。</strong></p><p>pause();//等待一个信号<br>abort();</p><p>system();<br>&emsp;想要在有信号的进程当中使用system，需要blocked掉SIGCHLD，ignored掉SIGIINT和SIGQUIT。</p><p>sleep();的替代函数：<br>&emsp;nanosleep();<br>&emsp;usleep();<br>&emsp;select();</p><p>alarm小例程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line">static volatile int loop = 0;</span><br><span class="line">static void alrm_handler(int s)</span><br><span class="line">&#123;</span><br><span class="line">    loop = 1;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t count = 0;</span><br><span class="line">    signal(SIGALRM,alrm_handler);</span><br><span class="line">    alarm(5);</span><br><span class="line">    <span class="keyword">while</span>(!loop)//5s内count能加到几？</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc -S 5sec_sig.c -O1    //对源文件进行优化，获取其汇编文件<br>查看其汇编文件，while(loop)会陷入死循环，因为是去内存中取的loop的值，没有变过。<br>解决：volatile修饰loop，去这个变量的真正空间取数值。</p><p>测试结果：优化之后得到的count大约是原来计数值的7倍。</p><figure class="image-box">                <img src="https://file.moetu.org/images/2020/07/25/8de76ea3f17269cb6bd94dd00d81d6b529fb6ec6c20192fb.png" alt="" title="" class="">                <p></p>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先补充两个概念:&lt;/p&gt;
&lt;p&gt;同步，用户知道什么时候发生什么事件。（单进程程序）&lt;br&gt;异步，这个事件什么时候到来不知道，会产生什么结果不知道。&lt;/p&gt;
&lt;p&gt;异步事件的处理：查询法，通知法&lt;br&gt;发生频率稀疏—通知法（但是也要有相应的机制监听）&lt;/p&gt;
&lt;p&gt;一、信号&lt;
      
    
    </summary>
    
    
      <category term="Linux系统编程" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="信号" scheme="https://cral-freedom.github.io/zhoujiabo.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
</feed>
